{"ast":null,"code":"'use strict';\n\nconst net = require('net');\n\nconst uniq = require('lodash.uniq');\n\nconst analyticsSampler = require('../../analytics_sampler');\n\nconst FORMAT_HTTP_HEADERS = 'http_headers';\n\nconst log = require('../../log');\n\nconst tags = require('../../../../../ext/tags');\n\nconst types = require('../../../../../ext/types');\n\nconst kinds = require('../../../../../ext/kinds');\n\nconst urlFilter = require('./urlfilter');\n\nconst BlockList = require('./ip_blocklist');\n\nconst {\n  incomingHttpRequestEnd\n} = require('../../appsec/gateway/channels');\n\nconst WEB = types.WEB;\nconst SERVER = kinds.SERVER;\nconst RESOURCE_NAME = tags.RESOURCE_NAME;\nconst SERVICE_NAME = tags.SERVICE_NAME;\nconst SPAN_TYPE = tags.SPAN_TYPE;\nconst SPAN_KIND = tags.SPAN_KIND;\nconst ERROR = tags.ERROR;\nconst HTTP_METHOD = tags.HTTP_METHOD;\nconst HTTP_URL = tags.HTTP_URL;\nconst HTTP_STATUS_CODE = tags.HTTP_STATUS_CODE;\nconst HTTP_ROUTE = tags.HTTP_ROUTE;\nconst HTTP_REQUEST_HEADERS = tags.HTTP_REQUEST_HEADERS;\nconst HTTP_RESPONSE_HEADERS = tags.HTTP_RESPONSE_HEADERS;\nconst HTTP_USERAGENT = tags.HTTP_USERAGENT;\nconst HTTP_CLIENT_IP = tags.HTTP_CLIENT_IP;\nconst MANUAL_DROP = tags.MANUAL_DROP;\nconst HTTP2_HEADER_AUTHORITY = ':authority';\nconst HTTP2_HEADER_SCHEME = ':scheme';\nconst HTTP2_HEADER_PATH = ':path';\nconst ipHeaderList = ['x-forwarded-for', 'x-real-ip', 'client-ip', 'x-forwarded', 'x-cluster-client-ip', 'forwarded-for', 'forwarded', 'via', 'true-client-ip'];\nconst contexts = new WeakMap();\nconst ends = new WeakMap();\nconst web = {\n  // Ensure the configuration has the correct structure and defaults.\n  normalizeConfig(config) {\n    config = config.server || config;\n    const headers = getHeadersToRecord(config);\n    const validateStatus = getStatusValidator(config);\n    const hooks = getHooks(config);\n    const filter = urlFilter.getFilter(config);\n    const middleware = getMiddlewareSetting(config);\n    const queryStringObfuscation = getQsObfuscator(config);\n    return Object.assign({}, config, {\n      headers,\n      validateStatus,\n      hooks,\n      filter,\n      middleware,\n      queryStringObfuscation\n    });\n  },\n\n  setFramework(req, name, config) {\n    const context = this.patch(req);\n    const span = context.span;\n    if (!span) return;\n    span.context()._name = `${name}.request`;\n    web.setConfig(req, config);\n  },\n\n  setConfig(req, config) {\n    const context = contexts.get(req);\n    const span = context.span;\n    context.config = config;\n\n    if (!config.filter(req.url)) {\n      span.setTag(MANUAL_DROP, true);\n      span.context()._trace.isRecording = false;\n    }\n\n    if (config.service) {\n      span.setTag(SERVICE_NAME, config.service);\n    }\n\n    analyticsSampler.sample(span, config.measured, true);\n  },\n\n  startSpan(tracer, config, req, res, name) {\n    const context = this.patch(req);\n    let span;\n\n    if (context.span) {\n      context.span.context()._name = name;\n      span = context.span;\n    } else {\n      span = web.startChildSpan(tracer, name, req.headers);\n    }\n\n    context.tracer = tracer;\n    context.span = span;\n    context.res = res;\n    this.setConfig(req, config);\n    return span;\n  },\n\n  wrap(req) {\n    const context = contexts.get(req);\n\n    if (!context.instrumented) {\n      this.wrapEnd(context);\n      context.instrumented = true;\n    }\n  },\n\n  // Start a span and activate a scope for a request.\n  instrument(tracer, config, req, res, name, callback) {\n    const span = this.startSpan(tracer, config, req, res, name);\n    this.wrap(req);\n    return callback && tracer.scope().activate(span, () => callback(span));\n  },\n\n  // Reactivate the request scope in case it was changed by a middleware.\n  reactivate(req, fn) {\n    return reactivate(req, fn);\n  },\n\n  // Add a route segment that will be used for the resource name.\n  enterRoute(req, path) {\n    if (typeof path === 'string') {\n      contexts.get(req).paths.push(path);\n    }\n  },\n\n  setRoute(req, path) {\n    const context = contexts.get(req);\n    if (!context) return;\n    context.paths = [path];\n  },\n\n  // Remove the current route segment.\n  exitRoute(req) {\n    contexts.get(req).paths.pop();\n  },\n\n  // Start a new middleware span and activate a new scope with the span.\n  wrapMiddleware(req, middleware, name, fn) {\n    if (!this.active(req)) return fn();\n    const context = contexts.get(req);\n    const tracer = context.tracer;\n    const childOf = this.active(req);\n    const config = context.config;\n    if (config.middleware === false) return this.bindAndWrapMiddlewareErrors(fn, req, tracer, childOf);\n    const span = tracer.startSpan(name, {\n      childOf\n    });\n    analyticsSampler.sample(span, config.measured);\n    span.addTags({\n      [RESOURCE_NAME]: middleware._name || middleware.name || '<anonymous>'\n    });\n    context.middleware.push(span);\n    return tracer.scope().activate(span, fn);\n  },\n\n  // catch errors and apply to active span\n  bindAndWrapMiddlewareErrors(fn, req, tracer, activeSpan) {\n    try {\n      return tracer.scope().bind(fn, activeSpan).apply(this, arguments);\n    } catch (e) {\n      web.addError(req, e); // TODO: remove when error formatting is moved to Span\n\n      throw e;\n    }\n  },\n\n  // Finish the active middleware span.\n  finish(req, error) {\n    if (!this.active(req)) return;\n    const context = contexts.get(req);\n    const span = context.middleware.pop();\n\n    if (span) {\n      if (error) {\n        span.addTags({\n          'error.type': error.name,\n          'error.msg': error.message,\n          'error.stack': error.stack\n        });\n      }\n\n      span.finish();\n    }\n  },\n\n  // Register a callback to run before res.end() is called.\n  beforeEnd(req, callback) {\n    contexts.get(req).beforeEnd.push(callback);\n  },\n\n  // Prepare the request for instrumentation.\n  patch(req) {\n    let context = contexts.get(req);\n    if (context) return context;\n    context = req.stream && contexts.get(req.stream);\n\n    if (context) {\n      contexts.set(req, context);\n      return context;\n    }\n\n    context = {\n      req,\n      span: null,\n      paths: [],\n      middleware: [],\n      beforeEnd: [],\n      config: {}\n    };\n    contexts.set(req, context);\n    return context;\n  },\n\n  // Return the request root span.\n  root(req) {\n    const context = contexts.get(req);\n    return context ? context.span : null;\n  },\n\n  // Return the active span.\n  active(req) {\n    const context = contexts.get(req);\n    if (!context) return null;\n    if (context.middleware.length === 0) return context.span || null;\n    return context.middleware.slice(-1)[0];\n  },\n\n  // Extract the parent span from the headers and start a new span as its child\n  startChildSpan(tracer, name, headers) {\n    const childOf = tracer.scope().active() || tracer.extract(FORMAT_HTTP_HEADERS, headers);\n    const span = tracer.startSpan(name, {\n      childOf\n    });\n    return span;\n  },\n\n  // Validate a request's status code and then add error tags if necessary\n  addStatusError(req, statusCode) {\n    const context = contexts.get(req);\n    const span = context.span;\n    const error = context.error;\n\n    const hasExistingError = span.context()._tags['error'] || span.context()._tags['error.msg'];\n\n    if (!hasExistingError && !context.config.validateStatus(statusCode)) {\n      span.setTag(ERROR, error || true);\n    }\n  },\n\n  // Add an error to the request\n  addError(req, error) {\n    if (error instanceof Error) {\n      const context = contexts.get(req);\n\n      if (context) {\n        context.error = error;\n      }\n    }\n  },\n\n  finishMiddleware(context) {\n    if (context.finished) return;\n    let span;\n\n    while (span = context.middleware.pop()) {\n      span.finish();\n    }\n  },\n\n  finishSpan(context) {\n    const {\n      req,\n      res\n    } = context;\n    if (context.finished && !req.stream) return;\n    addRequestTags(context);\n    addResponseTags(context);\n    context.config.hooks.request(context.span, req, res);\n    addResourceTag(context);\n    context.span.finish();\n    context.finished = true;\n  },\n\n  finishAll(context) {\n    const {\n      req,\n      res\n    } = context;\n\n    for (const beforeEnd of context.beforeEnd) {\n      beforeEnd();\n    }\n\n    web.finishMiddleware(context);\n\n    if (incomingHttpRequestEnd.hasSubscribers) {\n      incomingHttpRequestEnd.publish({\n        req,\n        res\n      });\n    }\n\n    web.finishSpan(context);\n  },\n\n  obfuscateQs(config, url) {\n    const {\n      queryStringObfuscation\n    } = config;\n    if (queryStringObfuscation === false) return url;\n    const i = url.indexOf('?');\n    if (i === -1) return url;\n    const path = url.slice(0, i);\n    if (queryStringObfuscation === true) return path;\n    let qs = url.slice(i + 1);\n    qs = qs.replace(queryStringObfuscation, '<redacted>');\n    return `${path}?${qs}`;\n  },\n\n  extractIp(context) {\n    const {\n      req,\n      config\n    } = context;\n    if (config.clientIpHeaderDisabled) return;\n    const headers = req.headers;\n\n    if (config.clientIpHeader) {\n      const header = headers[config.clientIpHeader];\n      if (!header) return;\n      return findFirstIp(header);\n    }\n\n    const foundHeaders = [];\n\n    for (let i = 0; i < ipHeaderList.length; i++) {\n      if (headers[ipHeaderList[i]]) {\n        foundHeaders.push(ipHeaderList[i]);\n      }\n    }\n\n    if (foundHeaders.length === 1) {\n      const header = headers[foundHeaders[0]];\n      const firstIp = findFirstIp(header);\n      if (firstIp) return firstIp;\n    } else if (foundHeaders.length > 1) {\n      log.error(`Cannot find client IP: multiple IP headers detected ${foundHeaders}`);\n      return;\n    }\n\n    return req.socket && req.socket.remoteAddress;\n  },\n\n  wrapWriteHead(context) {\n    const {\n      req,\n      res\n    } = context;\n    const writeHead = res.writeHead;\n    return function (statusCode, statusMessage, headers) {\n      headers = typeof statusMessage === 'string' ? headers : statusMessage;\n      headers = Object.assign(res.getHeaders(), headers);\n\n      if (req.method.toLowerCase() === 'options' && isOriginAllowed(req, headers)) {\n        addAllowHeaders(req, res, headers);\n      }\n\n      return writeHead.apply(this, arguments);\n    };\n  },\n\n  getContext(req) {\n    return contexts.get(req);\n  },\n\n  wrapRes(context, req, res, end) {\n    return function () {\n      web.finishAll(context);\n      return end.apply(res, arguments);\n    };\n  },\n\n  wrapEnd(context) {\n    const scope = context.tracer.scope();\n    const req = context.req;\n    const res = context.res;\n    const end = res.end;\n    res.writeHead = web.wrapWriteHead(context);\n    ends.set(res, this.wrapRes(context, req, res, end));\n    Object.defineProperty(res, 'end', {\n      configurable: true,\n\n      get() {\n        return ends.get(this);\n      },\n\n      set(value) {\n        ends.set(this, scope.bind(value, context.span));\n      }\n\n    });\n  }\n\n};\n\nfunction addAllowHeaders(req, res, headers) {\n  const allowHeaders = splitHeader(headers['access-control-allow-headers']);\n  const requestHeaders = splitHeader(req.headers['access-control-request-headers']);\n  const contextHeaders = ['x-datadog-origin', 'x-datadog-parent-id', 'x-datadog-sampled', // Deprecated, but still accept it in case it's sent.\n  'x-datadog-sampling-priority', 'x-datadog-trace-id', 'x-datadog-tags'];\n\n  for (const header of contextHeaders) {\n    if (~requestHeaders.indexOf(header)) {\n      allowHeaders.push(header);\n    }\n  }\n\n  if (allowHeaders.length > 0) {\n    res.setHeader('access-control-allow-headers', uniq(allowHeaders).join(','));\n  }\n}\n\nfunction isOriginAllowed(req, headers) {\n  const origin = req.headers['origin'];\n  const allowOrigin = headers['access-control-allow-origin'];\n  return origin && (allowOrigin === '*' || allowOrigin === origin);\n}\n\nfunction splitHeader(str) {\n  return typeof str === 'string' ? str.split(/\\s*,\\s*/) : [];\n}\n\nfunction reactivate(req, fn) {\n  const context = contexts.get(req);\n  return context ? context.tracer.scope().activate(context.span, fn) : fn();\n}\n\nfunction addRequestTags(context) {\n  const {\n    req,\n    span,\n    config\n  } = context;\n  const url = extractURL(req);\n  span.addTags({\n    [HTTP_URL]: web.obfuscateQs(config, url),\n    [HTTP_METHOD]: req.method,\n    [SPAN_KIND]: SERVER,\n    [SPAN_TYPE]: WEB,\n    [HTTP_USERAGENT]: req.headers['user-agent'],\n    [HTTP_CLIENT_IP]: web.extractIp(context)\n  });\n  addHeaders(context);\n}\n\nfunction addResponseTags(context) {\n  const {\n    req,\n    res,\n    paths,\n    span\n  } = context;\n\n  if (paths.length > 0) {\n    span.setTag(HTTP_ROUTE, paths.join(''));\n  }\n\n  span.addTags({\n    [HTTP_STATUS_CODE]: res.statusCode\n  });\n  web.addStatusError(req, res.statusCode);\n}\n\nfunction addResourceTag(context) {\n  const {\n    req,\n    span\n  } = context;\n\n  const tags = span.context()._tags;\n\n  if (tags['resource.name']) return;\n  const resource = [req.method, tags[HTTP_ROUTE]].filter(val => val).join(' ');\n  span.setTag(RESOURCE_NAME, resource);\n}\n\nfunction addHeaders(context) {\n  const {\n    req,\n    res,\n    config,\n    span\n  } = context;\n  config.headers.forEach(key => {\n    const reqHeader = req.headers[key];\n    const resHeader = res.getHeader(key);\n\n    if (reqHeader) {\n      span.setTag(`${HTTP_REQUEST_HEADERS}.${key}`, reqHeader);\n    }\n\n    if (resHeader) {\n      span.setTag(`${HTTP_RESPONSE_HEADERS}.${key}`, resHeader);\n    }\n  });\n}\n\nfunction extractURL(req) {\n  const headers = req.headers;\n\n  if (req.stream) {\n    return `${headers[HTTP2_HEADER_SCHEME]}://${headers[HTTP2_HEADER_AUTHORITY]}${headers[HTTP2_HEADER_PATH]}`;\n  } else {\n    const protocol = getProtocol(req);\n    return `${protocol}://${req.headers['host']}${req.originalUrl || req.url}`;\n  }\n}\n\nfunction getProtocol(req) {\n  if (req.socket && req.socket.encrypted) return 'https';\n  if (req.connection && req.connection.encrypted) return 'https';\n  return 'http';\n}\n\nconst privateCIDRs = ['127.0.0.0/8', '10.0.0.0/8', '172.16.0.0/12', '192.168.0.0/16', '169.254.0.0/16', '::1/128', 'fec0::/10', 'fe80::/10', 'fc00::/7', 'fd00::/8'];\nconst privateIPMatcher = new BlockList();\n\nfor (const cidr of privateCIDRs) {\n  const [address, prefix] = cidr.split('/');\n  privateIPMatcher.addSubnet(address, parseInt(prefix), net.isIPv6(address) ? 'ipv6' : 'ipv4');\n}\n\nfunction findFirstIp(str) {\n  let firstPrivateIp;\n  const splitted = str.split(',');\n\n  for (let i = 0; i < splitted.length; i++) {\n    const chunk = splitted[i].trim(); // TODO: strip port and interface data ?\n\n    const type = net.isIP(chunk);\n    if (!type) continue;\n\n    if (!privateIPMatcher.check(chunk, type === 6 ? 'ipv6' : 'ipv4')) {\n      // it's public, return it immediately\n      return chunk;\n    } // it's private, only save the first one found\n\n\n    if (!firstPrivateIp) firstPrivateIp = chunk;\n  }\n\n  return firstPrivateIp;\n}\n\nfunction getHeadersToRecord(config) {\n  if (Array.isArray(config.headers)) {\n    try {\n      return config.headers.map(key => key.toLowerCase());\n    } catch (err) {\n      log.error(err);\n    }\n  } else if (config.hasOwnProperty('headers')) {\n    log.error('Expected `headers` to be an array of strings.');\n  }\n\n  return [];\n}\n\nfunction getStatusValidator(config) {\n  if (typeof config.validateStatus === 'function') {\n    return config.validateStatus;\n  } else if (config.hasOwnProperty('validateStatus')) {\n    log.error('Expected `validateStatus` to be a function.');\n  }\n\n  return code => code < 500;\n}\n\nfunction getHooks(config) {\n  const noop = () => {};\n\n  const request = config.hooks && config.hooks.request || noop;\n  return {\n    request\n  };\n}\n\nfunction getMiddlewareSetting(config) {\n  if (config && typeof config.middleware === 'boolean') {\n    return config.middleware;\n  } else if (config && config.hasOwnProperty('middleware')) {\n    log.error('Expected `middleware` to be a boolean.');\n  }\n\n  return true;\n}\n\nfunction getQsObfuscator(config) {\n  const obfuscator = config.queryStringObfuscation;\n\n  if (typeof obfuscator === 'boolean') {\n    return obfuscator;\n  }\n\n  if (typeof obfuscator === 'string') {\n    if (obfuscator === '') return false; // disable obfuscator\n\n    if (obfuscator === '.*') return true; // optimize full redact\n\n    try {\n      return new RegExp(obfuscator, 'gi');\n    } catch (err) {\n      log.error(err);\n    }\n  }\n\n  if (config.hasOwnProperty('queryStringObfuscation')) {\n    log.error('Expected `queryStringObfuscation` to be a regex string or boolean.');\n  }\n\n  return true;\n}\n\nmodule.exports = web;","map":{"version":3,"names":["net","require","uniq","analyticsSampler","FORMAT_HTTP_HEADERS","log","tags","types","kinds","urlFilter","BlockList","incomingHttpRequestEnd","WEB","SERVER","RESOURCE_NAME","SERVICE_NAME","SPAN_TYPE","SPAN_KIND","ERROR","HTTP_METHOD","HTTP_URL","HTTP_STATUS_CODE","HTTP_ROUTE","HTTP_REQUEST_HEADERS","HTTP_RESPONSE_HEADERS","HTTP_USERAGENT","HTTP_CLIENT_IP","MANUAL_DROP","HTTP2_HEADER_AUTHORITY","HTTP2_HEADER_SCHEME","HTTP2_HEADER_PATH","ipHeaderList","contexts","WeakMap","ends","web","normalizeConfig","config","server","headers","getHeadersToRecord","validateStatus","getStatusValidator","hooks","getHooks","filter","getFilter","middleware","getMiddlewareSetting","queryStringObfuscation","getQsObfuscator","Object","assign","setFramework","req","name","context","patch","span","_name","setConfig","get","url","setTag","_trace","isRecording","service","sample","measured","startSpan","tracer","res","startChildSpan","wrap","instrumented","wrapEnd","instrument","callback","scope","activate","reactivate","fn","enterRoute","path","paths","push","setRoute","exitRoute","pop","wrapMiddleware","active","childOf","bindAndWrapMiddlewareErrors","addTags","activeSpan","bind","apply","arguments","e","addError","finish","error","message","stack","beforeEnd","stream","set","root","length","slice","extract","addStatusError","statusCode","hasExistingError","_tags","Error","finishMiddleware","finished","finishSpan","addRequestTags","addResponseTags","request","addResourceTag","finishAll","hasSubscribers","publish","obfuscateQs","i","indexOf","qs","replace","extractIp","clientIpHeaderDisabled","clientIpHeader","header","findFirstIp","foundHeaders","firstIp","socket","remoteAddress","wrapWriteHead","writeHead","statusMessage","getHeaders","method","toLowerCase","isOriginAllowed","addAllowHeaders","getContext","wrapRes","end","defineProperty","configurable","value","allowHeaders","splitHeader","requestHeaders","contextHeaders","setHeader","join","origin","allowOrigin","str","split","extractURL","addHeaders","resource","val","forEach","key","reqHeader","resHeader","getHeader","protocol","getProtocol","originalUrl","encrypted","connection","privateCIDRs","privateIPMatcher","cidr","address","prefix","addSubnet","parseInt","isIPv6","firstPrivateIp","splitted","chunk","trim","type","isIP","check","Array","isArray","map","err","hasOwnProperty","code","noop","obfuscator","RegExp","module","exports"],"sources":["/Users/daniel.calderon/Projects/barkito/barkito_front/node_modules/dd-trace/packages/dd-trace/src/plugins/util/web.js"],"sourcesContent":["'use strict'\n\nconst net = require('net')\nconst uniq = require('lodash.uniq')\nconst analyticsSampler = require('../../analytics_sampler')\nconst FORMAT_HTTP_HEADERS = 'http_headers'\nconst log = require('../../log')\nconst tags = require('../../../../../ext/tags')\nconst types = require('../../../../../ext/types')\nconst kinds = require('../../../../../ext/kinds')\nconst urlFilter = require('./urlfilter')\nconst BlockList = require('./ip_blocklist')\nconst { incomingHttpRequestEnd } = require('../../appsec/gateway/channels')\n\nconst WEB = types.WEB\nconst SERVER = kinds.SERVER\nconst RESOURCE_NAME = tags.RESOURCE_NAME\nconst SERVICE_NAME = tags.SERVICE_NAME\nconst SPAN_TYPE = tags.SPAN_TYPE\nconst SPAN_KIND = tags.SPAN_KIND\nconst ERROR = tags.ERROR\nconst HTTP_METHOD = tags.HTTP_METHOD\nconst HTTP_URL = tags.HTTP_URL\nconst HTTP_STATUS_CODE = tags.HTTP_STATUS_CODE\nconst HTTP_ROUTE = tags.HTTP_ROUTE\nconst HTTP_REQUEST_HEADERS = tags.HTTP_REQUEST_HEADERS\nconst HTTP_RESPONSE_HEADERS = tags.HTTP_RESPONSE_HEADERS\nconst HTTP_USERAGENT = tags.HTTP_USERAGENT\nconst HTTP_CLIENT_IP = tags.HTTP_CLIENT_IP\nconst MANUAL_DROP = tags.MANUAL_DROP\n\nconst HTTP2_HEADER_AUTHORITY = ':authority'\nconst HTTP2_HEADER_SCHEME = ':scheme'\nconst HTTP2_HEADER_PATH = ':path'\n\nconst ipHeaderList = [\n  'x-forwarded-for',\n  'x-real-ip',\n  'client-ip',\n  'x-forwarded',\n  'x-cluster-client-ip',\n  'forwarded-for',\n  'forwarded',\n  'via',\n  'true-client-ip'\n]\n\nconst contexts = new WeakMap()\nconst ends = new WeakMap()\n\nconst web = {\n  // Ensure the configuration has the correct structure and defaults.\n  normalizeConfig (config) {\n    config = config.server || config\n\n    const headers = getHeadersToRecord(config)\n    const validateStatus = getStatusValidator(config)\n    const hooks = getHooks(config)\n    const filter = urlFilter.getFilter(config)\n    const middleware = getMiddlewareSetting(config)\n    const queryStringObfuscation = getQsObfuscator(config)\n\n    return Object.assign({}, config, {\n      headers,\n      validateStatus,\n      hooks,\n      filter,\n      middleware,\n      queryStringObfuscation\n    })\n  },\n\n  setFramework (req, name, config) {\n    const context = this.patch(req)\n    const span = context.span\n\n    if (!span) return\n\n    span.context()._name = `${name}.request`\n\n    web.setConfig(req, config)\n  },\n\n  setConfig (req, config) {\n    const context = contexts.get(req)\n    const span = context.span\n\n    context.config = config\n\n    if (!config.filter(req.url)) {\n      span.setTag(MANUAL_DROP, true)\n      span.context()._trace.isRecording = false\n    }\n\n    if (config.service) {\n      span.setTag(SERVICE_NAME, config.service)\n    }\n\n    analyticsSampler.sample(span, config.measured, true)\n  },\n\n  startSpan (tracer, config, req, res, name) {\n    const context = this.patch(req)\n\n    let span\n\n    if (context.span) {\n      context.span.context()._name = name\n      span = context.span\n    } else {\n      span = web.startChildSpan(tracer, name, req.headers)\n    }\n\n    context.tracer = tracer\n    context.span = span\n    context.res = res\n\n    this.setConfig(req, config)\n\n    return span\n  },\n  wrap (req) {\n    const context = contexts.get(req)\n    if (!context.instrumented) {\n      this.wrapEnd(context)\n      context.instrumented = true\n    }\n  },\n  // Start a span and activate a scope for a request.\n  instrument (tracer, config, req, res, name, callback) {\n    const span = this.startSpan(tracer, config, req, res, name)\n\n    this.wrap(req)\n\n    return callback && tracer.scope().activate(span, () => callback(span))\n  },\n\n  // Reactivate the request scope in case it was changed by a middleware.\n  reactivate (req, fn) {\n    return reactivate(req, fn)\n  },\n\n  // Add a route segment that will be used for the resource name.\n  enterRoute (req, path) {\n    if (typeof path === 'string') {\n      contexts.get(req).paths.push(path)\n    }\n  },\n\n  setRoute (req, path) {\n    const context = contexts.get(req)\n\n    if (!context) return\n\n    context.paths = [path]\n  },\n\n  // Remove the current route segment.\n  exitRoute (req) {\n    contexts.get(req).paths.pop()\n  },\n\n  // Start a new middleware span and activate a new scope with the span.\n  wrapMiddleware (req, middleware, name, fn) {\n    if (!this.active(req)) return fn()\n\n    const context = contexts.get(req)\n    const tracer = context.tracer\n    const childOf = this.active(req)\n    const config = context.config\n\n    if (config.middleware === false) return this.bindAndWrapMiddlewareErrors(fn, req, tracer, childOf)\n\n    const span = tracer.startSpan(name, { childOf })\n\n    analyticsSampler.sample(span, config.measured)\n\n    span.addTags({\n      [RESOURCE_NAME]: middleware._name || middleware.name || '<anonymous>'\n    })\n\n    context.middleware.push(span)\n\n    return tracer.scope().activate(span, fn)\n  },\n\n  // catch errors and apply to active span\n  bindAndWrapMiddlewareErrors (fn, req, tracer, activeSpan) {\n    try {\n      return tracer.scope().bind(fn, activeSpan).apply(this, arguments)\n    } catch (e) {\n      web.addError(req, e) // TODO: remove when error formatting is moved to Span\n      throw e\n    }\n  },\n\n  // Finish the active middleware span.\n  finish (req, error) {\n    if (!this.active(req)) return\n\n    const context = contexts.get(req)\n    const span = context.middleware.pop()\n\n    if (span) {\n      if (error) {\n        span.addTags({\n          'error.type': error.name,\n          'error.msg': error.message,\n          'error.stack': error.stack\n        })\n      }\n\n      span.finish()\n    }\n  },\n\n  // Register a callback to run before res.end() is called.\n  beforeEnd (req, callback) {\n    contexts.get(req).beforeEnd.push(callback)\n  },\n\n  // Prepare the request for instrumentation.\n  patch (req) {\n    let context = contexts.get(req)\n\n    if (context) return context\n\n    context = req.stream && contexts.get(req.stream)\n\n    if (context) {\n      contexts.set(req, context)\n      return context\n    }\n\n    context = {\n      req,\n      span: null,\n      paths: [],\n      middleware: [],\n      beforeEnd: [],\n      config: {}\n    }\n\n    contexts.set(req, context)\n\n    return context\n  },\n\n  // Return the request root span.\n  root (req) {\n    const context = contexts.get(req)\n    return context ? context.span : null\n  },\n\n  // Return the active span.\n  active (req) {\n    const context = contexts.get(req)\n\n    if (!context) return null\n    if (context.middleware.length === 0) return context.span || null\n\n    return context.middleware.slice(-1)[0]\n  },\n\n  // Extract the parent span from the headers and start a new span as its child\n  startChildSpan (tracer, name, headers) {\n    const childOf = tracer.scope().active() || tracer.extract(FORMAT_HTTP_HEADERS, headers)\n\n    const span = tracer.startSpan(name, { childOf })\n\n    return span\n  },\n\n  // Validate a request's status code and then add error tags if necessary\n  addStatusError (req, statusCode) {\n    const context = contexts.get(req)\n    const span = context.span\n    const error = context.error\n    const hasExistingError = span.context()._tags['error'] || span.context()._tags['error.msg']\n\n    if (!hasExistingError && !context.config.validateStatus(statusCode)) {\n      span.setTag(ERROR, error || true)\n    }\n  },\n\n  // Add an error to the request\n  addError (req, error) {\n    if (error instanceof Error) {\n      const context = contexts.get(req)\n\n      if (context) {\n        context.error = error\n      }\n    }\n  },\n\n  finishMiddleware (context) {\n    if (context.finished) return\n\n    let span\n\n    while ((span = context.middleware.pop())) {\n      span.finish()\n    }\n  },\n\n  finishSpan (context) {\n    const { req, res } = context\n\n    if (context.finished && !req.stream) return\n\n    addRequestTags(context)\n    addResponseTags(context)\n\n    context.config.hooks.request(context.span, req, res)\n    addResourceTag(context)\n\n    context.span.finish()\n    context.finished = true\n  },\n\n  finishAll (context) {\n    const { req, res } = context\n\n    for (const beforeEnd of context.beforeEnd) {\n      beforeEnd()\n    }\n\n    web.finishMiddleware(context)\n\n    if (incomingHttpRequestEnd.hasSubscribers) {\n      incomingHttpRequestEnd.publish({ req, res })\n    }\n\n    web.finishSpan(context)\n  },\n\n  obfuscateQs (config, url) {\n    const { queryStringObfuscation } = config\n\n    if (queryStringObfuscation === false) return url\n\n    const i = url.indexOf('?')\n    if (i === -1) return url\n\n    const path = url.slice(0, i)\n    if (queryStringObfuscation === true) return path\n\n    let qs = url.slice(i + 1)\n\n    qs = qs.replace(queryStringObfuscation, '<redacted>')\n\n    return `${path}?${qs}`\n  },\n\n  extractIp (context) {\n    const { req, config } = context\n\n    if (config.clientIpHeaderDisabled) return\n\n    const headers = req.headers\n\n    if (config.clientIpHeader) {\n      const header = headers[config.clientIpHeader]\n      if (!header) return\n\n      return findFirstIp(header)\n    }\n\n    const foundHeaders = []\n\n    for (let i = 0; i < ipHeaderList.length; i++) {\n      if (headers[ipHeaderList[i]]) {\n        foundHeaders.push(ipHeaderList[i])\n      }\n    }\n\n    if (foundHeaders.length === 1) {\n      const header = headers[foundHeaders[0]]\n      const firstIp = findFirstIp(header)\n\n      if (firstIp) return firstIp\n    } else if (foundHeaders.length > 1) {\n      log.error(`Cannot find client IP: multiple IP headers detected ${foundHeaders}`)\n      return\n    }\n\n    return req.socket && req.socket.remoteAddress\n  },\n\n  wrapWriteHead (context) {\n    const { req, res } = context\n    const writeHead = res.writeHead\n\n    return function (statusCode, statusMessage, headers) {\n      headers = typeof statusMessage === 'string' ? headers : statusMessage\n      headers = Object.assign(res.getHeaders(), headers)\n\n      if (req.method.toLowerCase() === 'options' && isOriginAllowed(req, headers)) {\n        addAllowHeaders(req, res, headers)\n      }\n\n      return writeHead.apply(this, arguments)\n    }\n  },\n  getContext (req) {\n    return contexts.get(req)\n  },\n  wrapRes (context, req, res, end) {\n    return function () {\n      web.finishAll(context)\n\n      return end.apply(res, arguments)\n    }\n  },\n  wrapEnd (context) {\n    const scope = context.tracer.scope()\n    const req = context.req\n    const res = context.res\n    const end = res.end\n\n    res.writeHead = web.wrapWriteHead(context)\n\n    ends.set(res, this.wrapRes(context, req, res, end))\n\n    Object.defineProperty(res, 'end', {\n      configurable: true,\n      get () {\n        return ends.get(this)\n      },\n      set (value) {\n        ends.set(this, scope.bind(value, context.span))\n      }\n    })\n  }\n}\n\nfunction addAllowHeaders (req, res, headers) {\n  const allowHeaders = splitHeader(headers['access-control-allow-headers'])\n  const requestHeaders = splitHeader(req.headers['access-control-request-headers'])\n  const contextHeaders = [\n    'x-datadog-origin',\n    'x-datadog-parent-id',\n    'x-datadog-sampled', // Deprecated, but still accept it in case it's sent.\n    'x-datadog-sampling-priority',\n    'x-datadog-trace-id',\n    'x-datadog-tags'\n  ]\n\n  for (const header of contextHeaders) {\n    if (~requestHeaders.indexOf(header)) {\n      allowHeaders.push(header)\n    }\n  }\n\n  if (allowHeaders.length > 0) {\n    res.setHeader('access-control-allow-headers', uniq(allowHeaders).join(','))\n  }\n}\n\nfunction isOriginAllowed (req, headers) {\n  const origin = req.headers['origin']\n  const allowOrigin = headers['access-control-allow-origin']\n\n  return origin && (allowOrigin === '*' || allowOrigin === origin)\n}\n\nfunction splitHeader (str) {\n  return typeof str === 'string' ? str.split(/\\s*,\\s*/) : []\n}\n\nfunction reactivate (req, fn) {\n  const context = contexts.get(req)\n\n  return context\n    ? context.tracer.scope().activate(context.span, fn)\n    : fn()\n}\n\nfunction addRequestTags (context) {\n  const { req, span, config } = context\n  const url = extractURL(req)\n\n  span.addTags({\n    [HTTP_URL]: web.obfuscateQs(config, url),\n    [HTTP_METHOD]: req.method,\n    [SPAN_KIND]: SERVER,\n    [SPAN_TYPE]: WEB,\n    [HTTP_USERAGENT]: req.headers['user-agent'],\n    [HTTP_CLIENT_IP]: web.extractIp(context)\n  })\n\n  addHeaders(context)\n}\n\nfunction addResponseTags (context) {\n  const { req, res, paths, span } = context\n\n  if (paths.length > 0) {\n    span.setTag(HTTP_ROUTE, paths.join(''))\n  }\n\n  span.addTags({\n    [HTTP_STATUS_CODE]: res.statusCode\n  })\n\n  web.addStatusError(req, res.statusCode)\n}\n\nfunction addResourceTag (context) {\n  const { req, span } = context\n  const tags = span.context()._tags\n\n  if (tags['resource.name']) return\n\n  const resource = [req.method, tags[HTTP_ROUTE]]\n    .filter(val => val)\n    .join(' ')\n\n  span.setTag(RESOURCE_NAME, resource)\n}\n\nfunction addHeaders (context) {\n  const { req, res, config, span } = context\n\n  config.headers.forEach(key => {\n    const reqHeader = req.headers[key]\n    const resHeader = res.getHeader(key)\n\n    if (reqHeader) {\n      span.setTag(`${HTTP_REQUEST_HEADERS}.${key}`, reqHeader)\n    }\n\n    if (resHeader) {\n      span.setTag(`${HTTP_RESPONSE_HEADERS}.${key}`, resHeader)\n    }\n  })\n}\n\nfunction extractURL (req) {\n  const headers = req.headers\n\n  if (req.stream) {\n    return `${headers[HTTP2_HEADER_SCHEME]}://${headers[HTTP2_HEADER_AUTHORITY]}${headers[HTTP2_HEADER_PATH]}`\n  } else {\n    const protocol = getProtocol(req)\n    return `${protocol}://${req.headers['host']}${req.originalUrl || req.url}`\n  }\n}\n\nfunction getProtocol (req) {\n  if (req.socket && req.socket.encrypted) return 'https'\n  if (req.connection && req.connection.encrypted) return 'https'\n\n  return 'http'\n}\n\nconst privateCIDRs = [\n  '127.0.0.0/8',\n  '10.0.0.0/8',\n  '172.16.0.0/12',\n  '192.168.0.0/16',\n  '169.254.0.0/16',\n  '::1/128',\n  'fec0::/10',\n  'fe80::/10',\n  'fc00::/7',\n  'fd00::/8'\n]\n\nconst privateIPMatcher = new BlockList()\n\nfor (const cidr of privateCIDRs) {\n  const [ address, prefix ] = cidr.split('/')\n\n  privateIPMatcher.addSubnet(address, parseInt(prefix), net.isIPv6(address) ? 'ipv6' : 'ipv4')\n}\n\nfunction findFirstIp (str) {\n  let firstPrivateIp\n  const splitted = str.split(',')\n\n  for (let i = 0; i < splitted.length; i++) {\n    const chunk = splitted[i].trim()\n\n    // TODO: strip port and interface data ?\n\n    const type = net.isIP(chunk)\n    if (!type) continue\n\n    if (!privateIPMatcher.check(chunk, type === 6 ? 'ipv6' : 'ipv4')) {\n      // it's public, return it immediately\n      return chunk\n    }\n\n    // it's private, only save the first one found\n    if (!firstPrivateIp) firstPrivateIp = chunk\n  }\n\n  return firstPrivateIp\n}\n\nfunction getHeadersToRecord (config) {\n  if (Array.isArray(config.headers)) {\n    try {\n      return config.headers.map(key => key.toLowerCase())\n    } catch (err) {\n      log.error(err)\n    }\n  } else if (config.hasOwnProperty('headers')) {\n    log.error('Expected `headers` to be an array of strings.')\n  }\n  return []\n}\n\nfunction getStatusValidator (config) {\n  if (typeof config.validateStatus === 'function') {\n    return config.validateStatus\n  } else if (config.hasOwnProperty('validateStatus')) {\n    log.error('Expected `validateStatus` to be a function.')\n  }\n  return code => code < 500\n}\n\nfunction getHooks (config) {\n  const noop = () => {}\n  const request = (config.hooks && config.hooks.request) || noop\n\n  return { request }\n}\n\nfunction getMiddlewareSetting (config) {\n  if (config && typeof config.middleware === 'boolean') {\n    return config.middleware\n  } else if (config && config.hasOwnProperty('middleware')) {\n    log.error('Expected `middleware` to be a boolean.')\n  }\n\n  return true\n}\n\nfunction getQsObfuscator (config) {\n  const obfuscator = config.queryStringObfuscation\n\n  if (typeof obfuscator === 'boolean') {\n    return obfuscator\n  }\n\n  if (typeof obfuscator === 'string') {\n    if (obfuscator === '') return false // disable obfuscator\n\n    if (obfuscator === '.*') return true // optimize full redact\n\n    try {\n      return new RegExp(obfuscator, 'gi')\n    } catch (err) {\n      log.error(err)\n    }\n  }\n\n  if (config.hasOwnProperty('queryStringObfuscation')) {\n    log.error('Expected `queryStringObfuscation` to be a regex string or boolean.')\n  }\n\n  return true\n}\n\nmodule.exports = web\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}