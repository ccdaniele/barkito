{"ast":null,"code":"'use strict'; // Use a weak map to avoid polluting the wrapped function/method.\n\nconst unwrappers = new WeakMap();\n\nfunction copyProperties(original, wrapped) {\n  Object.setPrototypeOf(wrapped, original);\n  const props = Object.getOwnPropertyDescriptors(original);\n  const keys = Reflect.ownKeys(props);\n\n  for (const key of keys) {\n    Object.defineProperty(wrapped, key, props[key]);\n  }\n}\n\nfunction wrapFn(original, delegate) {\n  assertFunction(delegate);\n  assertNotClass(original); // TODO: support constructors of native classes\n\n  const shim = function shim() {\n    return delegate.apply(this, arguments);\n  };\n\n  unwrappers.set(shim, () => {\n    delegate = original;\n  });\n  copyProperties(original, shim);\n  return shim;\n}\n\nfunction wrapMethod(target, name, wrapper) {\n  assertMethod(target, name);\n  assertNotClass(target[name]); // TODO: support constructors of native classes\n\n  assertFunction(wrapper);\n  const original = target[name];\n  const wrapped = wrapper(original);\n  const descriptor = Object.getOwnPropertyDescriptor(target, name);\n\n  if (descriptor) {\n    unwrappers.set(wrapped, () => Object.defineProperty(target, name, descriptor));\n  } else {\n    // no descriptor means original was on the prototype\n    unwrappers.set(wrapped, () => delete target[name]);\n  }\n\n  Object.defineProperty(target, name, {\n    configurable: true,\n    writable: true,\n    enumerable: false,\n    ...descriptor,\n    value: wrapped\n  });\n  copyProperties(original, wrapped);\n  return target;\n}\n\nfunction wrap(target, name, wrapper) {\n  return typeof name === 'function' ? wrapFn(target, name) : wrapMethod(target, name, wrapper);\n}\n\nfunction unwrap(target, name) {\n  if (!target) return target; // no target to unwrap\n\n  const unwrapper = unwrappers.get(name ? target[name] : target);\n  if (!unwrapper) return target; // target is already unwrapped or isn't wrapped\n\n  unwrapper();\n  return target;\n}\n\nfunction massWrap(targets, names, wrapper) {\n  targets = toArray(targets);\n  names = toArray(names);\n\n  for (const target of targets) {\n    for (const name of names) {\n      wrap(target, name, wrapper);\n    }\n  }\n}\n\nfunction massUnwrap(targets, names) {\n  targets = toArray(targets);\n  names = toArray(names);\n\n  for (const target of targets) {\n    for (const name of names) {\n      unwrap(target, name);\n    }\n  }\n}\n\nfunction toArray(maybeArray) {\n  return Array.isArray(maybeArray) ? maybeArray : [maybeArray];\n}\n\nfunction assertMethod(target, name) {\n  if (!target) {\n    throw new Error('No target object provided.');\n  }\n\n  if (typeof target !== 'object' && typeof target !== 'function') {\n    throw new Error('Invalid target.');\n  }\n\n  if (!target[name]) {\n    throw new Error(`No original method ${name}.`);\n  }\n\n  if (typeof target[name] !== 'function') {\n    throw new Error(`Original method ${name} is not a function.`);\n  }\n}\n\nfunction assertFunction(target) {\n  if (!target) {\n    throw new Error('No function provided.');\n  }\n\n  if (typeof target !== 'function') {\n    throw new Error('Target is not a function.');\n  }\n}\n\nfunction assertNotClass(target) {\n  if (Function.prototype.toString.call(target).startsWith('class')) {\n    throw new Error('Target is a native class constructor and cannot be wrapped.');\n  }\n}\n\nmodule.exports = {\n  wrap,\n  massWrap,\n  unwrap,\n  massUnwrap\n};","map":{"version":3,"names":["unwrappers","WeakMap","copyProperties","original","wrapped","Object","setPrototypeOf","props","getOwnPropertyDescriptors","keys","Reflect","ownKeys","key","defineProperty","wrapFn","delegate","assertFunction","assertNotClass","shim","apply","arguments","set","wrapMethod","target","name","wrapper","assertMethod","descriptor","getOwnPropertyDescriptor","configurable","writable","enumerable","value","wrap","unwrap","unwrapper","get","massWrap","targets","names","toArray","massUnwrap","maybeArray","Array","isArray","Error","Function","prototype","toString","call","startsWith","module","exports"],"sources":["/Users/daniel.calderon/Projects/barkito/barkito_front/node_modules/dd-trace/packages/datadog-shimmer/src/shimmer.js"],"sourcesContent":["'use strict'\n\n// Use a weak map to avoid polluting the wrapped function/method.\nconst unwrappers = new WeakMap()\n\nfunction copyProperties (original, wrapped) {\n  Object.setPrototypeOf(wrapped, original)\n\n  const props = Object.getOwnPropertyDescriptors(original)\n  const keys = Reflect.ownKeys(props)\n\n  for (const key of keys) {\n    Object.defineProperty(wrapped, key, props[key])\n  }\n}\n\nfunction wrapFn (original, delegate) {\n  assertFunction(delegate)\n  assertNotClass(original) // TODO: support constructors of native classes\n\n  const shim = function shim () {\n    return delegate.apply(this, arguments)\n  }\n\n  unwrappers.set(shim, () => {\n    delegate = original\n  })\n\n  copyProperties(original, shim)\n\n  return shim\n}\n\nfunction wrapMethod (target, name, wrapper) {\n  assertMethod(target, name)\n  assertNotClass(target[name]) // TODO: support constructors of native classes\n  assertFunction(wrapper)\n\n  const original = target[name]\n  const wrapped = wrapper(original)\n  const descriptor = Object.getOwnPropertyDescriptor(target, name)\n\n  if (descriptor) {\n    unwrappers.set(wrapped, () => Object.defineProperty(target, name, descriptor))\n  } else { // no descriptor means original was on the prototype\n    unwrappers.set(wrapped, () => delete target[name])\n  }\n\n  Object.defineProperty(target, name, {\n    configurable: true,\n    writable: true,\n    enumerable: false,\n    ...descriptor,\n    value: wrapped\n  })\n\n  copyProperties(original, wrapped)\n\n  return target\n}\n\nfunction wrap (target, name, wrapper) {\n  return typeof name === 'function'\n    ? wrapFn(target, name)\n    : wrapMethod(target, name, wrapper)\n}\n\nfunction unwrap (target, name) {\n  if (!target) return target // no target to unwrap\n\n  const unwrapper = unwrappers.get(name ? target[name] : target)\n\n  if (!unwrapper) return target // target is already unwrapped or isn't wrapped\n\n  unwrapper()\n\n  return target\n}\n\nfunction massWrap (targets, names, wrapper) {\n  targets = toArray(targets)\n  names = toArray(names)\n\n  for (const target of targets) {\n    for (const name of names) {\n      wrap(target, name, wrapper)\n    }\n  }\n}\n\nfunction massUnwrap (targets, names) {\n  targets = toArray(targets)\n  names = toArray(names)\n\n  for (const target of targets) {\n    for (const name of names) {\n      unwrap(target, name)\n    }\n  }\n}\n\nfunction toArray (maybeArray) {\n  return Array.isArray(maybeArray) ? maybeArray : [maybeArray]\n}\n\nfunction assertMethod (target, name) {\n  if (!target) {\n    throw new Error('No target object provided.')\n  }\n\n  if (typeof target !== 'object' && typeof target !== 'function') {\n    throw new Error('Invalid target.')\n  }\n\n  if (!target[name]) {\n    throw new Error(`No original method ${name}.`)\n  }\n\n  if (typeof target[name] !== 'function') {\n    throw new Error(`Original method ${name} is not a function.`)\n  }\n}\n\nfunction assertFunction (target) {\n  if (!target) {\n    throw new Error('No function provided.')\n  }\n\n  if (typeof target !== 'function') {\n    throw new Error('Target is not a function.')\n  }\n}\n\nfunction assertNotClass (target) {\n  if (Function.prototype.toString.call(target).startsWith('class')) {\n    throw new Error('Target is a native class constructor and cannot be wrapped.')\n  }\n}\n\nmodule.exports = {\n  wrap,\n  massWrap,\n  unwrap,\n  massUnwrap\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}