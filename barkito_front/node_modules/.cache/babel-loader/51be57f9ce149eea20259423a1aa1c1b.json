{"ast":null,"code":"'use strict';\n\nconst constants = require('./constants');\n\nconst tags = require('../../../ext/tags');\n\nconst id = require('./id');\n\nconst {\n  isError\n} = require('./util');\n\nconst SAMPLING_PRIORITY_KEY = constants.SAMPLING_PRIORITY_KEY;\nconst SAMPLING_RULE_DECISION = constants.SAMPLING_RULE_DECISION;\nconst SAMPLING_LIMIT_DECISION = constants.SAMPLING_LIMIT_DECISION;\nconst SAMPLING_AGENT_DECISION = constants.SAMPLING_AGENT_DECISION;\nconst MEASURED = tags.MEASURED;\nconst ORIGIN_KEY = constants.ORIGIN_KEY;\nconst HOSTNAME_KEY = constants.HOSTNAME_KEY;\nconst TOP_LEVEL_KEY = constants.TOP_LEVEL_KEY;\nconst map = {\n  'service.name': 'service',\n  'span.type': 'type',\n  'resource.name': 'resource'\n};\n\nfunction format(span) {\n  const formatted = formatSpan(span);\n  extractRootTags(formatted, span);\n  extractChunkTags(formatted, span);\n  extractTags(formatted, span);\n  return formatted;\n}\n\nfunction formatSpan(span) {\n  const spanContext = span.context();\n  return {\n    trace_id: spanContext._traceId,\n    span_id: spanContext._spanId,\n    parent_id: spanContext._parentId || id('0'),\n    name: String(spanContext._name),\n    resource: String(spanContext._name),\n    error: 0,\n    meta: {},\n    metrics: {},\n    start: Math.round(span._startTime * 1e6),\n    duration: Math.round(span._duration * 1e6)\n  };\n}\n\nfunction extractTags(trace, span) {\n  const context = span.context();\n  const origin = context._trace.origin;\n  const tags = context._tags;\n  const hostname = context._hostname;\n  const priority = context._sampling.priority;\n\n  if (tags['span.kind'] && tags['span.kind'] !== 'internal') {\n    addTag({}, trace.metrics, MEASURED, 1);\n  }\n\n  for (const tag in tags) {\n    switch (tag) {\n      case 'service.name':\n      case 'span.type':\n      case 'resource.name':\n        addTag(trace, {}, map[tag], tags[tag]);\n        break;\n      // HACK: remove when Datadog supports numeric status code\n\n      case 'http.status_code':\n        addTag(trace.meta, {}, tag, tags[tag] && String(tags[tag]));\n        break;\n\n      case HOSTNAME_KEY:\n      case MEASURED:\n        addTag({}, trace.metrics, tag, tags[tag] === undefined || tags[tag] ? 1 : 0);\n        break;\n\n      case 'error':\n        if (context._name !== 'fs.operation') {\n          extractError(trace, tags[tag]);\n        }\n\n        break;\n\n      case 'error.type':\n      case 'error.msg':\n      case 'error.stack':\n        // HACK: remove when implemented in the backend\n        if (context._name !== 'fs.operation') {\n          trace.error = 1;\n        } else {\n          break;\n        }\n\n      default:\n        // eslint-disable-line no-fallthrough\n        addTag(trace.meta, trace.metrics, tag, tags[tag]);\n    }\n  }\n\n  if (span.tracer()._service === tags['service.name']) {\n    addTag(trace.meta, trace.metrics, 'language', 'javascript');\n  }\n\n  addTag(trace.meta, trace.metrics, SAMPLING_PRIORITY_KEY, priority);\n  addTag(trace.meta, trace.metrics, ORIGIN_KEY, origin);\n  addTag(trace.meta, trace.metrics, HOSTNAME_KEY, hostname);\n}\n\nfunction extractRootTags(trace, span) {\n  const context = span.context();\n  const isLocalRoot = span === context._trace.started[0];\n  const parentId = context._parentId;\n  if (!isLocalRoot || parentId && parentId.toString(10) !== '0') return;\n  addTag({}, trace.metrics, SAMPLING_RULE_DECISION, context._trace[SAMPLING_RULE_DECISION]);\n  addTag({}, trace.metrics, SAMPLING_LIMIT_DECISION, context._trace[SAMPLING_LIMIT_DECISION]);\n  addTag({}, trace.metrics, SAMPLING_AGENT_DECISION, context._trace[SAMPLING_AGENT_DECISION]);\n  addTag({}, trace.metrics, TOP_LEVEL_KEY, 1);\n}\n\nfunction extractChunkTags(trace, span) {\n  const context = span.context();\n  const isLocalRoot = span === context._trace.started[0];\n  if (!isLocalRoot) return;\n\n  for (const key in context._trace.tags) {\n    addTag(trace.meta, trace.metrics, key, context._trace.tags[key]);\n  }\n}\n\nfunction extractError(trace, error) {\n  if (!error) return;\n  trace.error = 1;\n\n  if (isError(error)) {\n    addTag(trace.meta, trace.metrics, 'error.msg', error.message);\n    addTag(trace.meta, trace.metrics, 'error.type', error.name);\n    addTag(trace.meta, trace.metrics, 'error.stack', error.stack);\n  }\n}\n\nfunction addTag(meta, metrics, key, value, nested) {\n  switch (typeof value) {\n    case 'string':\n      if (!value) break;\n      meta[key] = value;\n      break;\n\n    case 'number':\n      if (isNaN(value)) break;\n      metrics[key] = value;\n      break;\n\n    case 'boolean':\n      metrics[key] = value ? 1 : 0;\n      break;\n\n    case 'undefined':\n      break;\n\n    case 'object':\n      if (value === null) break; // Special case for Node.js Buffer and URL\n\n      if (isNodeBuffer(value) || isUrl(value)) {\n        metrics[key] = value.toString();\n      } else if (!Array.isArray(value) && !nested) {\n        for (const prop in value) {\n          if (!value.hasOwnProperty(prop)) continue;\n          addTag(meta, metrics, `${key}.${prop}`, value[prop], true);\n        }\n      }\n\n      break;\n  }\n}\n\nfunction isNodeBuffer(obj) {\n  return obj.constructor && obj.constructor.name === 'Buffer' && typeof obj.readInt8 === 'function' && typeof obj.toString === 'function';\n}\n\nfunction isUrl(obj) {\n  return obj.constructor && obj.constructor.name === 'URL' && typeof obj.href === 'string' && typeof obj.toString === 'function';\n}\n\nmodule.exports = format;","map":{"version":3,"names":["constants","require","tags","id","isError","SAMPLING_PRIORITY_KEY","SAMPLING_RULE_DECISION","SAMPLING_LIMIT_DECISION","SAMPLING_AGENT_DECISION","MEASURED","ORIGIN_KEY","HOSTNAME_KEY","TOP_LEVEL_KEY","map","format","span","formatted","formatSpan","extractRootTags","extractChunkTags","extractTags","spanContext","context","trace_id","_traceId","span_id","_spanId","parent_id","_parentId","name","String","_name","resource","error","meta","metrics","start","Math","round","_startTime","duration","_duration","trace","origin","_trace","_tags","hostname","_hostname","priority","_sampling","addTag","tag","undefined","extractError","tracer","_service","isLocalRoot","started","parentId","toString","key","message","stack","value","nested","isNaN","isNodeBuffer","isUrl","Array","isArray","prop","hasOwnProperty","obj","constructor","readInt8","href","module","exports"],"sources":["/Users/daniel.calderon/Projects/barkito/barkito_front/node_modules/dd-trace/packages/dd-trace/src/format.js"],"sourcesContent":["'use strict'\n\nconst constants = require('./constants')\nconst tags = require('../../../ext/tags')\nconst id = require('./id')\nconst { isError } = require('./util')\n\nconst SAMPLING_PRIORITY_KEY = constants.SAMPLING_PRIORITY_KEY\nconst SAMPLING_RULE_DECISION = constants.SAMPLING_RULE_DECISION\nconst SAMPLING_LIMIT_DECISION = constants.SAMPLING_LIMIT_DECISION\nconst SAMPLING_AGENT_DECISION = constants.SAMPLING_AGENT_DECISION\nconst MEASURED = tags.MEASURED\nconst ORIGIN_KEY = constants.ORIGIN_KEY\nconst HOSTNAME_KEY = constants.HOSTNAME_KEY\nconst TOP_LEVEL_KEY = constants.TOP_LEVEL_KEY\n\nconst map = {\n  'service.name': 'service',\n  'span.type': 'type',\n  'resource.name': 'resource'\n}\n\nfunction format (span) {\n  const formatted = formatSpan(span)\n\n  extractRootTags(formatted, span)\n  extractChunkTags(formatted, span)\n  extractTags(formatted, span)\n\n  return formatted\n}\n\nfunction formatSpan (span) {\n  const spanContext = span.context()\n\n  return {\n    trace_id: spanContext._traceId,\n    span_id: spanContext._spanId,\n    parent_id: spanContext._parentId || id('0'),\n    name: String(spanContext._name),\n    resource: String(spanContext._name),\n    error: 0,\n    meta: {},\n    metrics: {},\n    start: Math.round(span._startTime * 1e6),\n    duration: Math.round(span._duration * 1e6)\n  }\n}\n\nfunction extractTags (trace, span) {\n  const context = span.context()\n  const origin = context._trace.origin\n  const tags = context._tags\n  const hostname = context._hostname\n  const priority = context._sampling.priority\n\n  if (tags['span.kind'] && tags['span.kind'] !== 'internal') {\n    addTag({}, trace.metrics, MEASURED, 1)\n  }\n\n  for (const tag in tags) {\n    switch (tag) {\n      case 'service.name':\n      case 'span.type':\n      case 'resource.name':\n        addTag(trace, {}, map[tag], tags[tag])\n        break\n      // HACK: remove when Datadog supports numeric status code\n      case 'http.status_code':\n        addTag(trace.meta, {}, tag, tags[tag] && String(tags[tag]))\n        break\n      case HOSTNAME_KEY:\n      case MEASURED:\n        addTag({}, trace.metrics, tag, tags[tag] === undefined || tags[tag] ? 1 : 0)\n        break\n      case 'error':\n        if (context._name !== 'fs.operation') {\n          extractError(trace, tags[tag])\n        }\n        break\n      case 'error.type':\n      case 'error.msg':\n      case 'error.stack':\n        // HACK: remove when implemented in the backend\n        if (context._name !== 'fs.operation') {\n          trace.error = 1\n        } else {\n          break\n        }\n      default: // eslint-disable-line no-fallthrough\n        addTag(trace.meta, trace.metrics, tag, tags[tag])\n    }\n  }\n\n  if (span.tracer()._service === tags['service.name']) {\n    addTag(trace.meta, trace.metrics, 'language', 'javascript')\n  }\n\n  addTag(trace.meta, trace.metrics, SAMPLING_PRIORITY_KEY, priority)\n  addTag(trace.meta, trace.metrics, ORIGIN_KEY, origin)\n  addTag(trace.meta, trace.metrics, HOSTNAME_KEY, hostname)\n}\n\nfunction extractRootTags (trace, span) {\n  const context = span.context()\n  const isLocalRoot = span === context._trace.started[0]\n  const parentId = context._parentId\n\n  if (!isLocalRoot || (parentId && parentId.toString(10) !== '0')) return\n\n  addTag({}, trace.metrics, SAMPLING_RULE_DECISION, context._trace[SAMPLING_RULE_DECISION])\n  addTag({}, trace.metrics, SAMPLING_LIMIT_DECISION, context._trace[SAMPLING_LIMIT_DECISION])\n  addTag({}, trace.metrics, SAMPLING_AGENT_DECISION, context._trace[SAMPLING_AGENT_DECISION])\n  addTag({}, trace.metrics, TOP_LEVEL_KEY, 1)\n}\n\nfunction extractChunkTags (trace, span) {\n  const context = span.context()\n  const isLocalRoot = span === context._trace.started[0]\n\n  if (!isLocalRoot) return\n\n  for (const key in context._trace.tags) {\n    addTag(trace.meta, trace.metrics, key, context._trace.tags[key])\n  }\n}\n\nfunction extractError (trace, error) {\n  if (!error) return\n\n  trace.error = 1\n\n  if (isError(error)) {\n    addTag(trace.meta, trace.metrics, 'error.msg', error.message)\n    addTag(trace.meta, trace.metrics, 'error.type', error.name)\n    addTag(trace.meta, trace.metrics, 'error.stack', error.stack)\n  }\n}\n\nfunction addTag (meta, metrics, key, value, nested) {\n  switch (typeof value) {\n    case 'string':\n      if (!value) break\n      meta[key] = value\n      break\n    case 'number':\n      if (isNaN(value)) break\n      metrics[key] = value\n      break\n    case 'boolean':\n      metrics[key] = value ? 1 : 0\n      break\n    case 'undefined':\n      break\n    case 'object':\n      if (value === null) break\n\n      // Special case for Node.js Buffer and URL\n      if (isNodeBuffer(value) || isUrl(value)) {\n        metrics[key] = value.toString()\n      } else if (!Array.isArray(value) && !nested) {\n        for (const prop in value) {\n          if (!value.hasOwnProperty(prop)) continue\n\n          addTag(meta, metrics, `${key}.${prop}`, value[prop], true)\n        }\n      }\n\n      break\n  }\n}\n\nfunction isNodeBuffer (obj) {\n  return obj.constructor && obj.constructor.name === 'Buffer' &&\n    typeof obj.readInt8 === 'function' &&\n    typeof obj.toString === 'function'\n}\n\nfunction isUrl (obj) {\n  return obj.constructor && obj.constructor.name === 'URL' &&\n    typeof obj.href === 'string' &&\n    typeof obj.toString === 'function'\n}\n\nmodule.exports = format\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}