{"ast":null,"code":"'use strict'; // TODO: capture every second and flush every 10 seconds\n\nconst v8 = require('v8');\n\nconst os = require('os');\n\nconst Client = require('./dogstatsd');\n\nconst log = require('./log');\n\nconst Histogram = require('./histogram');\n\nconst INTERVAL = 10 * 1000;\nlet nativeMetrics = null;\nlet interval;\nlet client;\nlet time;\nlet cpuUsage;\nlet gauges;\nlet counters;\nlet histograms;\nreset();\nmodule.exports = {\n  start(config) {\n    const tags = [];\n    Object.keys(config.tags).filter(key => typeof config.tags[key] === 'string').filter(key => {\n      // Skip runtime-id unless enabled as cardinality may be too high\n      if (key !== 'runtime-id') return true;\n      return config.experimental && config.experimental.runtimeId;\n    }).forEach(key => {\n      // https://docs.datadoghq.com/tagging/#defining-tags\n      const value = config.tags[key].replace(/[^a-z0-9_:./-]/ig, '_');\n      tags.push(`${key}:${value}`);\n    });\n\n    try {\n      nativeMetrics = require('@datadog/native-metrics');\n      nativeMetrics.start();\n    } catch (e) {\n      log.error(e);\n      nativeMetrics = null;\n    }\n\n    client = new Client({\n      host: config.dogstatsd.hostname,\n      port: config.dogstatsd.port,\n      tags\n    });\n    time = process.hrtime();\n\n    if (nativeMetrics) {\n      interval = setInterval(() => {\n        captureCommonMetrics();\n        captureNativeMetrics();\n        client.flush();\n      }, INTERVAL);\n    } else {\n      cpuUsage = process.cpuUsage();\n      interval = setInterval(() => {\n        captureCommonMetrics();\n        captureCpuUsage();\n        captureHeapSpace();\n        client.flush();\n      }, INTERVAL);\n    }\n\n    interval.unref();\n  },\n\n  stop() {\n    if (nativeMetrics) {\n      nativeMetrics.stop();\n    }\n\n    clearInterval(interval);\n    reset();\n  },\n\n  track(span) {\n    if (nativeMetrics) {\n      const handle = nativeMetrics.track(span);\n      return {\n        finish: () => nativeMetrics.finish(handle)\n      };\n    }\n\n    return {\n      finish: () => {}\n    };\n  },\n\n  boolean(name, value, tag) {\n    this.gauge(name, value ? 1 : 0, tag);\n  },\n\n  histogram(name, value, tag) {\n    if (!client) return;\n    histograms[name] = histograms[name] || new Map();\n\n    if (!histograms[name].has(tag)) {\n      histograms[name].set(tag, new Histogram());\n    }\n\n    histograms[name].get(tag).record(value);\n  },\n\n  count(name, count, tag) {\n    let monotonic = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    if (!client) return;\n\n    if (typeof tag === 'boolean') {\n      monotonic = tag;\n      tag = undefined;\n    }\n\n    const map = monotonic ? counters : gauges;\n    map[name] = map[name] || new Map();\n    const value = map[name].get(tag) || 0;\n    map[name].set(tag, value + count);\n  },\n\n  gauge(name, value, tag) {\n    if (!client) return;\n    gauges[name] = gauges[name] || new Map();\n    gauges[name].set(tag, value);\n  },\n\n  increment(name, tag, monotonic) {\n    this.count(name, 1, tag, monotonic);\n  },\n\n  decrement(name, tag) {\n    this.count(name, -1, tag);\n  }\n\n};\n\nfunction reset() {\n  interval = null;\n  client = null;\n  time = null;\n  cpuUsage = null;\n  gauges = {};\n  counters = {};\n  histograms = {};\n  nativeMetrics = null;\n}\n\nfunction captureCpuUsage() {\n  if (!process.cpuUsage) return;\n  const elapsedTime = process.hrtime(time);\n  const elapsedUsage = process.cpuUsage(cpuUsage);\n  time = process.hrtime();\n  cpuUsage = process.cpuUsage();\n  const elapsedMs = elapsedTime[0] * 1000 + elapsedTime[1] / 1000000;\n  const userPercent = 100 * elapsedUsage.user / 1000 / elapsedMs;\n  const systemPercent = 100 * elapsedUsage.system / 1000 / elapsedMs;\n  const totalPercent = userPercent + systemPercent;\n  client.gauge('runtime.node.cpu.system', systemPercent.toFixed(2));\n  client.gauge('runtime.node.cpu.user', userPercent.toFixed(2));\n  client.gauge('runtime.node.cpu.total', totalPercent.toFixed(2));\n}\n\nfunction captureMemoryUsage() {\n  const stats = process.memoryUsage();\n  client.gauge('runtime.node.mem.heap_total', stats.heapTotal);\n  client.gauge('runtime.node.mem.heap_used', stats.heapUsed);\n  client.gauge('runtime.node.mem.rss', stats.rss);\n  client.gauge('runtime.node.mem.total', os.totalmem());\n  client.gauge('runtime.node.mem.free', os.freemem());\n  stats.external && client.gauge('runtime.node.mem.external', stats.external);\n}\n\nfunction captureProcess() {\n  client.gauge('runtime.node.process.uptime', Math.round(process.uptime()));\n}\n\nfunction captureHeapStats() {\n  const stats = v8.getHeapStatistics();\n  client.gauge('runtime.node.heap.total_heap_size', stats.total_heap_size);\n  client.gauge('runtime.node.heap.total_heap_size_executable', stats.total_heap_size_executable);\n  client.gauge('runtime.node.heap.total_physical_size', stats.total_physical_size);\n  client.gauge('runtime.node.heap.total_available_size', stats.total_available_size);\n  client.gauge('runtime.node.heap.heap_size_limit', stats.heap_size_limit);\n  stats.malloced_memory && client.gauge('runtime.node.heap.malloced_memory', stats.malloced_memory);\n  stats.peak_malloced_memory && client.gauge('runtime.node.heap.peak_malloced_memory', stats.peak_malloced_memory);\n}\n\nfunction captureHeapSpace() {\n  if (!v8.getHeapSpaceStatistics) return;\n  const stats = v8.getHeapSpaceStatistics();\n\n  for (let i = 0, l = stats.length; i < l; i++) {\n    const tags = [`space:${stats[i].space_name}`];\n    client.gauge('runtime.node.heap.size.by.space', stats[i].space_size, tags);\n    client.gauge('runtime.node.heap.used_size.by.space', stats[i].space_used_size, tags);\n    client.gauge('runtime.node.heap.available_size.by.space', stats[i].space_available_size, tags);\n    client.gauge('runtime.node.heap.physical_size.by.space', stats[i].physical_space_size, tags);\n  }\n}\n\nfunction captureGauges() {\n  Object.keys(gauges).forEach(name => {\n    gauges[name].forEach((value, tag) => {\n      client.gauge(name, value, tag && [tag]);\n    });\n  });\n}\n\nfunction captureCounters() {\n  Object.keys(counters).forEach(name => {\n    counters[name].forEach((value, tag) => {\n      client.increment(name, value, tag && [tag]);\n    });\n  });\n  counters = {};\n}\n\nfunction captureHistograms() {\n  Object.keys(histograms).forEach(name => {\n    histograms[name].forEach((stats, tag) => {\n      histogram(name, stats, tag && [tag]);\n      stats.reset();\n    });\n  });\n}\n\nfunction captureCommonMetrics() {\n  captureMemoryUsage();\n  captureProcess();\n  captureHeapStats();\n  captureGauges();\n  captureCounters();\n  captureHistograms();\n}\n\nfunction captureNativeMetrics() {\n  const stats = nativeMetrics.stats();\n  const spaces = stats.heap.spaces;\n  const elapsedTime = process.hrtime(time);\n  time = process.hrtime();\n  const elapsedUs = elapsedTime[0] * 1e6 + elapsedTime[1] / 1e3;\n  const userPercent = 100 * stats.cpu.user / elapsedUs;\n  const systemPercent = 100 * stats.cpu.system / elapsedUs;\n  const totalPercent = userPercent + systemPercent;\n  client.gauge('runtime.node.cpu.system', systemPercent.toFixed(2));\n  client.gauge('runtime.node.cpu.user', userPercent.toFixed(2));\n  client.gauge('runtime.node.cpu.total', totalPercent.toFixed(2));\n  histogram('runtime.node.event_loop.delay', stats.eventLoop);\n  Object.keys(stats.gc).forEach(type => {\n    if (type === 'all') {\n      histogram('runtime.node.gc.pause', stats.gc[type]);\n    } else {\n      histogram('runtime.node.gc.pause.by.type', stats.gc[type], [`gc_type:${type}`]);\n    }\n  });\n\n  for (let i = 0, l = spaces.length; i < l; i++) {\n    const tags = [`heap_space:${spaces[i].space_name}`];\n    client.gauge('runtime.node.heap.size.by.space', spaces[i].space_size, tags);\n    client.gauge('runtime.node.heap.used_size.by.space', spaces[i].space_used_size, tags);\n    client.gauge('runtime.node.heap.available_size.by.space', spaces[i].space_available_size, tags);\n    client.gauge('runtime.node.heap.physical_size.by.space', spaces[i].physical_space_size, tags);\n  }\n}\n\nfunction histogram(name, stats, tags) {\n  tags = [].concat(tags);\n  client.gauge(`${name}.min`, stats.min, tags);\n  client.gauge(`${name}.max`, stats.max, tags);\n  client.increment(`${name}.sum`, stats.sum, tags);\n  client.increment(`${name}.total`, stats.sum, tags);\n  client.gauge(`${name}.avg`, stats.avg, tags);\n  client.increment(`${name}.count`, stats.count, tags);\n  client.gauge(`${name}.median`, stats.median, tags);\n  client.gauge(`${name}.95percentile`, stats.p95, tags);\n}","map":{"version":3,"names":["v8","require","os","Client","log","Histogram","INTERVAL","nativeMetrics","interval","client","time","cpuUsage","gauges","counters","histograms","reset","module","exports","start","config","tags","Object","keys","filter","key","experimental","runtimeId","forEach","value","replace","push","e","error","host","dogstatsd","hostname","port","process","hrtime","setInterval","captureCommonMetrics","captureNativeMetrics","flush","captureCpuUsage","captureHeapSpace","unref","stop","clearInterval","track","span","handle","finish","boolean","name","tag","gauge","histogram","Map","has","set","get","record","count","monotonic","undefined","map","increment","decrement","elapsedTime","elapsedUsage","elapsedMs","userPercent","user","systemPercent","system","totalPercent","toFixed","captureMemoryUsage","stats","memoryUsage","heapTotal","heapUsed","rss","totalmem","freemem","external","captureProcess","Math","round","uptime","captureHeapStats","getHeapStatistics","total_heap_size","total_heap_size_executable","total_physical_size","total_available_size","heap_size_limit","malloced_memory","peak_malloced_memory","getHeapSpaceStatistics","i","l","length","space_name","space_size","space_used_size","space_available_size","physical_space_size","captureGauges","captureCounters","captureHistograms","spaces","heap","elapsedUs","cpu","eventLoop","gc","type","concat","min","max","sum","avg","median","p95"],"sources":["/Users/daniel.calderon/Projects/barkito/barkito_front/node_modules/dd-trace/packages/dd-trace/src/metrics.js"],"sourcesContent":["'use strict'\n\n// TODO: capture every second and flush every 10 seconds\n\nconst v8 = require('v8')\nconst os = require('os')\nconst Client = require('./dogstatsd')\nconst log = require('./log')\nconst Histogram = require('./histogram')\n\nconst INTERVAL = 10 * 1000\n\nlet nativeMetrics = null\n\nlet interval\nlet client\nlet time\nlet cpuUsage\nlet gauges\nlet counters\nlet histograms\n\nreset()\n\nmodule.exports = {\n  start (config) {\n    const tags = []\n\n    Object.keys(config.tags)\n      .filter(key => typeof config.tags[key] === 'string')\n      .filter(key => {\n        // Skip runtime-id unless enabled as cardinality may be too high\n        if (key !== 'runtime-id') return true\n        return (config.experimental && config.experimental.runtimeId)\n      })\n      .forEach(key => {\n        // https://docs.datadoghq.com/tagging/#defining-tags\n        const value = config.tags[key].replace(/[^a-z0-9_:./-]/ig, '_')\n\n        tags.push(`${key}:${value}`)\n      })\n\n    try {\n      nativeMetrics = require('@datadog/native-metrics')\n      nativeMetrics.start()\n    } catch (e) {\n      log.error(e)\n      nativeMetrics = null\n    }\n\n    client = new Client({\n      host: config.dogstatsd.hostname,\n      port: config.dogstatsd.port,\n      tags\n    })\n\n    time = process.hrtime()\n\n    if (nativeMetrics) {\n      interval = setInterval(() => {\n        captureCommonMetrics()\n        captureNativeMetrics()\n        client.flush()\n      }, INTERVAL)\n    } else {\n      cpuUsage = process.cpuUsage()\n\n      interval = setInterval(() => {\n        captureCommonMetrics()\n        captureCpuUsage()\n        captureHeapSpace()\n        client.flush()\n      }, INTERVAL)\n    }\n\n    interval.unref()\n  },\n\n  stop () {\n    if (nativeMetrics) {\n      nativeMetrics.stop()\n    }\n\n    clearInterval(interval)\n    reset()\n  },\n\n  track (span) {\n    if (nativeMetrics) {\n      const handle = nativeMetrics.track(span)\n\n      return {\n        finish: () => nativeMetrics.finish(handle)\n      }\n    }\n\n    return { finish: () => {} }\n  },\n\n  boolean (name, value, tag) {\n    this.gauge(name, value ? 1 : 0, tag)\n  },\n\n  histogram (name, value, tag) {\n    if (!client) return\n\n    histograms[name] = histograms[name] || new Map()\n\n    if (!histograms[name].has(tag)) {\n      histograms[name].set(tag, new Histogram())\n    }\n\n    histograms[name].get(tag).record(value)\n  },\n\n  count (name, count, tag, monotonic = false) {\n    if (!client) return\n    if (typeof tag === 'boolean') {\n      monotonic = tag\n      tag = undefined\n    }\n\n    const map = monotonic ? counters : gauges\n\n    map[name] = map[name] || new Map()\n\n    const value = map[name].get(tag) || 0\n\n    map[name].set(tag, value + count)\n  },\n\n  gauge (name, value, tag) {\n    if (!client) return\n\n    gauges[name] = gauges[name] || new Map()\n    gauges[name].set(tag, value)\n  },\n\n  increment (name, tag, monotonic) {\n    this.count(name, 1, tag, monotonic)\n  },\n\n  decrement (name, tag) {\n    this.count(name, -1, tag)\n  }\n}\n\nfunction reset () {\n  interval = null\n  client = null\n  time = null\n  cpuUsage = null\n  gauges = {}\n  counters = {}\n  histograms = {}\n  nativeMetrics = null\n}\n\nfunction captureCpuUsage () {\n  if (!process.cpuUsage) return\n\n  const elapsedTime = process.hrtime(time)\n  const elapsedUsage = process.cpuUsage(cpuUsage)\n\n  time = process.hrtime()\n  cpuUsage = process.cpuUsage()\n\n  const elapsedMs = elapsedTime[0] * 1000 + elapsedTime[1] / 1000000\n  const userPercent = 100 * elapsedUsage.user / 1000 / elapsedMs\n  const systemPercent = 100 * elapsedUsage.system / 1000 / elapsedMs\n  const totalPercent = userPercent + systemPercent\n\n  client.gauge('runtime.node.cpu.system', systemPercent.toFixed(2))\n  client.gauge('runtime.node.cpu.user', userPercent.toFixed(2))\n  client.gauge('runtime.node.cpu.total', totalPercent.toFixed(2))\n}\n\nfunction captureMemoryUsage () {\n  const stats = process.memoryUsage()\n\n  client.gauge('runtime.node.mem.heap_total', stats.heapTotal)\n  client.gauge('runtime.node.mem.heap_used', stats.heapUsed)\n  client.gauge('runtime.node.mem.rss', stats.rss)\n  client.gauge('runtime.node.mem.total', os.totalmem())\n  client.gauge('runtime.node.mem.free', os.freemem())\n\n  stats.external && client.gauge('runtime.node.mem.external', stats.external)\n}\n\nfunction captureProcess () {\n  client.gauge('runtime.node.process.uptime', Math.round(process.uptime()))\n}\n\nfunction captureHeapStats () {\n  const stats = v8.getHeapStatistics()\n\n  client.gauge('runtime.node.heap.total_heap_size', stats.total_heap_size)\n  client.gauge('runtime.node.heap.total_heap_size_executable', stats.total_heap_size_executable)\n  client.gauge('runtime.node.heap.total_physical_size', stats.total_physical_size)\n  client.gauge('runtime.node.heap.total_available_size', stats.total_available_size)\n  client.gauge('runtime.node.heap.heap_size_limit', stats.heap_size_limit)\n\n  stats.malloced_memory && client.gauge('runtime.node.heap.malloced_memory', stats.malloced_memory)\n  stats.peak_malloced_memory && client.gauge('runtime.node.heap.peak_malloced_memory', stats.peak_malloced_memory)\n}\n\nfunction captureHeapSpace () {\n  if (!v8.getHeapSpaceStatistics) return\n\n  const stats = v8.getHeapSpaceStatistics()\n\n  for (let i = 0, l = stats.length; i < l; i++) {\n    const tags = [`space:${stats[i].space_name}`]\n\n    client.gauge('runtime.node.heap.size.by.space', stats[i].space_size, tags)\n    client.gauge('runtime.node.heap.used_size.by.space', stats[i].space_used_size, tags)\n    client.gauge('runtime.node.heap.available_size.by.space', stats[i].space_available_size, tags)\n    client.gauge('runtime.node.heap.physical_size.by.space', stats[i].physical_space_size, tags)\n  }\n}\n\nfunction captureGauges () {\n  Object.keys(gauges).forEach(name => {\n    gauges[name].forEach((value, tag) => {\n      client.gauge(name, value, tag && [tag])\n    })\n  })\n}\n\nfunction captureCounters () {\n  Object.keys(counters).forEach(name => {\n    counters[name].forEach((value, tag) => {\n      client.increment(name, value, tag && [tag])\n    })\n  })\n\n  counters = {}\n}\n\nfunction captureHistograms () {\n  Object.keys(histograms).forEach(name => {\n    histograms[name].forEach((stats, tag) => {\n      histogram(name, stats, tag && [tag])\n      stats.reset()\n    })\n  })\n}\n\nfunction captureCommonMetrics () {\n  captureMemoryUsage()\n  captureProcess()\n  captureHeapStats()\n  captureGauges()\n  captureCounters()\n  captureHistograms()\n}\n\nfunction captureNativeMetrics () {\n  const stats = nativeMetrics.stats()\n  const spaces = stats.heap.spaces\n  const elapsedTime = process.hrtime(time)\n\n  time = process.hrtime()\n\n  const elapsedUs = elapsedTime[0] * 1e6 + elapsedTime[1] / 1e3\n  const userPercent = 100 * stats.cpu.user / elapsedUs\n  const systemPercent = 100 * stats.cpu.system / elapsedUs\n  const totalPercent = userPercent + systemPercent\n\n  client.gauge('runtime.node.cpu.system', systemPercent.toFixed(2))\n  client.gauge('runtime.node.cpu.user', userPercent.toFixed(2))\n  client.gauge('runtime.node.cpu.total', totalPercent.toFixed(2))\n\n  histogram('runtime.node.event_loop.delay', stats.eventLoop)\n\n  Object.keys(stats.gc).forEach(type => {\n    if (type === 'all') {\n      histogram('runtime.node.gc.pause', stats.gc[type])\n    } else {\n      histogram('runtime.node.gc.pause.by.type', stats.gc[type], [`gc_type:${type}`])\n    }\n  })\n\n  for (let i = 0, l = spaces.length; i < l; i++) {\n    const tags = [`heap_space:${spaces[i].space_name}`]\n\n    client.gauge('runtime.node.heap.size.by.space', spaces[i].space_size, tags)\n    client.gauge('runtime.node.heap.used_size.by.space', spaces[i].space_used_size, tags)\n    client.gauge('runtime.node.heap.available_size.by.space', spaces[i].space_available_size, tags)\n    client.gauge('runtime.node.heap.physical_size.by.space', spaces[i].physical_space_size, tags)\n  }\n}\n\nfunction histogram (name, stats, tags) {\n  tags = [].concat(tags)\n\n  client.gauge(`${name}.min`, stats.min, tags)\n  client.gauge(`${name}.max`, stats.max, tags)\n  client.increment(`${name}.sum`, stats.sum, tags)\n  client.increment(`${name}.total`, stats.sum, tags)\n  client.gauge(`${name}.avg`, stats.avg, tags)\n  client.increment(`${name}.count`, stats.count, tags)\n  client.gauge(`${name}.median`, stats.median, tags)\n  client.gauge(`${name}.95percentile`, stats.p95, tags)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}