{"ast":null,"code":"/**\r\n * A hierarchical token bucket for rate limiting. See\r\n * http://en.wikipedia.org/wiki/Token_bucket for more information.\r\n * @author John Hurliman <jhurliman@cull.tv>\r\n *\r\n * @param {Number} bucketSize Maximum number of tokens to hold in the bucket.\r\n *  Also known as the burst rate.\r\n * @param {Number} tokensPerInterval Number of tokens to drip into the bucket\r\n *  over the course of one interval.\r\n * @param {String|Number} interval The interval length in milliseconds, or as\r\n *  one of the following strings: 'second', 'minute', 'hour', day'.\r\n * @param {TokenBucket} parentBucket Optional. A token bucket that will act as\r\n *  the parent of this bucket.\r\n */\nvar TokenBucket = function (bucketSize, tokensPerInterval, interval, parentBucket) {\n  this.bucketSize = bucketSize;\n  this.tokensPerInterval = tokensPerInterval;\n\n  if (typeof interval === 'string') {\n    switch (interval) {\n      case 'sec':\n      case 'second':\n        this.interval = 1000;\n        break;\n\n      case 'min':\n      case 'minute':\n        this.interval = 1000 * 60;\n        break;\n\n      case 'hr':\n      case 'hour':\n        this.interval = 1000 * 60 * 60;\n        break;\n\n      case 'day':\n        this.interval = 1000 * 60 * 60 * 24;\n        break;\n\n      default:\n        throw new Error('Invaid interval ' + interval);\n    }\n  } else {\n    this.interval = interval;\n  }\n\n  this.parentBucket = parentBucket;\n  this.content = 0;\n  this.lastDrip = +new Date();\n};\n\nTokenBucket.prototype = {\n  bucketSize: 1,\n  tokensPerInterval: 1,\n  interval: 1000,\n  parentBucket: null,\n  content: 0,\n  lastDrip: 0,\n\n  /**\r\n   * Remove the requested number of tokens and fire the given callback. If the\r\n   * bucket (and any parent buckets) contains enough tokens this will happen\r\n   * immediately. Otherwise, the removal and callback will happen when enough\r\n   * tokens become available.\r\n   * @param {Number} count The number of tokens to remove.\r\n   * @param {Function} callback(err, remainingTokens)\r\n   * @returns {Boolean} True if the callback was fired immediately, otherwise\r\n   *  false.\r\n   */\n  removeTokens: function (count, callback) {\n    var self = this; // Is this an infinite size bucket?\n\n    if (!this.bucketSize) {\n      process.nextTick(callback.bind(null, null, count, Number.POSITIVE_INFINITY));\n      return true;\n    } // Make sure the bucket can hold the requested number of tokens\n\n\n    if (count > this.bucketSize) {\n      process.nextTick(callback.bind(null, 'Requested tokens ' + count + ' exceeds bucket size ' + this.bucketSize, null));\n      return false;\n    } // Drip new tokens into this bucket\n\n\n    this.drip(); // If we don't have enough tokens in this bucket, come back later\n\n    if (count > this.content) return comeBackLater();\n\n    if (this.parentBucket) {\n      // Remove the requested from the parent bucket first\n      return this.parentBucket.removeTokens(count, function (err, remainingTokens) {\n        if (err) return callback(err, null); // Check that we still have enough tokens in this bucket\n\n        if (count > self.content) return comeBackLater(); // Tokens were removed from the parent bucket, now remove them from\n        // this bucket and fire the callback. Note that we look at the current\n        // bucket and parent bucket's remaining tokens and return the smaller\n        // of the two values\n\n        self.content -= count;\n        callback(null, Math.min(remainingTokens, self.content));\n      });\n    } else {\n      // Remove the requested tokens from this bucket and fire the callback\n      this.content -= count;\n      process.nextTick(callback.bind(null, null, this.content));\n      return true;\n    }\n\n    function comeBackLater() {\n      // How long do we need to wait to make up the difference in tokens?\n      var waitInterval = Math.ceil((count - self.content) * (self.interval / self.tokensPerInterval));\n      setTimeout(function () {\n        self.removeTokens(count, callback);\n      }, waitInterval);\n      return false;\n    }\n  },\n\n  /**\r\n   * Attempt to remove the requested number of tokens and return immediately.\r\n   * If the bucket (and any parent buckets) contains enough tokens this will\r\n   * return true, otherwise false is returned.\r\n   * @param {Number} count The number of tokens to remove.\r\n   * @param {Boolean} True if the tokens were successfully removed, otherwise\r\n   *  false.\r\n   */\n  tryRemoveTokens: function (count) {\n    // Is this an infinite size bucket?\n    if (!this.bucketSize) return true; // Make sure the bucket can hold the requested number of tokens\n\n    if (count > this.bucketSize) return false; // Drip new tokens into this bucket\n\n    this.drip(); // If we don't have enough tokens in this bucket, return false\n\n    if (count > this.content) return false; // Try to remove the requested tokens from the parent bucket\n\n    if (this.parentBucket && !this.parentBucket.tryRemoveTokens(count)) return false; // Remove the requested tokens from this bucket and return\n\n    this.content -= count;\n    return true;\n  },\n\n  /**\r\n   * Add any new tokens to the bucket since the last drip.\r\n   * @returns {Boolean} True if new tokens were added, otherwise false.\r\n   */\n  drip: function () {\n    if (!this.tokensPerInterval) {\n      this.content = this.bucketSize;\n      return;\n    }\n\n    var now = +new Date();\n    var deltaMS = Math.max(now - this.lastDrip, 0);\n    this.lastDrip = now;\n    var dripAmount = deltaMS * (this.tokensPerInterval / this.interval);\n    this.content = Math.min(this.content + dripAmount, this.bucketSize);\n  }\n};\nmodule.exports = TokenBucket;","map":{"version":3,"names":["TokenBucket","bucketSize","tokensPerInterval","interval","parentBucket","Error","content","lastDrip","Date","prototype","removeTokens","count","callback","self","process","nextTick","bind","Number","POSITIVE_INFINITY","drip","comeBackLater","err","remainingTokens","Math","min","waitInterval","ceil","setTimeout","tryRemoveTokens","now","deltaMS","max","dripAmount","module","exports"],"sources":["/Users/daniel.calderon/Projects/barkito/barkito_front/node_modules/limiter/lib/tokenBucket.js"],"sourcesContent":["\r\n/**\r\n * A hierarchical token bucket for rate limiting. See\r\n * http://en.wikipedia.org/wiki/Token_bucket for more information.\r\n * @author John Hurliman <jhurliman@cull.tv>\r\n *\r\n * @param {Number} bucketSize Maximum number of tokens to hold in the bucket.\r\n *  Also known as the burst rate.\r\n * @param {Number} tokensPerInterval Number of tokens to drip into the bucket\r\n *  over the course of one interval.\r\n * @param {String|Number} interval The interval length in milliseconds, or as\r\n *  one of the following strings: 'second', 'minute', 'hour', day'.\r\n * @param {TokenBucket} parentBucket Optional. A token bucket that will act as\r\n *  the parent of this bucket.\r\n */\r\nvar TokenBucket = function(bucketSize, tokensPerInterval, interval, parentBucket) {\r\n  this.bucketSize = bucketSize;\r\n  this.tokensPerInterval = tokensPerInterval;\r\n\r\n  if (typeof interval === 'string') {\r\n    switch (interval) {\r\n      case 'sec': case 'second':\r\n        this.interval = 1000; break;\r\n      case 'min': case 'minute':\r\n        this.interval = 1000 * 60; break;\r\n      case 'hr': case 'hour':\r\n        this.interval = 1000 * 60 * 60; break;\r\n      case 'day':\r\n        this.interval = 1000 * 60 * 60 * 24; break;\r\n      default:\r\n        throw new Error('Invaid interval ' + interval);\r\n    }\r\n  } else {\r\n    this.interval = interval;\r\n  }\r\n\r\n  this.parentBucket = parentBucket;\r\n  this.content = 0;\r\n  this.lastDrip = +new Date();\r\n};\r\n\r\nTokenBucket.prototype = {\r\n  bucketSize: 1,\r\n  tokensPerInterval: 1,\r\n  interval: 1000,\r\n  parentBucket: null,\r\n  content: 0,\r\n  lastDrip: 0,\r\n\r\n  /**\r\n   * Remove the requested number of tokens and fire the given callback. If the\r\n   * bucket (and any parent buckets) contains enough tokens this will happen\r\n   * immediately. Otherwise, the removal and callback will happen when enough\r\n   * tokens become available.\r\n   * @param {Number} count The number of tokens to remove.\r\n   * @param {Function} callback(err, remainingTokens)\r\n   * @returns {Boolean} True if the callback was fired immediately, otherwise\r\n   *  false.\r\n   */\r\n  removeTokens: function(count, callback) {\r\n    var self = this;\r\n\r\n    // Is this an infinite size bucket?\r\n    if (!this.bucketSize) {\r\n      process.nextTick(callback.bind(null, null, count, Number.POSITIVE_INFINITY));\r\n      return true;\r\n    }\r\n\r\n    // Make sure the bucket can hold the requested number of tokens\r\n    if (count > this.bucketSize) {\r\n      process.nextTick(callback.bind(null, 'Requested tokens ' + count + ' exceeds bucket size ' +\r\n        this.bucketSize, null));\r\n      return false;\r\n    }\r\n\r\n    // Drip new tokens into this bucket\r\n    this.drip();\r\n\r\n    // If we don't have enough tokens in this bucket, come back later\r\n    if (count > this.content)\r\n      return comeBackLater();\r\n\r\n    if (this.parentBucket) {\r\n      // Remove the requested from the parent bucket first\r\n      return this.parentBucket.removeTokens(count, function(err, remainingTokens) {\r\n        if (err) return callback(err, null);\r\n\r\n        // Check that we still have enough tokens in this bucket\r\n        if (count > self.content)\r\n          return comeBackLater();\r\n\r\n        // Tokens were removed from the parent bucket, now remove them from\r\n        // this bucket and fire the callback. Note that we look at the current\r\n        // bucket and parent bucket's remaining tokens and return the smaller\r\n        // of the two values\r\n        self.content -= count;\r\n        callback(null, Math.min(remainingTokens, self.content));\r\n      });\r\n    } else {\r\n      // Remove the requested tokens from this bucket and fire the callback\r\n      this.content -= count;\r\n      process.nextTick(callback.bind(null, null, this.content));\r\n      return true;\r\n    }\r\n\r\n    function comeBackLater() {\r\n      // How long do we need to wait to make up the difference in tokens?\r\n      var waitInterval = Math.ceil(\r\n        (count - self.content) * (self.interval / self.tokensPerInterval));\r\n      setTimeout(function() { self.removeTokens(count, callback); }, waitInterval);\r\n      return false;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Attempt to remove the requested number of tokens and return immediately.\r\n   * If the bucket (and any parent buckets) contains enough tokens this will\r\n   * return true, otherwise false is returned.\r\n   * @param {Number} count The number of tokens to remove.\r\n   * @param {Boolean} True if the tokens were successfully removed, otherwise\r\n   *  false.\r\n   */\r\n  tryRemoveTokens: function(count) {\r\n    // Is this an infinite size bucket?\r\n    if (!this.bucketSize)\r\n      return true;\r\n\r\n    // Make sure the bucket can hold the requested number of tokens\r\n    if (count > this.bucketSize)\r\n      return false;\r\n\r\n    // Drip new tokens into this bucket\r\n    this.drip();\r\n\r\n    // If we don't have enough tokens in this bucket, return false\r\n    if (count > this.content)\r\n      return false;\r\n\r\n    // Try to remove the requested tokens from the parent bucket\r\n    if (this.parentBucket && !this.parentBucket.tryRemoveTokens(count))\r\n      return false;\r\n\r\n    // Remove the requested tokens from this bucket and return\r\n    this.content -= count;\r\n    return true;\r\n  },\r\n\r\n  /**\r\n   * Add any new tokens to the bucket since the last drip.\r\n   * @returns {Boolean} True if new tokens were added, otherwise false.\r\n   */\r\n  drip: function() {\r\n    if (!this.tokensPerInterval) {\r\n      this.content = this.bucketSize;\r\n      return;\r\n    }\r\n\r\n    var now = +new Date();\r\n    var deltaMS = Math.max(now - this.lastDrip, 0);\r\n    this.lastDrip = now;\r\n\r\n    var dripAmount = deltaMS * (this.tokensPerInterval / this.interval);\r\n    this.content = Math.min(this.content + dripAmount, this.bucketSize);\r\n  }\r\n};\r\n\r\nmodule.exports = TokenBucket;\r\n"],"mappings":"AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIA,WAAW,GAAG,UAASC,UAAT,EAAqBC,iBAArB,EAAwCC,QAAxC,EAAkDC,YAAlD,EAAgE;EAChF,KAAKH,UAAL,GAAkBA,UAAlB;EACA,KAAKC,iBAAL,GAAyBA,iBAAzB;;EAEA,IAAI,OAAOC,QAAP,KAAoB,QAAxB,EAAkC;IAChC,QAAQA,QAAR;MACE,KAAK,KAAL;MAAY,KAAK,QAAL;QACV,KAAKA,QAAL,GAAgB,IAAhB;QAAsB;;MACxB,KAAK,KAAL;MAAY,KAAK,QAAL;QACV,KAAKA,QAAL,GAAgB,OAAO,EAAvB;QAA2B;;MAC7B,KAAK,IAAL;MAAW,KAAK,MAAL;QACT,KAAKA,QAAL,GAAgB,OAAO,EAAP,GAAY,EAA5B;QAAgC;;MAClC,KAAK,KAAL;QACE,KAAKA,QAAL,GAAgB,OAAO,EAAP,GAAY,EAAZ,GAAiB,EAAjC;QAAqC;;MACvC;QACE,MAAM,IAAIE,KAAJ,CAAU,qBAAqBF,QAA/B,CAAN;IAVJ;EAYD,CAbD,MAaO;IACL,KAAKA,QAAL,GAAgBA,QAAhB;EACD;;EAED,KAAKC,YAAL,GAAoBA,YAApB;EACA,KAAKE,OAAL,GAAe,CAAf;EACA,KAAKC,QAAL,GAAgB,CAAC,IAAIC,IAAJ,EAAjB;AACD,CAxBD;;AA0BAR,WAAW,CAACS,SAAZ,GAAwB;EACtBR,UAAU,EAAE,CADU;EAEtBC,iBAAiB,EAAE,CAFG;EAGtBC,QAAQ,EAAE,IAHY;EAItBC,YAAY,EAAE,IAJQ;EAKtBE,OAAO,EAAE,CALa;EAMtBC,QAAQ,EAAE,CANY;;EAQtB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEG,YAAY,EAAE,UAASC,KAAT,EAAgBC,QAAhB,EAA0B;IACtC,IAAIC,IAAI,GAAG,IAAX,CADsC,CAGtC;;IACA,IAAI,CAAC,KAAKZ,UAAV,EAAsB;MACpBa,OAAO,CAACC,QAAR,CAAiBH,QAAQ,CAACI,IAAT,CAAc,IAAd,EAAoB,IAApB,EAA0BL,KAA1B,EAAiCM,MAAM,CAACC,iBAAxC,CAAjB;MACA,OAAO,IAAP;IACD,CAPqC,CAStC;;;IACA,IAAIP,KAAK,GAAG,KAAKV,UAAjB,EAA6B;MAC3Ba,OAAO,CAACC,QAAR,CAAiBH,QAAQ,CAACI,IAAT,CAAc,IAAd,EAAoB,sBAAsBL,KAAtB,GAA8B,uBAA9B,GACnC,KAAKV,UADU,EACE,IADF,CAAjB;MAEA,OAAO,KAAP;IACD,CAdqC,CAgBtC;;;IACA,KAAKkB,IAAL,GAjBsC,CAmBtC;;IACA,IAAIR,KAAK,GAAG,KAAKL,OAAjB,EACE,OAAOc,aAAa,EAApB;;IAEF,IAAI,KAAKhB,YAAT,EAAuB;MACrB;MACA,OAAO,KAAKA,YAAL,CAAkBM,YAAlB,CAA+BC,KAA/B,EAAsC,UAASU,GAAT,EAAcC,eAAd,EAA+B;QAC1E,IAAID,GAAJ,EAAS,OAAOT,QAAQ,CAACS,GAAD,EAAM,IAAN,CAAf,CADiE,CAG1E;;QACA,IAAIV,KAAK,GAAGE,IAAI,CAACP,OAAjB,EACE,OAAOc,aAAa,EAApB,CALwE,CAO1E;QACA;QACA;QACA;;QACAP,IAAI,CAACP,OAAL,IAAgBK,KAAhB;QACAC,QAAQ,CAAC,IAAD,EAAOW,IAAI,CAACC,GAAL,CAASF,eAAT,EAA0BT,IAAI,CAACP,OAA/B,CAAP,CAAR;MACD,CAbM,CAAP;IAcD,CAhBD,MAgBO;MACL;MACA,KAAKA,OAAL,IAAgBK,KAAhB;MACAG,OAAO,CAACC,QAAR,CAAiBH,QAAQ,CAACI,IAAT,CAAc,IAAd,EAAoB,IAApB,EAA0B,KAAKV,OAA/B,CAAjB;MACA,OAAO,IAAP;IACD;;IAED,SAASc,aAAT,GAAyB;MACvB;MACA,IAAIK,YAAY,GAAGF,IAAI,CAACG,IAAL,CACjB,CAACf,KAAK,GAAGE,IAAI,CAACP,OAAd,KAA0BO,IAAI,CAACV,QAAL,GAAgBU,IAAI,CAACX,iBAA/C,CADiB,CAAnB;MAEAyB,UAAU,CAAC,YAAW;QAAEd,IAAI,CAACH,YAAL,CAAkBC,KAAlB,EAAyBC,QAAzB;MAAqC,CAAnD,EAAqDa,YAArD,CAAV;MACA,OAAO,KAAP;IACD;EACF,CAvEqB;;EAyEtB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEG,eAAe,EAAE,UAASjB,KAAT,EAAgB;IAC/B;IACA,IAAI,CAAC,KAAKV,UAAV,EACE,OAAO,IAAP,CAH6B,CAK/B;;IACA,IAAIU,KAAK,GAAG,KAAKV,UAAjB,EACE,OAAO,KAAP,CAP6B,CAS/B;;IACA,KAAKkB,IAAL,GAV+B,CAY/B;;IACA,IAAIR,KAAK,GAAG,KAAKL,OAAjB,EACE,OAAO,KAAP,CAd6B,CAgB/B;;IACA,IAAI,KAAKF,YAAL,IAAqB,CAAC,KAAKA,YAAL,CAAkBwB,eAAlB,CAAkCjB,KAAlC,CAA1B,EACE,OAAO,KAAP,CAlB6B,CAoB/B;;IACA,KAAKL,OAAL,IAAgBK,KAAhB;IACA,OAAO,IAAP;EACD,CAxGqB;;EA0GtB;AACF;AACA;AACA;EACEQ,IAAI,EAAE,YAAW;IACf,IAAI,CAAC,KAAKjB,iBAAV,EAA6B;MAC3B,KAAKI,OAAL,GAAe,KAAKL,UAApB;MACA;IACD;;IAED,IAAI4B,GAAG,GAAG,CAAC,IAAIrB,IAAJ,EAAX;IACA,IAAIsB,OAAO,GAAGP,IAAI,CAACQ,GAAL,CAASF,GAAG,GAAG,KAAKtB,QAApB,EAA8B,CAA9B,CAAd;IACA,KAAKA,QAAL,GAAgBsB,GAAhB;IAEA,IAAIG,UAAU,GAAGF,OAAO,IAAI,KAAK5B,iBAAL,GAAyB,KAAKC,QAAlC,CAAxB;IACA,KAAKG,OAAL,GAAeiB,IAAI,CAACC,GAAL,CAAS,KAAKlB,OAAL,GAAe0B,UAAxB,EAAoC,KAAK/B,UAAzC,CAAf;EACD;AA1HqB,CAAxB;AA6HAgC,MAAM,CAACC,OAAP,GAAiBlC,WAAjB"},"metadata":{},"sourceType":"script"}