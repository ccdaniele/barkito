{"ast":null,"code":"'use strict';\n\nconst types = require('./types');\n\nconst {\n  addHook,\n  channel,\n  AsyncResource\n} = require('../helpers/instrument');\n\nconst shimmer = require('../../../datadog-shimmer');\n\nconst patched = new WeakSet();\nconst instances = new WeakMap();\nconst startChannel = channel('apm:grpc:client:request:start');\nconst errorChannel = channel('apm:grpc:client:request:error');\nconst finishChannel = channel('apm:grpc:client:request:finish');\n\nfunction createWrapMakeRequest(type) {\n  return function wrapMakeRequest(makeRequest) {\n    return function (path) {\n      const args = ensureMetadata(this, arguments, 4);\n      return callMethod(this, makeRequest, args, path, args[4], type);\n    };\n  };\n}\n\nfunction createWrapLoadPackageDefinition() {\n  return function wrapLoadPackageDefinition(loadPackageDefinition) {\n    return function (packageDef) {\n      const result = loadPackageDefinition.apply(this, arguments);\n      if (!result) return result;\n      wrapPackageDefinition(result);\n      return result;\n    };\n  };\n}\n\nfunction createWrapMakeClientConstructor() {\n  return function wrapMakeClientConstructor(makeClientConstructor) {\n    return function (methods) {\n      const ServiceClient = makeClientConstructor.apply(this, arguments);\n      wrapClientConstructor(ServiceClient, methods);\n      return ServiceClient;\n    };\n  };\n}\n\nfunction wrapPackageDefinition(def) {\n  for (const name in def) {\n    if (def[name].format) continue;\n\n    if (def[name].service && def[name].prototype) {\n      wrapClientConstructor(def[name], def[name].service);\n    } else {\n      wrapPackageDefinition(def[name]);\n    }\n  }\n}\n\nfunction wrapClientConstructor(ServiceClient, methods) {\n  const proto = ServiceClient.prototype;\n  if (typeof methods !== 'object' || 'format' in methods) return;\n  Object.keys(methods).forEach(name => {\n    if (!methods[name]) return;\n    const originalName = methods[name].originalName;\n    const path = methods[name].path;\n    const type = getType(methods[name]);\n\n    if (methods[name]) {\n      proto[name] = wrapMethod(proto[name], path, type);\n    }\n\n    if (originalName) {\n      proto[originalName] = wrapMethod(proto[originalName], path, type);\n    }\n  });\n}\n\nfunction wrapMethod(method, path, type) {\n  if (typeof method !== 'function' || patched.has(method)) {\n    return method;\n  }\n\n  const wrapped = function () {\n    const args = ensureMetadata(this, arguments, 1);\n    return callMethod(this, method, args, path, args[1], type);\n  };\n\n  Object.assign(wrapped, method);\n  patched.add(wrapped);\n  return wrapped;\n}\n\nfunction wrapCallback(requestResource, parentResource, callback) {\n  return function (err) {\n    if (err) {\n      requestResource.runInAsyncScope(() => {\n        errorChannel.publish(err);\n      });\n    }\n\n    if (callback) {\n      return parentResource.runInAsyncScope(() => {\n        return callback.apply(this, arguments);\n      });\n    }\n  };\n}\n\nfunction wrapStream(call, requestResource, parentResource) {\n  if (!call || typeof call.emit !== 'function') return;\n  shimmer.wrap(call, 'emit', emit => {\n    return function (eventName) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      requestResource.runInAsyncScope(() => {\n        switch (eventName) {\n          case 'error':\n            errorChannel.publish(args[0]);\n            break;\n\n          case 'status':\n            finishChannel.publish(args[0]);\n            break;\n        }\n      });\n      return parentResource.runInAsyncScope(() => {\n        return emit.apply(this, arguments);\n      });\n    };\n  });\n}\n\nfunction callMethod(client, method, args, path, metadata, type) {\n  if (!startChannel.hasSubscribers) return method.apply(client, args);\n  const length = args.length;\n  const callback = args[length - 1];\n  const parentResource = new AsyncResource('bound-anonymous-fn');\n  const requestResource = new AsyncResource('bound-anonymous-fn');\n  return requestResource.runInAsyncScope(() => {\n    startChannel.publish({\n      metadata,\n      path,\n      type\n    });\n\n    if (type === types.unary || type === types.client_stream) {\n      if (typeof callback === 'function') {\n        args[length - 1] = wrapCallback(requestResource, parentResource, callback);\n      } else {\n        args[length] = wrapCallback(requestResource, parentResource);\n      }\n    }\n\n    const call = method.apply(client, args);\n    wrapStream(call, requestResource, parentResource);\n    return call;\n  });\n}\n\nfunction ensureMetadata(client, args, index) {\n  const grpc = getGrpc(client);\n  if (!client || !grpc) return args;\n  const meta = args[index];\n  const normalized = [];\n\n  for (let i = 0; i < index; i++) {\n    normalized.push(args[i]);\n  }\n\n  if (!meta || !meta.constructor || meta.constructor.name !== 'Metadata') {\n    normalized.push(new grpc.Metadata());\n  }\n\n  if (meta) {\n    normalized.push(meta);\n  }\n\n  for (let i = index + 1; i < args.length; i++) {\n    normalized.push(args[i]);\n  }\n\n  return normalized;\n}\n\nfunction getType(definition) {\n  if (definition.requestStream) {\n    if (definition.responseStream) {\n      return types.bidi;\n    }\n\n    return types.client_stream;\n  }\n\n  if (definition.responseStream) {\n    return types.server_stream;\n  }\n\n  return types.unary;\n}\n\nfunction getGrpc(client) {\n  let proto = client;\n\n  do {\n    const instance = instances.get(proto);\n    if (instance) return instance;\n  } while (proto = Object.getPrototypeOf(proto));\n}\n\nfunction patch(grpc) {\n  const proto = grpc.Client.prototype;\n  instances.set(proto, grpc);\n  shimmer.wrap(proto, 'makeBidiStreamRequest', createWrapMakeRequest(types.bidi));\n  shimmer.wrap(proto, 'makeClientStreamRequest', createWrapMakeRequest(types.clientStream));\n  shimmer.wrap(proto, 'makeServerStreamRequest', createWrapMakeRequest(types.serverStream));\n  shimmer.wrap(proto, 'makeUnaryRequest', createWrapMakeRequest(types.unary));\n  return grpc;\n}\n\naddHook({\n  name: 'grpc',\n  versions: ['>=1.24.3']\n}, patch);\naddHook({\n  name: 'grpc',\n  versions: ['>=1.24.3'],\n  file: 'src/client.js'\n}, client => {\n  shimmer.wrap(client, 'makeClientConstructor', createWrapMakeClientConstructor());\n  return client;\n});\naddHook({\n  name: '@grpc/grpc-js',\n  versions: ['>=1.0.3']\n}, patch);\naddHook({\n  name: '@grpc/grpc-js',\n  versions: ['>=1.0.3'],\n  file: 'build/src/make-client.js'\n}, client => {\n  shimmer.wrap(client, 'makeClientConstructor', createWrapMakeClientConstructor());\n  shimmer.wrap(client, 'loadPackageDefinition', createWrapLoadPackageDefinition());\n  return client;\n});","map":{"version":3,"names":["types","require","addHook","channel","AsyncResource","shimmer","patched","WeakSet","instances","WeakMap","startChannel","errorChannel","finishChannel","createWrapMakeRequest","type","wrapMakeRequest","makeRequest","path","args","ensureMetadata","arguments","callMethod","createWrapLoadPackageDefinition","wrapLoadPackageDefinition","loadPackageDefinition","packageDef","result","apply","wrapPackageDefinition","createWrapMakeClientConstructor","wrapMakeClientConstructor","makeClientConstructor","methods","ServiceClient","wrapClientConstructor","def","name","format","service","prototype","proto","Object","keys","forEach","originalName","getType","wrapMethod","method","has","wrapped","assign","add","wrapCallback","requestResource","parentResource","callback","err","runInAsyncScope","publish","wrapStream","call","emit","wrap","eventName","client","metadata","hasSubscribers","length","unary","client_stream","index","grpc","getGrpc","meta","normalized","i","push","constructor","Metadata","definition","requestStream","responseStream","bidi","server_stream","instance","get","getPrototypeOf","patch","Client","set","clientStream","serverStream","versions","file"],"sources":["/Users/daniel.calderon/Projects/barkito/barkito_front/node_modules/dd-trace/packages/datadog-instrumentations/src/grpc/client.js"],"sourcesContent":["'use strict'\n\nconst types = require('./types')\nconst { addHook, channel, AsyncResource } = require('../helpers/instrument')\nconst shimmer = require('../../../datadog-shimmer')\n\nconst patched = new WeakSet()\nconst instances = new WeakMap()\n\nconst startChannel = channel('apm:grpc:client:request:start')\nconst errorChannel = channel('apm:grpc:client:request:error')\nconst finishChannel = channel('apm:grpc:client:request:finish')\n\nfunction createWrapMakeRequest (type) {\n  return function wrapMakeRequest (makeRequest) {\n    return function (path) {\n      const args = ensureMetadata(this, arguments, 4)\n\n      return callMethod(this, makeRequest, args, path, args[4], type)\n    }\n  }\n}\n\nfunction createWrapLoadPackageDefinition () {\n  return function wrapLoadPackageDefinition (loadPackageDefinition) {\n    return function (packageDef) {\n      const result = loadPackageDefinition.apply(this, arguments)\n\n      if (!result) return result\n\n      wrapPackageDefinition(result)\n\n      return result\n    }\n  }\n}\n\nfunction createWrapMakeClientConstructor () {\n  return function wrapMakeClientConstructor (makeClientConstructor) {\n    return function (methods) {\n      const ServiceClient = makeClientConstructor.apply(this, arguments)\n\n      wrapClientConstructor(ServiceClient, methods)\n\n      return ServiceClient\n    }\n  }\n}\n\nfunction wrapPackageDefinition (def) {\n  for (const name in def) {\n    if (def[name].format) continue\n    if (def[name].service && def[name].prototype) {\n      wrapClientConstructor(def[name], def[name].service)\n    } else {\n      wrapPackageDefinition(def[name])\n    }\n  }\n}\n\nfunction wrapClientConstructor (ServiceClient, methods) {\n  const proto = ServiceClient.prototype\n\n  if (typeof methods !== 'object' || 'format' in methods) return\n\n  Object.keys(methods)\n    .forEach(name => {\n      if (!methods[name]) return\n\n      const originalName = methods[name].originalName\n      const path = methods[name].path\n      const type = getType(methods[name])\n\n      if (methods[name]) {\n        proto[name] = wrapMethod(proto[name], path, type)\n      }\n\n      if (originalName) {\n        proto[originalName] = wrapMethod(proto[originalName], path, type)\n      }\n    })\n}\n\nfunction wrapMethod (method, path, type) {\n  if (typeof method !== 'function' || patched.has(method)) {\n    return method\n  }\n\n  const wrapped = function () {\n    const args = ensureMetadata(this, arguments, 1)\n\n    return callMethod(this, method, args, path, args[1], type)\n  }\n\n  Object.assign(wrapped, method)\n\n  patched.add(wrapped)\n\n  return wrapped\n}\n\nfunction wrapCallback (requestResource, parentResource, callback) {\n  return function (err) {\n    if (err) {\n      requestResource.runInAsyncScope(() => {\n        errorChannel.publish(err)\n      })\n    }\n\n    if (callback) {\n      return parentResource.runInAsyncScope(() => {\n        return callback.apply(this, arguments)\n      })\n    }\n  }\n}\n\nfunction wrapStream (call, requestResource, parentResource) {\n  if (!call || typeof call.emit !== 'function') return\n\n  shimmer.wrap(call, 'emit', emit => {\n    return function (eventName, ...args) {\n      requestResource.runInAsyncScope(() => {\n        switch (eventName) {\n          case 'error':\n            errorChannel.publish(args[0])\n\n            break\n          case 'status':\n            finishChannel.publish(args[0])\n\n            break\n        }\n      })\n\n      return parentResource.runInAsyncScope(() => {\n        return emit.apply(this, arguments)\n      })\n    }\n  })\n}\n\nfunction callMethod (client, method, args, path, metadata, type) {\n  if (!startChannel.hasSubscribers) return method.apply(client, args)\n\n  const length = args.length\n  const callback = args[length - 1]\n  const parentResource = new AsyncResource('bound-anonymous-fn')\n  const requestResource = new AsyncResource('bound-anonymous-fn')\n\n  return requestResource.runInAsyncScope(() => {\n    startChannel.publish({ metadata, path, type })\n\n    if (type === types.unary || type === types.client_stream) {\n      if (typeof callback === 'function') {\n        args[length - 1] = wrapCallback(requestResource, parentResource, callback)\n      } else {\n        args[length] = wrapCallback(requestResource, parentResource)\n      }\n    }\n\n    const call = method.apply(client, args)\n\n    wrapStream(call, requestResource, parentResource)\n\n    return call\n  })\n}\n\nfunction ensureMetadata (client, args, index) {\n  const grpc = getGrpc(client)\n\n  if (!client || !grpc) return args\n\n  const meta = args[index]\n  const normalized = []\n\n  for (let i = 0; i < index; i++) {\n    normalized.push(args[i])\n  }\n\n  if (!meta || !meta.constructor || meta.constructor.name !== 'Metadata') {\n    normalized.push(new grpc.Metadata())\n  }\n\n  if (meta) {\n    normalized.push(meta)\n  }\n\n  for (let i = index + 1; i < args.length; i++) {\n    normalized.push(args[i])\n  }\n\n  return normalized\n}\n\nfunction getType (definition) {\n  if (definition.requestStream) {\n    if (definition.responseStream) {\n      return types.bidi\n    }\n\n    return types.client_stream\n  }\n\n  if (definition.responseStream) {\n    return types.server_stream\n  }\n\n  return types.unary\n}\n\nfunction getGrpc (client) {\n  let proto = client\n\n  do {\n    const instance = instances.get(proto)\n    if (instance) return instance\n  } while ((proto = Object.getPrototypeOf(proto)))\n}\n\nfunction patch (grpc) {\n  const proto = grpc.Client.prototype\n\n  instances.set(proto, grpc)\n\n  shimmer.wrap(proto, 'makeBidiStreamRequest', createWrapMakeRequest(types.bidi))\n  shimmer.wrap(proto, 'makeClientStreamRequest', createWrapMakeRequest(types.clientStream))\n  shimmer.wrap(proto, 'makeServerStreamRequest', createWrapMakeRequest(types.serverStream))\n  shimmer.wrap(proto, 'makeUnaryRequest', createWrapMakeRequest(types.unary))\n\n  return grpc\n}\n\naddHook({ name: 'grpc', versions: ['>=1.24.3'] }, patch)\n\naddHook({ name: 'grpc', versions: ['>=1.24.3'], file: 'src/client.js' }, client => {\n  shimmer.wrap(client, 'makeClientConstructor', createWrapMakeClientConstructor())\n\n  return client\n})\n\naddHook({ name: '@grpc/grpc-js', versions: ['>=1.0.3'] }, patch)\n\naddHook({ name: '@grpc/grpc-js', versions: ['>=1.0.3'], file: 'build/src/make-client.js' }, client => {\n  shimmer.wrap(client, 'makeClientConstructor', createWrapMakeClientConstructor())\n  shimmer.wrap(client, 'loadPackageDefinition', createWrapLoadPackageDefinition())\n\n  return client\n})\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}