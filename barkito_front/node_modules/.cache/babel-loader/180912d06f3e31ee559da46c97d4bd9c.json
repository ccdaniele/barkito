{"ast":null,"code":"'use strict';\n\nconst {\n  randomFillSync\n} = require('crypto');\n\nconst UINT_MAX = 4294967296;\nconst data = new Uint8Array(8 * 8192);\nconst zeroId = new Uint8Array(8);\nconst map = Array.prototype.map;\n\nconst pad = byte => `${byte < 16 ? '0' : ''}${byte.toString(16)}`;\n\nlet batch = 0; // Internal representation of a trace or span ID.\n\nclass Identifier {\n  constructor(value) {\n    let radix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 16;\n    this._isUint64BE = true; // msgpack-lite compatibility\n\n    this._buffer = radix === 16 ? createBuffer(value) : fromString(value, radix);\n  }\n\n  toString() {\n    let radix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 16;\n    return radix === 16 ? toHexString(this._buffer) : toNumberString(this._buffer, radix);\n  }\n\n  toBuffer() {\n    return this._buffer;\n  } // msgpack-lite compatibility\n\n\n  toArray() {\n    if (this._buffer.length === 8) {\n      return this._buffer;\n    }\n\n    return this._buffer.slice(-8);\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n\n} // Create a buffer, using an optional hexadecimal value if provided.\n\n\nfunction createBuffer(value) {\n  if (value === '0') return zeroId;\n  if (!value) return pseudoRandom();\n  const size = Math.ceil(value.length / 16) * 16;\n  const bytes = size / 2;\n  const buffer = new Array(bytes);\n  value = value.padStart(size, '0');\n\n  for (let i = 0; i < bytes; i++) {\n    buffer[i] = parseInt(value.substring(i * 2, i * 2 + 2), 16);\n  }\n\n  return buffer;\n} // Convert a numerical string to a buffer using the specified radix.\n\n\nfunction fromString(str, raddix) {\n  const buffer = new Array(8);\n  const len = str.length;\n  let pos = 0;\n  let high = 0;\n  let low = 0;\n  if (str[0] === '-') pos++;\n  const sign = pos;\n\n  while (pos < len) {\n    const chr = parseInt(str[pos++], raddix);\n    if (!(chr >= 0)) break; // NaN\n\n    low = low * raddix + chr;\n    high = high * raddix + Math.floor(low / UINT_MAX);\n    low %= UINT_MAX;\n  }\n\n  if (sign) {\n    high = ~high;\n\n    if (low) {\n      low = UINT_MAX - low;\n    } else {\n      high++;\n    }\n  }\n\n  writeUInt32BE(buffer, high, 0);\n  writeUInt32BE(buffer, low, 4);\n  return buffer;\n} // Convert a buffer to a numerical string.\n\n\nfunction toNumberString(buffer, radix) {\n  let high = readInt32(buffer, buffer.length - 8);\n  let low = readInt32(buffer, buffer.length - 4);\n  let str = '';\n  radix = radix || 10;\n\n  while (1) {\n    const mod = high % radix * UINT_MAX + low;\n    high = Math.floor(high / radix);\n    low = Math.floor(mod / radix);\n    str = (mod % radix).toString(radix) + str;\n    if (!high && !low) break;\n  }\n\n  return str;\n} // Convert a buffer to a hexadecimal string.\n\n\nfunction toHexString(buffer) {\n  return map.call(buffer, pad).join('');\n} // Simple pseudo-random 64-bit ID generator.\n\n\nfunction pseudoRandom() {\n  if (batch === 0) {\n    randomFillSync(data);\n  }\n\n  batch = (batch + 1) % 8192;\n  const offset = batch * 8;\n  return [data[offset] & 0x7F, // only positive int64,\n  data[offset + 1], data[offset + 2], data[offset + 3], data[offset + 4], data[offset + 5], data[offset + 6], data[offset + 7]];\n} // Read a buffer to unsigned integer bytes.\n\n\nfunction readInt32(buffer, offset) {\n  return buffer[offset + 0] * 16777216 + (buffer[offset + 1] << 16) + (buffer[offset + 2] << 8) + buffer[offset + 3];\n} // Write unsigned integer bytes to a buffer.\n\n\nfunction writeUInt32BE(buffer, value, offset) {\n  buffer[3 + offset] = value & 255;\n  value = value >> 8;\n  buffer[2 + offset] = value & 255;\n  value = value >> 8;\n  buffer[1 + offset] = value & 255;\n  value = value >> 8;\n  buffer[0 + offset] = value & 255;\n}\n\nmodule.exports = (value, radix) => new Identifier(value, radix);","map":{"version":3,"names":["randomFillSync","require","UINT_MAX","data","Uint8Array","zeroId","map","Array","prototype","pad","byte","toString","batch","Identifier","constructor","value","radix","_isUint64BE","_buffer","createBuffer","fromString","toHexString","toNumberString","toBuffer","toArray","length","slice","toJSON","pseudoRandom","size","Math","ceil","bytes","buffer","padStart","i","parseInt","substring","str","raddix","len","pos","high","low","sign","chr","floor","writeUInt32BE","readInt32","mod","call","join","offset","module","exports"],"sources":["/Users/daniel.calderon/Projects/barkito/barkito_front/node_modules/dd-trace/packages/dd-trace/src/id.js"],"sourcesContent":["'use strict'\n\nconst { randomFillSync } = require('crypto')\n\nconst UINT_MAX = 4294967296\n\nconst data = new Uint8Array(8 * 8192)\nconst zeroId = new Uint8Array(8)\n\nconst map = Array.prototype.map\nconst pad = byte => `${byte < 16 ? '0' : ''}${byte.toString(16)}`\n\nlet batch = 0\n\n// Internal representation of a trace or span ID.\nclass Identifier {\n  constructor (value, radix = 16) {\n    this._isUint64BE = true // msgpack-lite compatibility\n    this._buffer = radix === 16\n      ? createBuffer(value)\n      : fromString(value, radix)\n  }\n\n  toString (radix = 16) {\n    return radix === 16\n      ? toHexString(this._buffer)\n      : toNumberString(this._buffer, radix)\n  }\n\n  toBuffer () {\n    return this._buffer\n  }\n\n  // msgpack-lite compatibility\n  toArray () {\n    if (this._buffer.length === 8) {\n      return this._buffer\n    }\n    return this._buffer.slice(-8)\n  }\n\n  toJSON () {\n    return this.toString()\n  }\n}\n\n// Create a buffer, using an optional hexadecimal value if provided.\nfunction createBuffer (value) {\n  if (value === '0') return zeroId\n  if (!value) return pseudoRandom()\n\n  const size = Math.ceil(value.length / 16) * 16\n  const bytes = size / 2\n  const buffer = new Array(bytes)\n\n  value = value.padStart(size, '0')\n\n  for (let i = 0; i < bytes; i++) {\n    buffer[i] = parseInt(value.substring(i * 2, i * 2 + 2), 16)\n  }\n\n  return buffer\n}\n\n// Convert a numerical string to a buffer using the specified radix.\nfunction fromString (str, raddix) {\n  const buffer = new Array(8)\n  const len = str.length\n\n  let pos = 0\n  let high = 0\n  let low = 0\n\n  if (str[0] === '-') pos++\n\n  const sign = pos\n\n  while (pos < len) {\n    const chr = parseInt(str[pos++], raddix)\n\n    if (!(chr >= 0)) break // NaN\n\n    low = low * raddix + chr\n    high = high * raddix + Math.floor(low / UINT_MAX)\n    low %= UINT_MAX\n  }\n\n  if (sign) {\n    high = ~high\n\n    if (low) {\n      low = UINT_MAX - low\n    } else {\n      high++\n    }\n  }\n\n  writeUInt32BE(buffer, high, 0)\n  writeUInt32BE(buffer, low, 4)\n\n  return buffer\n}\n\n// Convert a buffer to a numerical string.\nfunction toNumberString (buffer, radix) {\n  let high = readInt32(buffer, buffer.length - 8)\n  let low = readInt32(buffer, buffer.length - 4)\n  let str = ''\n\n  radix = radix || 10\n\n  while (1) {\n    const mod = (high % radix) * UINT_MAX + low\n\n    high = Math.floor(high / radix)\n    low = Math.floor(mod / radix)\n    str = (mod % radix).toString(radix) + str\n\n    if (!high && !low) break\n  }\n\n  return str\n}\n\n// Convert a buffer to a hexadecimal string.\nfunction toHexString (buffer) {\n  return map.call(buffer, pad).join('')\n}\n\n// Simple pseudo-random 64-bit ID generator.\nfunction pseudoRandom () {\n  if (batch === 0) {\n    randomFillSync(data)\n  }\n\n  batch = (batch + 1) % 8192\n\n  const offset = batch * 8\n\n  return [\n    data[offset] & 0x7F, // only positive int64,\n    data[offset + 1],\n    data[offset + 2],\n    data[offset + 3],\n    data[offset + 4],\n    data[offset + 5],\n    data[offset + 6],\n    data[offset + 7]\n  ]\n}\n\n// Read a buffer to unsigned integer bytes.\nfunction readInt32 (buffer, offset) {\n  return (buffer[offset + 0] * 16777216) +\n    (buffer[offset + 1] << 16) +\n    (buffer[offset + 2] << 8) +\n    buffer[offset + 3]\n}\n\n// Write unsigned integer bytes to a buffer.\nfunction writeUInt32BE (buffer, value, offset) {\n  buffer[3 + offset] = value & 255\n  value = value >> 8\n  buffer[2 + offset] = value & 255\n  value = value >> 8\n  buffer[1 + offset] = value & 255\n  value = value >> 8\n  buffer[0 + offset] = value & 255\n}\n\nmodule.exports = (value, radix) => new Identifier(value, radix)\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}