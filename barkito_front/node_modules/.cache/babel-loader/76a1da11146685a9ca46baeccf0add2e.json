{"ast":null,"code":"const {\n  MANUAL_KEEP\n} = require('../../../../../ext/tags');\n\nconst LRU = require('lru-cache');\n\nconst VULNERABILITIES_KEY = 'vulnerabilities';\nconst IAST_JSON_TAG_KEY = '_dd.iast.json';\nconst VULNERABILITY_HASHES_MAX_SIZE = 1000;\nconst VULNERABILITY_HASHES = new LRU({\n  max: VULNERABILITY_HASHES_MAX_SIZE\n});\n\nfunction createVulnerability(type, evidence, spanId, location) {\n  if (type && evidence && spanId) {\n    return {\n      type,\n      evidence,\n      location: {\n        spanId,\n        ...location\n      },\n      hash: createHash(type, location)\n    };\n  }\n\n  return null;\n}\n\nfunction createHash(type, location) {\n  let hashSource;\n\n  if (location) {\n    hashSource = `${type}:${location.path}:${location.line}`;\n  } else {\n    hashSource = type;\n  }\n\n  let hash = 0;\n  let offset = 0;\n  const size = hashSource.length;\n\n  for (let i = 0; i < size; i++) {\n    hash = (hash << 5) - hash + hashSource.charCodeAt(offset++);\n  }\n\n  return hash;\n}\n\nfunction addVulnerability(iastContext, vulnerability) {\n  if (iastContext && vulnerability && vulnerability.evidence && vulnerability.type && vulnerability.location && vulnerability.location.spanId) {\n    iastContext[VULNERABILITIES_KEY] = iastContext[VULNERABILITIES_KEY] || [];\n    iastContext[VULNERABILITIES_KEY].push(vulnerability);\n  }\n}\n\nfunction isValidVulnerability(vulnerability) {\n  return vulnerability && vulnerability.type && vulnerability.evidence && vulnerability.evidence.value && vulnerability.location && vulnerability.location.spanId;\n}\n\nfunction jsonVulnerabilityFromVulnerability(vulnerability) {\n  const jsonVulnerability = {\n    type: vulnerability.type,\n    hash: vulnerability.hash,\n    evidence: {\n      value: vulnerability.evidence.value\n    },\n    location: {\n      spanId: vulnerability.location.spanId\n    }\n  };\n\n  if (vulnerability.location.path) {\n    jsonVulnerability.location.path = vulnerability.location.path;\n  }\n\n  if (vulnerability.location.line) {\n    jsonVulnerability.location.line = vulnerability.location.line;\n  }\n\n  return jsonVulnerability;\n}\n\nfunction sendVulnerabilities(iastContext) {\n  if (iastContext && iastContext.rootSpan && iastContext[VULNERABILITIES_KEY] && iastContext[VULNERABILITIES_KEY].length && iastContext.rootSpan.addTags) {\n    const span = iastContext.rootSpan;\n    const allVulnerabilities = iastContext[VULNERABILITIES_KEY]; // TODO support sources and ranges\n\n    const jsonToSend = {\n      vulnerabilities: []\n    };\n    deduplicateVulnerabilities(allVulnerabilities).forEach(vulnerability => {\n      if (isValidVulnerability(vulnerability)) {\n        jsonToSend.vulnerabilities.push(jsonVulnerabilityFromVulnerability(vulnerability));\n      }\n    });\n\n    if (jsonToSend.vulnerabilities.length > 0) {\n      const tags = {}; // TODO: Store this outside of the span and set the tag in the exporter.\n\n      tags[IAST_JSON_TAG_KEY] = JSON.stringify(jsonToSend);\n      tags[MANUAL_KEEP] = 'true';\n      span.addTags(tags);\n    }\n  }\n\n  return IAST_JSON_TAG_KEY;\n}\n\nfunction clearCache() {\n  // only for test purposes\n  VULNERABILITY_HASHES.clear();\n}\n\nfunction deduplicateVulnerabilities(vulnerabilities) {\n  const deduplicated = vulnerabilities.filter(vulnerability => {\n    const key = `${vulnerability.type}${vulnerability.hash}`;\n\n    if (!VULNERABILITY_HASHES.get(key)) {\n      VULNERABILITY_HASHES.set(key, true);\n      return true;\n    }\n\n    return false;\n  });\n  return deduplicated;\n}\n\nmodule.exports = {\n  createVulnerability,\n  addVulnerability,\n  sendVulnerabilities,\n  clearCache\n};","map":{"version":3,"names":["MANUAL_KEEP","require","LRU","VULNERABILITIES_KEY","IAST_JSON_TAG_KEY","VULNERABILITY_HASHES_MAX_SIZE","VULNERABILITY_HASHES","max","createVulnerability","type","evidence","spanId","location","hash","createHash","hashSource","path","line","offset","size","length","i","charCodeAt","addVulnerability","iastContext","vulnerability","push","isValidVulnerability","value","jsonVulnerabilityFromVulnerability","jsonVulnerability","sendVulnerabilities","rootSpan","addTags","span","allVulnerabilities","jsonToSend","vulnerabilities","deduplicateVulnerabilities","forEach","tags","JSON","stringify","clearCache","clear","deduplicated","filter","key","get","set","module","exports"],"sources":["/Users/daniel.calderon/Projects/barkito/barkito_front/node_modules/dd-trace/packages/dd-trace/src/appsec/iast/vulnerability-reporter.js"],"sourcesContent":["const { MANUAL_KEEP } = require('../../../../../ext/tags')\nconst LRU = require('lru-cache')\nconst VULNERABILITIES_KEY = 'vulnerabilities'\nconst IAST_JSON_TAG_KEY = '_dd.iast.json'\nconst VULNERABILITY_HASHES_MAX_SIZE = 1000\nconst VULNERABILITY_HASHES = new LRU({ max: VULNERABILITY_HASHES_MAX_SIZE })\n\nfunction createVulnerability (type, evidence, spanId, location) {\n  if (type && evidence && spanId) {\n    return {\n      type,\n      evidence,\n      location: {\n        spanId,\n        ...location\n      },\n      hash: createHash(type, location)\n    }\n  }\n  return null\n}\n\nfunction createHash (type, location) {\n  let hashSource\n  if (location) {\n    hashSource = `${type}:${location.path}:${location.line}`\n  } else {\n    hashSource = type\n  }\n  let hash = 0\n  let offset = 0\n  const size = hashSource.length\n  for (let i = 0; i < size; i++) {\n    hash = ((hash << 5) - hash) + hashSource.charCodeAt(offset++)\n  }\n  return hash\n}\n\nfunction addVulnerability (iastContext, vulnerability) {\n  if (iastContext && vulnerability && vulnerability.evidence && vulnerability.type &&\n    vulnerability.location && vulnerability.location.spanId) {\n    iastContext[VULNERABILITIES_KEY] = iastContext[VULNERABILITIES_KEY] || []\n    iastContext[VULNERABILITIES_KEY].push(vulnerability)\n  }\n}\n\nfunction isValidVulnerability (vulnerability) {\n  return vulnerability && vulnerability.type &&\n    vulnerability.evidence && vulnerability.evidence.value &&\n    vulnerability.location && vulnerability.location.spanId\n}\n\nfunction jsonVulnerabilityFromVulnerability (vulnerability) {\n  const jsonVulnerability = {\n    type: vulnerability.type,\n    hash: vulnerability.hash,\n    evidence: {\n      value: vulnerability.evidence.value\n    },\n    location: {\n      spanId: vulnerability.location.spanId\n    }\n  }\n  if (vulnerability.location.path) {\n    jsonVulnerability.location.path = vulnerability.location.path\n  }\n  if (vulnerability.location.line) {\n    jsonVulnerability.location.line = vulnerability.location.line\n  }\n  return jsonVulnerability\n}\n\nfunction sendVulnerabilities (iastContext) {\n  if (iastContext && iastContext.rootSpan && iastContext[VULNERABILITIES_KEY] &&\n    iastContext[VULNERABILITIES_KEY].length && iastContext.rootSpan.addTags) {\n    const span = iastContext.rootSpan\n    const allVulnerabilities = iastContext[VULNERABILITIES_KEY]\n    // TODO support sources and ranges\n    const jsonToSend = {\n      vulnerabilities: []\n    }\n\n    deduplicateVulnerabilities(allVulnerabilities).forEach((vulnerability) => {\n      if (isValidVulnerability(vulnerability)) {\n        jsonToSend.vulnerabilities.push(jsonVulnerabilityFromVulnerability(vulnerability))\n      }\n    })\n\n    if (jsonToSend.vulnerabilities.length > 0) {\n      const tags = {}\n      // TODO: Store this outside of the span and set the tag in the exporter.\n      tags[IAST_JSON_TAG_KEY] = JSON.stringify(jsonToSend)\n      tags[MANUAL_KEEP] = 'true'\n      span.addTags(tags)\n    }\n  }\n  return IAST_JSON_TAG_KEY\n}\n\nfunction clearCache () { // only for test purposes\n  VULNERABILITY_HASHES.clear()\n}\n\nfunction deduplicateVulnerabilities (vulnerabilities) {\n  const deduplicated = vulnerabilities.filter((vulnerability) => {\n    const key = `${vulnerability.type}${vulnerability.hash}`\n    if (!VULNERABILITY_HASHES.get(key)) {\n      VULNERABILITY_HASHES.set(key, true)\n      return true\n    }\n    return false\n  })\n  return deduplicated\n}\n\nmodule.exports = {\n  createVulnerability,\n  addVulnerability,\n  sendVulnerabilities,\n  clearCache\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}