{"ast":null,"code":"'use strict';\n\nconst {\n  channel,\n  addHook,\n  AsyncResource\n} = require('./helpers/instrument');\n\nconst shimmer = require('../../datadog-shimmer');\n\nconst startICPCh = channel('apm:net:ipc:start');\nconst finishICPCh = channel('apm:net:ipc:finish');\nconst errorICPCh = channel('apm:net:ipc:error');\nconst startTCPCh = channel('apm:net:tcp:start');\nconst finishTCPCh = channel('apm:net:tcp:finish');\nconst errorTCPCh = channel('apm:net:tcp:error');\nconst connectionCh = channel(`apm:net:tcp:connection`);\naddHook({\n  name: 'net'\n}, net => {\n  require('dns');\n\n  shimmer.wrap(net.Socket.prototype, 'connect', connect => function () {\n    if (!startICPCh.hasSubscribers || !startTCPCh.hasSubscribers) {\n      return connect.apply(this, arguments);\n    }\n\n    const options = getOptions(arguments);\n    const lastIndex = arguments.length - 1;\n    const callback = arguments[lastIndex];\n    if (!options) return connect.apply(this, arguments);\n    const callbackResource = new AsyncResource('bound-anonymous-fn');\n    const asyncResource = new AsyncResource('bound-anonymous-fn');\n\n    if (typeof callback === 'function') {\n      arguments[lastIndex] = callbackResource.bind(callback);\n    }\n\n    const protocol = options.path ? 'ipc' : 'tcp';\n    return asyncResource.runInAsyncScope(() => {\n      if (protocol === 'ipc') {\n        startICPCh.publish({\n          options\n        });\n        setupListeners(this, 'ipc', asyncResource);\n      } else {\n        startTCPCh.publish({\n          options\n        });\n        setupListeners(this, 'tcp', asyncResource);\n      }\n\n      const emit = this.emit;\n\n      this.emit = function (eventName) {\n        switch (eventName) {\n          case 'ready':\n          case 'connect':\n            return callbackResource.runInAsyncScope(() => {\n              return emit.apply(this, arguments);\n            });\n\n          default:\n            return emit.apply(this, arguments);\n        }\n      };\n\n      try {\n        return connect.apply(this, arguments);\n      } catch (err) {\n        protocol === 'ipc' ? errorICPCh.publish(err) : errorTCPCh.publish(err);\n        throw err;\n      }\n    });\n  });\n  return net;\n});\n\nfunction getOptions(args) {\n  if (!args[0]) return;\n\n  switch (typeof args[0]) {\n    case 'object':\n      if (Array.isArray(args[0])) return getOptions(args[0]);\n      return args[0];\n\n    case 'string':\n      if (isNaN(parseFloat(args[0]))) {\n        return {\n          path: args[0]\n        };\n      }\n\n    case 'number':\n      // eslint-disable-line no-fallthrough\n      return {\n        port: args[0],\n        host: typeof args[1] === 'string' ? args[1] : 'localhost'\n      };\n  }\n}\n\nfunction setupListeners(socket, protocol, asyncResource) {\n  const events = ['connect', 'error', 'close', 'timeout'];\n  const wrapListener = asyncResource.bind(function (error) {\n    if (error) {\n      protocol === 'ipc' ? errorICPCh.publish(error) : errorTCPCh.publish(error);\n    }\n\n    protocol === 'ipc' ? finishICPCh.publish(undefined) : finishTCPCh.publish(undefined);\n  });\n  const localListener = asyncResource.bind(function () {\n    connectionCh.publish({\n      socket\n    });\n  });\n\n  const cleanupListener = function () {\n    socket.removeListener('connect', localListener);\n    events.forEach(event => {\n      socket.removeListener(event, wrapListener);\n      socket.removeListener(event, cleanupListener);\n    });\n  };\n\n  if (protocol === 'tcp') {\n    socket.once('connect', localListener);\n  }\n\n  events.forEach(event => {\n    socket.once(event, wrapListener);\n    socket.once(event, cleanupListener);\n  });\n}","map":{"version":3,"names":["channel","addHook","AsyncResource","require","shimmer","startICPCh","finishICPCh","errorICPCh","startTCPCh","finishTCPCh","errorTCPCh","connectionCh","name","net","wrap","Socket","prototype","connect","hasSubscribers","apply","arguments","options","getOptions","lastIndex","length","callback","callbackResource","asyncResource","bind","protocol","path","runInAsyncScope","publish","setupListeners","emit","eventName","err","args","Array","isArray","isNaN","parseFloat","port","host","socket","events","wrapListener","error","undefined","localListener","cleanupListener","removeListener","forEach","event","once"],"sources":["/Users/daniel.calderon/Projects/barkito/barkito_front/node_modules/dd-trace/packages/datadog-instrumentations/src/net.js"],"sourcesContent":["'use strict'\n\nconst {\n  channel,\n  addHook,\n  AsyncResource\n} = require('./helpers/instrument')\nconst shimmer = require('../../datadog-shimmer')\n\nconst startICPCh = channel('apm:net:ipc:start')\nconst finishICPCh = channel('apm:net:ipc:finish')\nconst errorICPCh = channel('apm:net:ipc:error')\n\nconst startTCPCh = channel('apm:net:tcp:start')\nconst finishTCPCh = channel('apm:net:tcp:finish')\nconst errorTCPCh = channel('apm:net:tcp:error')\n\nconst connectionCh = channel(`apm:net:tcp:connection`)\n\naddHook({ name: 'net' }, net => {\n  require('dns')\n\n  shimmer.wrap(net.Socket.prototype, 'connect', connect => function () {\n    if (!startICPCh.hasSubscribers || !startTCPCh.hasSubscribers) {\n      return connect.apply(this, arguments)\n    }\n\n    const options = getOptions(arguments)\n    const lastIndex = arguments.length - 1\n    const callback = arguments[lastIndex]\n\n    if (!options) return connect.apply(this, arguments)\n\n    const callbackResource = new AsyncResource('bound-anonymous-fn')\n    const asyncResource = new AsyncResource('bound-anonymous-fn')\n\n    if (typeof callback === 'function') {\n      arguments[lastIndex] = callbackResource.bind(callback)\n    }\n\n    const protocol = options.path ? 'ipc' : 'tcp'\n\n    return asyncResource.runInAsyncScope(() => {\n      if (protocol === 'ipc') {\n        startICPCh.publish({ options })\n        setupListeners(this, 'ipc', asyncResource)\n      } else {\n        startTCPCh.publish({ options })\n        setupListeners(this, 'tcp', asyncResource)\n      }\n\n      const emit = this.emit\n      this.emit = function (eventName) {\n        switch (eventName) {\n          case 'ready':\n          case 'connect':\n            return callbackResource.runInAsyncScope(() => {\n              return emit.apply(this, arguments)\n            })\n          default:\n            return emit.apply(this, arguments)\n        }\n      }\n\n      try {\n        return connect.apply(this, arguments)\n      } catch (err) {\n        protocol === 'ipc' ? errorICPCh.publish(err) : errorTCPCh.publish(err)\n\n        throw err\n      }\n    })\n  })\n\n  return net\n})\n\nfunction getOptions (args) {\n  if (!args[0]) return\n\n  switch (typeof args[0]) {\n    case 'object':\n      if (Array.isArray(args[0])) return getOptions(args[0])\n      return args[0]\n    case 'string':\n      if (isNaN(parseFloat(args[0]))) {\n        return {\n          path: args[0]\n        }\n      }\n    case 'number': // eslint-disable-line no-fallthrough\n      return {\n        port: args[0],\n        host: typeof args[1] === 'string' ? args[1] : 'localhost'\n      }\n  }\n}\n\nfunction setupListeners (socket, protocol, asyncResource) {\n  const events = ['connect', 'error', 'close', 'timeout']\n\n  const wrapListener = asyncResource.bind(function (error) {\n    if (error) {\n      protocol === 'ipc' ? errorICPCh.publish(error) : errorTCPCh.publish(error)\n    }\n    protocol === 'ipc' ? finishICPCh.publish(undefined) : finishTCPCh.publish(undefined)\n  })\n\n  const localListener = asyncResource.bind(function () {\n    connectionCh.publish({ socket })\n  })\n\n  const cleanupListener = function () {\n    socket.removeListener('connect', localListener)\n    events.forEach(event => {\n      socket.removeListener(event, wrapListener)\n      socket.removeListener(event, cleanupListener)\n    })\n  }\n\n  if (protocol === 'tcp') {\n    socket.once('connect', localListener)\n  }\n\n  events.forEach(event => {\n    socket.once(event, wrapListener)\n    socket.once(event, cleanupListener)\n  })\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}