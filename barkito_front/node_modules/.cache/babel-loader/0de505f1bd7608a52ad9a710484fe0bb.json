{"ast":null,"code":"'use strict'; // The `fs` plugin is an old style plugin that has not been updated for the new\n// plugin system and was hacked in for backward compatibility with 2.x.\n\nconst {\n  storage\n} = require('../../datadog-core');\n\nconst {\n  channel\n} = require('../../datadog-instrumentations/src/helpers/instrument');\n\nconst shimmer = require('../../datadog-shimmer');\n\nconst Plugin = require('../../dd-trace/src/plugins/plugin');\n\nlet kDirReadPromisified;\nlet kDirClosePromisified;\nlet kHandle;\nlet fsConfig;\nlet fsInstance;\nconst ddFhSym = Symbol('ddFileHandle');\nconst tagMakers = {\n  open: createOpenTags,\n  close: createCloseTags,\n  readFile: createReadFileTags,\n  writeFile: createWriteFileTags,\n  appendFile: createAppendFileTags,\n  access: createPathTags,\n  copyFile: createCopyFileTags,\n  stat: createPathTags,\n  lstat: createPathTags,\n  fstat: createFDTags,\n  readdir: createPathTags,\n  opendir: createPathTags,\n  read: createFDTags,\n  write: createFDTags,\n  writev: createFDTags,\n  chmod: createChmodTags,\n  lchmod: createChmodTags,\n  fchmod: createFchmodTags,\n  chown: createChownTags,\n  lchown: createChownTags,\n  fchown: createFchownTags,\n  realpath: createPathTags,\n  readlink: createPathTags,\n  unlink: createPathTags,\n  symlink: createCopyFileTags,\n  link: createCopyFileTags,\n  rmdir: createPathTags,\n  rename: createCopyFileTags,\n  fsync: createFDTags,\n  fdatasync: createFDTags,\n  mkdir: createPathTags,\n  truncate: createPathTags,\n  ftruncate: createFDTags,\n  utimes: createPathTags,\n  futimes: createFDTags,\n  mkdtemp: createPathTags\n};\nconst promisifiable = ['read', 'readv', 'write', 'writev'];\nconst orphanable = false;\n\nfunction createWrapCreateReadStream(config, tracer) {\n  return function wrapCreateReadStream(createReadStream) {\n    return function createReadStreamWithTrace(path, options) {\n      if (!hasParent()) {\n        return createReadStream.apply(this, arguments);\n      }\n\n      const tags = makeFSFlagTags('ReadStream', path, options, 'r', config, tracer);\n      return tracer.trace('fs.operation', {\n        tags,\n        orphanable\n      }, (span, done) => {\n        const stream = createReadStream.apply(this, arguments);\n        stream.once('close', done);\n        stream.once('end', done);\n        stream.once('error', done);\n        return stream;\n      });\n    };\n  };\n}\n\nfunction createWrapCreateWriteStream(config, tracer) {\n  return function wrapCreateWriteStream(createWriteStream) {\n    return function createWriteStreamWithTrace(path, options) {\n      const tags = makeFSFlagTags('WriteStream', path, options, 'w', config, tracer);\n      return tracer.trace('fs.operation', {\n        tags,\n        orphanable\n      }, (span, done) => {\n        const stream = createWriteStream.apply(this, arguments);\n        stream.once('close', done);\n        stream.once('finish', done);\n        stream.once('error', done);\n        return stream;\n      });\n    };\n  };\n}\n\nfunction createWrapExists(config, tracer) {\n  return function wrapExists(exists) {\n    const existsWithTrace = function existsWithTrace(path, cb) {\n      if (typeof cb !== 'function') {\n        return exists.apply(this, arguments);\n      }\n\n      const tags = makeFSTags('exists', path, null, config, tracer);\n      return tracer.trace('fs.operation', {\n        tags,\n        orphanable\n      }, (span, done) => {\n        arguments[1] = function (result) {\n          done();\n          cb.apply(this, arguments);\n        };\n\n        return exists.apply(this, arguments);\n      });\n    };\n\n    copySymbols(exists, existsWithTrace);\n    return existsWithTrace;\n  };\n}\n\nfunction createWrapDirRead(config, tracer, sync) {\n  const name = sync ? 'dir.readSync' : 'dir.read';\n  return function wrapDirRead(read) {\n    function options() {\n      const tags = makeFSTags(name, this.path, null, config, tracer);\n      return {\n        tags,\n        orphanable\n      };\n    }\n\n    return tracer.wrap('fs.operation', options, read, true);\n  };\n}\n\nfunction createWrapDirClose(config, tracer, sync) {\n  const name = sync ? 'dir.closeSync' : 'dir.close';\n  return function wrapDirClose(close) {\n    function options() {\n      const tags = makeFSTags(name, this.path, null, config, tracer);\n      return {\n        tags,\n        orphanable\n      };\n    }\n\n    return tracer.wrap('fs.operation', options, close, true);\n  };\n}\n\nfunction createWrapDirAsyncIterator(config, tracer, instrumenter) {\n  return function wrapDirAsyncIterator(asyncIterator) {\n    return function asyncIteratorWithTrace() {\n      if (!kDirReadPromisified) {\n        const keys = Reflect.ownKeys(this);\n\n        for (const key of keys) {\n          if (kDirReadPromisified && kDirClosePromisified) break;\n          if (typeof key !== 'symbol') continue;\n\n          if (!kDirReadPromisified && getSymbolName(key).includes('kDirReadPromisified')) {\n            kDirReadPromisified = key;\n          }\n\n          if (!kDirClosePromisified && getSymbolName(key).includes('kDirClosePromisified')) {\n            kDirClosePromisified = key;\n          }\n        }\n      }\n\n      shimmer.wrap(this, kDirReadPromisified, createWrapDirRead(config, tracer));\n      shimmer.wrap(this, kDirClosePromisified, createWrapKDirClose(config, tracer, instrumenter));\n      return asyncIterator.apply(this, arguments);\n    };\n  };\n}\n\nfunction createWrapKDirClose(config, tracer, instrumenter) {\n  return function wrapKDirClose(kDirClose) {\n    return function kDirCloseWithTrace() {\n      const tags = makeFSTags('dir.close', this.path, null, config, tracer);\n      return tracer.trace('fs.operation', {\n        tags,\n        orphanable\n      }, span => {\n        const p = kDirClose.apply(this, arguments);\n\n        const unwrapBoth = () => {\n          shimmer.unwrap(this, kDirReadPromisified);\n          shimmer.unwrap(this, kDirClosePromisified);\n        };\n\n        p.then(unwrapBoth, unwrapBoth);\n        return p;\n      });\n    };\n  };\n}\n\nfunction createOpenTags(resourceName, config, tracer) {\n  return function openTags(path, flag, mode) {\n    if (!flag || typeof flag === 'function') {\n      flag = null;\n    }\n\n    return makeFSFlagTags(resourceName, path, {\n      flag\n    }, 'r', config, tracer);\n  };\n}\n\nfunction createCloseTags(resourceName, config, tracer) {\n  return function closeTags(fd) {\n    if (typeof fd === 'undefined' && this && this[ddFhSym]) {\n      fd = this[ddFhSym].fd;\n    }\n\n    if (typeof fd !== 'number' || !Number.isInteger(fd)) {\n      return;\n    }\n\n    return makeFSTags(resourceName, fd, null, config, tracer);\n  };\n}\n\nfunction createReadFileTags(resourceName, config, tracer) {\n  return function readFileTags(path, options) {\n    return makeFSFlagTags(resourceName, path, options, 'r', config, tracer);\n  };\n}\n\nfunction createWriteFileTags(resourceName, config, tracer) {\n  return function writeFileTags(path, data, options) {\n    return makeFSFlagTags(resourceName, path, options, 'w', config, tracer);\n  };\n}\n\nfunction createAppendFileTags(resourceName, config, tracer) {\n  return function appendFileTags(path, data, options) {\n    return makeFSFlagTags(resourceName, path, options, 'a', config, tracer);\n  };\n}\n\nfunction createCopyFileTags(resourceName, config, tracer) {\n  return function copyFileTags(src, dest, flag) {\n    return makeFSTags(resourceName, {\n      src,\n      dest\n    }, null, config, tracer);\n  };\n}\n\nfunction createChmodTags(resourceName, config, tracer) {\n  return function chmodTags(fd, mode) {\n    const tags = makeFSTags(resourceName, fd, null, config, tracer);\n    tags['file.mode'] = mode.toString(8);\n    return tags;\n  };\n}\n\nfunction createFchmodTags(resourceName, config, tracer) {\n  return function fchmodTags(fd, mode) {\n    if (typeof this === 'object' && this !== null && this.fd) {\n      mode = fd;\n      fd = this.fd;\n    }\n\n    const tags = makeFSTags(resourceName, fd, null, config, tracer);\n\n    if (mode) {\n      tags['file.mode'] = mode.toString(8);\n    }\n\n    return tags;\n  };\n}\n\nfunction createPathTags(resourceName, config, tracer) {\n  return function pathTags(path) {\n    return makeFSTags(resourceName, path, null, config, tracer);\n  };\n}\n\nfunction createFDTags(resourceName, config, tracer) {\n  return function fdTags(fd) {\n    if (typeof this === 'object' && this !== null && this.fd) {\n      fd = this.fd;\n    }\n\n    return makeFSTags(resourceName, fd, null, config, tracer);\n  };\n}\n\nfunction createChownTags(resourceName, config, tracer) {\n  return function chownTags(fd, uid, gid) {\n    const tags = makeFSTags(resourceName, fd, null, config, tracer);\n\n    if (typeof uid === 'number') {\n      tags['file.uid'] = uid.toString();\n    }\n\n    if (typeof gid === 'number') {\n      tags['file.gid'] = gid.toString();\n    }\n\n    return tags;\n  };\n}\n\nfunction createFchownTags(resourceName, config, tracer) {\n  return function fchownTags(fd, uid, gid) {\n    if (typeof this === 'object' && this !== null && this.fd) {\n      gid = uid;\n      uid = fd;\n      fd = this.fd;\n    }\n\n    const tags = makeFSTags(resourceName, fd, null, config, tracer);\n\n    if (typeof uid === 'number') {\n      tags['file.uid'] = uid.toString();\n    }\n\n    if (typeof gid === 'number') {\n      tags['file.gid'] = gid.toString();\n    }\n\n    return tags;\n  };\n}\n\nfunction getSymbolName(sym) {\n  return sym.description || sym.toString();\n}\n\nfunction hasParent() {\n  const store = storage.getStore();\n  return store && store.span && !store.noop;\n}\n\nfunction createWrapCb(tracer, config, name, tagMaker) {\n  const makeTags = tagMaker(name, config, tracer);\n  return function wrapFunction(fn) {\n    return tracer.wrap('fs.operation', function () {\n      if (typeof arguments[arguments.length - 1] !== 'function') {\n        return;\n      }\n\n      const tags = makeTags.apply(this, arguments);\n      return tags ? {\n        tags,\n        orphanable\n      } : {\n        orphanable\n      };\n    }, fn, true);\n  };\n}\n\nfunction createWrap(tracer, config, name, tagMaker) {\n  const makeTags = tagMaker(name, config, tracer);\n  return function wrapSyncFunction(fn) {\n    return tracer.wrap('fs.operation', function () {\n      const tags = makeTags.apply(this, arguments);\n      return tags ? {\n        tags,\n        orphanable\n      } : {\n        orphanable\n      };\n    }, fn, true);\n  };\n}\n\nfunction makeFSFlagTags(resourceName, path, options, defaultFlag, config, tracer) {\n  const tags = makeFSTags(resourceName, path, options, config, tracer);\n\n  if (tags) {\n    let flag = defaultFlag;\n\n    if (typeof options === 'object' && options !== null) {\n      if (options.flag) {\n        flag = options.flag;\n      } else if (options.flags) {\n        flag = options.flags;\n      }\n    }\n\n    tags['file.flag'] = flag;\n    return tags;\n  }\n}\n\nfunction makeFSTags(resourceName, path, options, config, tracer) {\n  path = options && typeof options === 'object' && 'fd' in options ? options.fd : path;\n  const tags = {\n    'component': 'fs',\n    'span.kind': 'internal',\n    'resource.name': resourceName,\n    'service.name': fsConfig.service || tracer._service\n  };\n\n  switch (typeof path) {\n    case 'object':\n      {\n        if (path === null) return tags;\n        const src = 'src' in path ? path.src : null;\n        const dest = 'dest' in path ? path.dest : null;\n\n        if (src || dest) {\n          tags['file.src'] = src;\n          tags['file.dest'] = dest;\n        } else {\n          tags['file.path'] = path;\n        }\n\n        break;\n      }\n\n    case 'string':\n      {\n        tags['file.path'] = path;\n        break;\n      }\n\n    case 'number':\n      {\n        tags['file.descriptor'] = path.toString();\n        break;\n      }\n  }\n\n  return tags;\n}\n\nfunction copySymbols(from, to) {\n  const props = Object.getOwnPropertyDescriptors(from);\n  const keys = Reflect.ownKeys(props);\n\n  for (const key of keys) {\n    if (typeof key !== 'symbol' || to.hasOwnProperty(key)) continue;\n    Object.defineProperty(to, key, props[key]);\n  }\n}\n\nfunction getFileHandlePrototype(fs) {\n  return fs.promises.open(__filename, 'r').then(fh => {\n    if (!kHandle) {\n      kHandle = Reflect.ownKeys(fh).find(key => typeof key === 'symbol' && key.toString().includes('kHandle'));\n    }\n\n    fh.close();\n    return Object.getPrototypeOf(fh);\n  });\n}\n\nfunction patchClassicFunctions(fs, tracer, config) {\n  for (const name in fs) {\n    if (!fs[name]) continue;\n    const tagMakerName = name.endsWith('Sync') ? name.substr(0, name.length - 4) : name;\n    const original = fs[name];\n\n    if (tagMakerName in tagMakers) {\n      const tagMaker = tagMakers[tagMakerName];\n\n      if (name.endsWith('Sync')) {\n        shimmer.wrap(fs, name, createWrap(tracer, config, name, tagMaker));\n      } else {\n        shimmer.wrap(fs, name, createWrapCb(tracer, config, name, tagMaker));\n      }\n\n      if (name in promisifiable) {\n        copySymbols(original, fs[name]);\n      }\n    }\n  }\n}\n\nfunction patchFileHandle(fs, tracer, config) {\n  getFileHandlePrototype(fs).then(fileHandlePrototype => {\n    for (const name of Reflect.ownKeys(fileHandlePrototype)) {\n      if (typeof name !== 'string' || name === 'constructor' || name === 'fd' || name === 'getAsyncId') {\n        continue;\n      }\n\n      let tagMaker;\n      const fName = 'f' + name;\n\n      if (fName in tagMakers) {\n        tagMaker = tagMakers[fName];\n      } else {\n        tagMaker = createFDTags;\n      }\n\n      const desc = Reflect.getOwnPropertyDescriptor(fileHandlePrototype, kHandle);\n\n      if (!desc || !desc.get) {\n        Reflect.defineProperty(fileHandlePrototype, kHandle, {\n          get() {\n            return this[ddFhSym];\n          },\n\n          set(h) {\n            this[ddFhSym] = h;\n            shimmer.wrap(this, 'close', createWrap(tracer, config, 'filehandle.close', tagMakers.close));\n          },\n\n          configurable: true\n        });\n      }\n\n      shimmer.wrap(fileHandlePrototype, name, createWrap(tracer, config, 'filehandle.' + name, tagMaker));\n    }\n  });\n}\n\nfunction patchPromiseFunctions(fs, tracer, config) {\n  for (const name in fs.promises) {\n    if (name in tagMakers) {\n      const tagMaker = tagMakers[name];\n      shimmer.wrap(fs.promises, name, createWrap(tracer, config, 'promises.' + name, tagMaker));\n    }\n  }\n}\n\nfunction patchDirFunctions(fs, tracer, config) {\n  shimmer.wrap(fs.Dir.prototype, 'close', createWrapDirClose(config, tracer));\n  shimmer.wrap(fs.Dir.prototype, 'closeSync', createWrapDirClose(config, tracer, true));\n  shimmer.wrap(fs.Dir.prototype, 'read', createWrapDirRead(config, tracer));\n  shimmer.wrap(fs.Dir.prototype, 'readSync', createWrapDirRead(config, tracer, true));\n  shimmer.wrap(fs.Dir.prototype, Symbol.asyncIterator, createWrapDirAsyncIterator(config, tracer, this));\n}\n\nfunction unpatchClassicFunctions(fs) {\n  for (const name in fs) {\n    if (!fs[name]) continue;\n    const tagMakerName = name.endsWith('Sync') ? name.substr(0, name.length - 4) : name;\n\n    if (tagMakerName in tagMakers) {\n      shimmer.unwrap(fs, name);\n    }\n  }\n}\n\nfunction unpatchFileHandle(fs) {\n  getFileHandlePrototype(fs).then(fileHandlePrototype => {\n    for (const name of Reflect.ownKeys(fileHandlePrototype)) {\n      if (typeof name !== 'string' || name === 'constructor' || name === 'fd' || name === 'getAsyncId') {\n        continue;\n      }\n\n      shimmer.unwrap(fileHandlePrototype, name);\n    }\n\n    delete fileHandlePrototype[kHandle];\n  });\n}\n\nfunction unpatchPromiseFunctions(fs) {\n  for (const name in fs.promises) {\n    if (name in tagMakers) {\n      shimmer.unwrap(fs.promises, name);\n    }\n  }\n}\n\nfunction unpatchDirFunctions(fs) {\n  shimmer.unwrap(fs.Dir.prototype, 'close');\n  shimmer.unwrap(fs.Dir.prototype, 'closeSync');\n  shimmer.unwrap(fs.Dir.prototype, 'read');\n  shimmer.unwrap(fs.Dir.prototype, 'readSync');\n  shimmer.unwrap(fs.Dir.prototype, Symbol.asyncIterator);\n}\n\nconst hookChannel = channel('apm:fs:hook');\nhookChannel.subscribe(fs => {\n  fsInstance = fs;\n});\n\nclass FsPlugin extends Plugin {\n  static get name() {\n    return 'fs';\n  }\n\n  configure(config) {\n    fsConfig = config;\n    super.configure(config);\n\n    this._unpatch();\n\n    if (this._enabled) {\n      this._patch();\n    }\n  }\n\n  _patch() {\n    const fs = fsInstance;\n    const tracer = this.tracer;\n    const config = this.config;\n    const realpathNative = fs.realpath.native;\n    const realpathSyncNative = fs.realpathSync.native;\n    patchClassicFunctions.call(this, fs, tracer, config);\n\n    if (fs.promises) {\n      patchFileHandle.call(this, fs, tracer, config);\n      patchPromiseFunctions.call(this, fs, tracer, config);\n    }\n\n    if (fs.Dir) {\n      patchDirFunctions.call(this, fs, tracer, config);\n    }\n\n    shimmer.wrap(fs, 'createReadStream', createWrapCreateReadStream(config, tracer));\n    shimmer.wrap(fs, 'createWriteStream', createWrapCreateWriteStream(config, tracer));\n    shimmer.wrap(fs, 'existsSync', createWrap(tracer, config, 'existsSync', createPathTags));\n    shimmer.wrap(fs, 'exists', createWrapExists(config, tracer));\n\n    if (realpathNative) {\n      fs.realpath.native = createWrapCb(tracer, config, 'realpath.native', createPathTags)(realpathNative);\n    }\n\n    if (realpathSyncNative) {\n      fs.realpathSync.native = createWrap(tracer, config, 'realpath.native', createPathTags)(realpathSyncNative);\n    }\n  }\n\n  _unpatch() {\n    const fs = fsInstance;\n    unpatchClassicFunctions.call(this, fs);\n\n    if (fs.promises) {\n      unpatchFileHandle.call(this, fs);\n      unpatchPromiseFunctions.call(this, fs);\n    }\n\n    if (fs.Dir) {\n      unpatchDirFunctions.call(this, fs);\n    }\n\n    shimmer.unwrap(fs, 'createReadStream');\n    shimmer.unwrap(fs, 'createWriteStream');\n    shimmer.unwrap(fs, 'existsSync');\n    shimmer.unwrap(fs, 'exists');\n  }\n\n}\n\nmodule.exports = FsPlugin;\n/** TODO fs functions:\n\nunwatchFile\nwatch\nwatchFile\n*/","map":{"version":3,"names":["storage","require","channel","shimmer","Plugin","kDirReadPromisified","kDirClosePromisified","kHandle","fsConfig","fsInstance","ddFhSym","Symbol","tagMakers","open","createOpenTags","close","createCloseTags","readFile","createReadFileTags","writeFile","createWriteFileTags","appendFile","createAppendFileTags","access","createPathTags","copyFile","createCopyFileTags","stat","lstat","fstat","createFDTags","readdir","opendir","read","write","writev","chmod","createChmodTags","lchmod","fchmod","createFchmodTags","chown","createChownTags","lchown","fchown","createFchownTags","realpath","readlink","unlink","symlink","link","rmdir","rename","fsync","fdatasync","mkdir","truncate","ftruncate","utimes","futimes","mkdtemp","promisifiable","orphanable","createWrapCreateReadStream","config","tracer","wrapCreateReadStream","createReadStream","createReadStreamWithTrace","path","options","hasParent","apply","arguments","tags","makeFSFlagTags","trace","span","done","stream","once","createWrapCreateWriteStream","wrapCreateWriteStream","createWriteStream","createWriteStreamWithTrace","createWrapExists","wrapExists","exists","existsWithTrace","cb","makeFSTags","result","copySymbols","createWrapDirRead","sync","name","wrapDirRead","wrap","createWrapDirClose","wrapDirClose","createWrapDirAsyncIterator","instrumenter","wrapDirAsyncIterator","asyncIterator","asyncIteratorWithTrace","keys","Reflect","ownKeys","key","getSymbolName","includes","createWrapKDirClose","wrapKDirClose","kDirClose","kDirCloseWithTrace","p","unwrapBoth","unwrap","then","resourceName","openTags","flag","mode","closeTags","fd","Number","isInteger","readFileTags","writeFileTags","data","appendFileTags","copyFileTags","src","dest","chmodTags","toString","fchmodTags","pathTags","fdTags","chownTags","uid","gid","fchownTags","sym","description","store","getStore","noop","createWrapCb","tagMaker","makeTags","wrapFunction","fn","length","createWrap","wrapSyncFunction","defaultFlag","flags","service","_service","from","to","props","Object","getOwnPropertyDescriptors","hasOwnProperty","defineProperty","getFileHandlePrototype","fs","promises","__filename","fh","find","getPrototypeOf","patchClassicFunctions","tagMakerName","endsWith","substr","original","patchFileHandle","fileHandlePrototype","fName","desc","getOwnPropertyDescriptor","get","set","h","configurable","patchPromiseFunctions","patchDirFunctions","Dir","prototype","unpatchClassicFunctions","unpatchFileHandle","unpatchPromiseFunctions","unpatchDirFunctions","hookChannel","subscribe","FsPlugin","configure","_unpatch","_enabled","_patch","realpathNative","native","realpathSyncNative","realpathSync","call","module","exports"],"sources":["/Users/daniel.calderon/Projects/barkito/barkito_front/node_modules/dd-trace/packages/datadog-plugin-fs/src/index.js"],"sourcesContent":["'use strict'\n\n// The `fs` plugin is an old style plugin that has not been updated for the new\n// plugin system and was hacked in for backward compatibility with 2.x.\n\nconst { storage } = require('../../datadog-core')\nconst { channel } = require('../../datadog-instrumentations/src/helpers/instrument')\nconst shimmer = require('../../datadog-shimmer')\nconst Plugin = require('../../dd-trace/src/plugins/plugin')\n\nlet kDirReadPromisified\nlet kDirClosePromisified\nlet kHandle\nlet fsConfig\nlet fsInstance\n\nconst ddFhSym = Symbol('ddFileHandle')\n\nconst tagMakers = {\n  open: createOpenTags,\n  close: createCloseTags,\n  readFile: createReadFileTags,\n  writeFile: createWriteFileTags,\n  appendFile: createAppendFileTags,\n  access: createPathTags,\n  copyFile: createCopyFileTags,\n  stat: createPathTags,\n  lstat: createPathTags,\n  fstat: createFDTags,\n  readdir: createPathTags,\n  opendir: createPathTags,\n  read: createFDTags,\n  write: createFDTags,\n  writev: createFDTags,\n  chmod: createChmodTags,\n  lchmod: createChmodTags,\n  fchmod: createFchmodTags,\n  chown: createChownTags,\n  lchown: createChownTags,\n  fchown: createFchownTags,\n  realpath: createPathTags,\n  readlink: createPathTags,\n  unlink: createPathTags,\n  symlink: createCopyFileTags,\n  link: createCopyFileTags,\n  rmdir: createPathTags,\n  rename: createCopyFileTags,\n  fsync: createFDTags,\n  fdatasync: createFDTags,\n  mkdir: createPathTags,\n  truncate: createPathTags,\n  ftruncate: createFDTags,\n  utimes: createPathTags,\n  futimes: createFDTags,\n  mkdtemp: createPathTags\n}\n\nconst promisifiable = ['read', 'readv', 'write', 'writev']\n\nconst orphanable = false\n\nfunction createWrapCreateReadStream (config, tracer) {\n  return function wrapCreateReadStream (createReadStream) {\n    return function createReadStreamWithTrace (path, options) {\n      if (!hasParent()) {\n        return createReadStream.apply(this, arguments)\n      }\n      const tags = makeFSFlagTags('ReadStream', path, options, 'r', config, tracer)\n      return tracer.trace('fs.operation', { tags, orphanable }, (span, done) => {\n        const stream = createReadStream.apply(this, arguments)\n        stream.once('close', done)\n        stream.once('end', done)\n        stream.once('error', done)\n        return stream\n      })\n    }\n  }\n}\n\nfunction createWrapCreateWriteStream (config, tracer) {\n  return function wrapCreateWriteStream (createWriteStream) {\n    return function createWriteStreamWithTrace (path, options) {\n      const tags = makeFSFlagTags('WriteStream', path, options, 'w', config, tracer)\n      return tracer.trace('fs.operation', { tags, orphanable }, (span, done) => {\n        const stream = createWriteStream.apply(this, arguments)\n        stream.once('close', done)\n        stream.once('finish', done)\n        stream.once('error', done)\n        return stream\n      })\n    }\n  }\n}\n\nfunction createWrapExists (config, tracer) {\n  return function wrapExists (exists) {\n    const existsWithTrace = function existsWithTrace (path, cb) {\n      if (typeof cb !== 'function') {\n        return exists.apply(this, arguments)\n      }\n      const tags = makeFSTags('exists', path, null, config, tracer)\n      return tracer.trace('fs.operation', { tags, orphanable }, (span, done) => {\n        arguments[1] = function (result) {\n          done()\n          cb.apply(this, arguments)\n        }\n        return exists.apply(this, arguments)\n      })\n    }\n\n    copySymbols(exists, existsWithTrace)\n\n    return existsWithTrace\n  }\n}\n\nfunction createWrapDirRead (config, tracer, sync) {\n  const name = sync ? 'dir.readSync' : 'dir.read'\n  return function wrapDirRead (read) {\n    function options () {\n      const tags = makeFSTags(name, this.path, null, config, tracer)\n      return { tags, orphanable }\n    }\n    return tracer.wrap('fs.operation', options, read, true)\n  }\n}\n\nfunction createWrapDirClose (config, tracer, sync) {\n  const name = sync ? 'dir.closeSync' : 'dir.close'\n  return function wrapDirClose (close) {\n    function options () {\n      const tags = makeFSTags(name, this.path, null, config, tracer)\n      return { tags, orphanable }\n    }\n    return tracer.wrap('fs.operation', options, close, true)\n  }\n}\n\nfunction createWrapDirAsyncIterator (config, tracer, instrumenter) {\n  return function wrapDirAsyncIterator (asyncIterator) {\n    return function asyncIteratorWithTrace () {\n      if (!kDirReadPromisified) {\n        const keys = Reflect.ownKeys(this)\n        for (const key of keys) {\n          if (kDirReadPromisified && kDirClosePromisified) break\n          if (typeof key !== 'symbol') continue\n          if (!kDirReadPromisified && getSymbolName(key).includes('kDirReadPromisified')) {\n            kDirReadPromisified = key\n          }\n          if (!kDirClosePromisified && getSymbolName(key).includes('kDirClosePromisified')) {\n            kDirClosePromisified = key\n          }\n        }\n      }\n      shimmer.wrap(this, kDirReadPromisified, createWrapDirRead(config, tracer))\n      shimmer.wrap(this, kDirClosePromisified, createWrapKDirClose(config, tracer, instrumenter))\n      return asyncIterator.apply(this, arguments)\n    }\n  }\n}\n\nfunction createWrapKDirClose (config, tracer, instrumenter) {\n  return function wrapKDirClose (kDirClose) {\n    return function kDirCloseWithTrace () {\n      const tags = makeFSTags('dir.close', this.path, null, config, tracer)\n      return tracer.trace('fs.operation', { tags, orphanable }, (span) => {\n        const p = kDirClose.apply(this, arguments)\n        const unwrapBoth = () => {\n          shimmer.unwrap(this, kDirReadPromisified)\n          shimmer.unwrap(this, kDirClosePromisified)\n        }\n        p.then(unwrapBoth, unwrapBoth)\n        return p\n      })\n    }\n  }\n}\n\nfunction createOpenTags (resourceName, config, tracer) {\n  return function openTags (path, flag, mode) {\n    if (!flag || typeof flag === 'function') {\n      flag = null\n    }\n    return makeFSFlagTags(resourceName, path, { flag }, 'r', config, tracer)\n  }\n}\n\nfunction createCloseTags (resourceName, config, tracer) {\n  return function closeTags (fd) {\n    if (typeof fd === 'undefined' && this && this[ddFhSym]) {\n      fd = this[ddFhSym].fd\n    }\n    if (typeof fd !== 'number' || !Number.isInteger(fd)) {\n      return\n    }\n    return makeFSTags(resourceName, fd, null, config, tracer)\n  }\n}\n\nfunction createReadFileTags (resourceName, config, tracer) {\n  return function readFileTags (path, options) {\n    return makeFSFlagTags(resourceName, path, options, 'r', config, tracer)\n  }\n}\n\nfunction createWriteFileTags (resourceName, config, tracer) {\n  return function writeFileTags (path, data, options) {\n    return makeFSFlagTags(resourceName, path, options, 'w', config, tracer)\n  }\n}\n\nfunction createAppendFileTags (resourceName, config, tracer) {\n  return function appendFileTags (path, data, options) {\n    return makeFSFlagTags(resourceName, path, options, 'a', config, tracer)\n  }\n}\n\nfunction createCopyFileTags (resourceName, config, tracer) {\n  return function copyFileTags (src, dest, flag) {\n    return makeFSTags(resourceName, { src, dest }, null, config, tracer)\n  }\n}\n\nfunction createChmodTags (resourceName, config, tracer) {\n  return function chmodTags (fd, mode) {\n    const tags = makeFSTags(resourceName, fd, null, config, tracer)\n    tags['file.mode'] = mode.toString(8)\n    return tags\n  }\n}\n\nfunction createFchmodTags (resourceName, config, tracer) {\n  return function fchmodTags (fd, mode) {\n    if (typeof this === 'object' && this !== null && this.fd) {\n      mode = fd\n      fd = this.fd\n    }\n\n    const tags = makeFSTags(resourceName, fd, null, config, tracer)\n    if (mode) {\n      tags['file.mode'] = mode.toString(8)\n    }\n    return tags\n  }\n}\n\nfunction createPathTags (resourceName, config, tracer) {\n  return function pathTags (path) {\n    return makeFSTags(resourceName, path, null, config, tracer)\n  }\n}\n\nfunction createFDTags (resourceName, config, tracer) {\n  return function fdTags (fd) {\n    if (typeof this === 'object' && this !== null && this.fd) {\n      fd = this.fd\n    }\n    return makeFSTags(resourceName, fd, null, config, tracer)\n  }\n}\n\nfunction createChownTags (resourceName, config, tracer) {\n  return function chownTags (fd, uid, gid) {\n    const tags = makeFSTags(resourceName, fd, null, config, tracer)\n    if (typeof uid === 'number') {\n      tags['file.uid'] = uid.toString()\n    }\n    if (typeof gid === 'number') {\n      tags['file.gid'] = gid.toString()\n    }\n    return tags\n  }\n}\n\nfunction createFchownTags (resourceName, config, tracer) {\n  return function fchownTags (fd, uid, gid) {\n    if (typeof this === 'object' && this !== null && this.fd) {\n      gid = uid\n      uid = fd\n      fd = this.fd\n    }\n    const tags = makeFSTags(resourceName, fd, null, config, tracer)\n    if (typeof uid === 'number') {\n      tags['file.uid'] = uid.toString()\n    }\n    if (typeof gid === 'number') {\n      tags['file.gid'] = gid.toString()\n    }\n    return tags\n  }\n}\n\nfunction getSymbolName (sym) {\n  return sym.description || sym.toString()\n}\n\nfunction hasParent () {\n  const store = storage.getStore()\n\n  return store && store.span && !store.noop\n}\n\nfunction createWrapCb (tracer, config, name, tagMaker) {\n  const makeTags = tagMaker(name, config, tracer)\n  return function wrapFunction (fn) {\n    return tracer.wrap('fs.operation', function () {\n      if (typeof arguments[arguments.length - 1] !== 'function') {\n        return\n      }\n      const tags = makeTags.apply(this, arguments)\n      return tags ? { tags, orphanable } : { orphanable }\n    }, fn, true)\n  }\n}\n\nfunction createWrap (tracer, config, name, tagMaker) {\n  const makeTags = tagMaker(name, config, tracer)\n\n  return function wrapSyncFunction (fn) {\n    return tracer.wrap('fs.operation', function () {\n      const tags = makeTags.apply(this, arguments)\n      return tags ? { tags, orphanable } : { orphanable }\n    }, fn, true)\n  }\n}\n\nfunction makeFSFlagTags (resourceName, path, options, defaultFlag, config, tracer) {\n  const tags = makeFSTags(resourceName, path, options, config, tracer)\n\n  if (tags) {\n    let flag = defaultFlag\n    if (typeof options === 'object' && options !== null) {\n      if (options.flag) {\n        flag = options.flag\n      } else if (options.flags) {\n        flag = options.flags\n      }\n    }\n    tags['file.flag'] = flag\n    return tags\n  }\n}\n\nfunction makeFSTags (resourceName, path, options, config, tracer) {\n  path = options && typeof options === 'object' && 'fd' in options ? options.fd : path\n  const tags = {\n    'component': 'fs',\n    'span.kind': 'internal',\n    'resource.name': resourceName,\n    'service.name': fsConfig.service || tracer._service\n  }\n\n  switch (typeof path) {\n    case 'object': {\n      if (path === null) return tags\n      const src = 'src' in path ? path.src : null\n      const dest = 'dest' in path ? path.dest : null\n      if (src || dest) {\n        tags['file.src'] = src\n        tags['file.dest'] = dest\n      } else {\n        tags['file.path'] = path\n      }\n      break\n    }\n    case 'string': {\n      tags['file.path'] = path\n      break\n    }\n    case 'number': {\n      tags['file.descriptor'] = path.toString()\n      break\n    }\n  }\n\n  return tags\n}\n\nfunction copySymbols (from, to) {\n  const props = Object.getOwnPropertyDescriptors(from)\n  const keys = Reflect.ownKeys(props)\n\n  for (const key of keys) {\n    if (typeof key !== 'symbol' || to.hasOwnProperty(key)) continue\n\n    Object.defineProperty(to, key, props[key])\n  }\n}\n\nfunction getFileHandlePrototype (fs) {\n  return fs.promises.open(__filename, 'r')\n    .then(fh => {\n      if (!kHandle) {\n        kHandle = Reflect.ownKeys(fh).find(key => typeof key === 'symbol' && key.toString().includes('kHandle'))\n      }\n      fh.close()\n\n      return Object.getPrototypeOf(fh)\n    })\n}\n\nfunction patchClassicFunctions (fs, tracer, config) {\n  for (const name in fs) {\n    if (!fs[name]) continue\n    const tagMakerName = name.endsWith('Sync') ? name.substr(0, name.length - 4) : name\n    const original = fs[name]\n    if (tagMakerName in tagMakers) {\n      const tagMaker = tagMakers[tagMakerName]\n      if (name.endsWith('Sync')) {\n        shimmer.wrap(fs, name, createWrap(tracer, config, name, tagMaker))\n      } else {\n        shimmer.wrap(fs, name, createWrapCb(tracer, config, name, tagMaker))\n      }\n      if (name in promisifiable) {\n        copySymbols(original, fs[name])\n      }\n    }\n  }\n}\n\nfunction patchFileHandle (fs, tracer, config) {\n  getFileHandlePrototype(fs).then((fileHandlePrototype) => {\n    for (const name of Reflect.ownKeys(fileHandlePrototype)) {\n      if (typeof name !== 'string' || name === 'constructor' || name === 'fd' || name === 'getAsyncId') {\n        continue\n      }\n      let tagMaker\n      const fName = 'f' + name\n      if (fName in tagMakers) {\n        tagMaker = tagMakers[fName]\n      } else {\n        tagMaker = createFDTags\n      }\n\n      const desc = Reflect.getOwnPropertyDescriptor(fileHandlePrototype, kHandle)\n      if (!desc || !desc.get) {\n        Reflect.defineProperty(fileHandlePrototype, kHandle, {\n          get () {\n            return this[ddFhSym]\n          },\n          set (h) {\n            this[ddFhSym] = h\n            shimmer.wrap(this, 'close', createWrap(tracer, config, 'filehandle.close', tagMakers.close))\n          },\n          configurable: true\n        })\n      }\n\n      shimmer.wrap(fileHandlePrototype, name, createWrap(tracer, config, 'filehandle.' + name, tagMaker))\n    }\n  })\n}\n\nfunction patchPromiseFunctions (fs, tracer, config) {\n  for (const name in fs.promises) {\n    if (name in tagMakers) {\n      const tagMaker = tagMakers[name]\n      shimmer.wrap(fs.promises, name, createWrap(tracer, config, 'promises.' + name, tagMaker))\n    }\n  }\n}\n\nfunction patchDirFunctions (fs, tracer, config) {\n  shimmer.wrap(fs.Dir.prototype, 'close', createWrapDirClose(config, tracer))\n  shimmer.wrap(fs.Dir.prototype, 'closeSync', createWrapDirClose(config, tracer, true))\n  shimmer.wrap(fs.Dir.prototype, 'read', createWrapDirRead(config, tracer))\n  shimmer.wrap(fs.Dir.prototype, 'readSync', createWrapDirRead(config, tracer, true))\n  shimmer.wrap(fs.Dir.prototype, Symbol.asyncIterator, createWrapDirAsyncIterator(config, tracer, this))\n}\n\nfunction unpatchClassicFunctions (fs) {\n  for (const name in fs) {\n    if (!fs[name]) continue\n    const tagMakerName = name.endsWith('Sync') ? name.substr(0, name.length - 4) : name\n    if (tagMakerName in tagMakers) {\n      shimmer.unwrap(fs, name)\n    }\n  }\n}\n\nfunction unpatchFileHandle (fs) {\n  getFileHandlePrototype(fs).then(fileHandlePrototype => {\n    for (const name of Reflect.ownKeys(fileHandlePrototype)) {\n      if (typeof name !== 'string' || name === 'constructor' || name === 'fd' || name === 'getAsyncId') {\n        continue\n      }\n      shimmer.unwrap(fileHandlePrototype, name)\n    }\n    delete fileHandlePrototype[kHandle]\n  })\n}\n\nfunction unpatchPromiseFunctions (fs) {\n  for (const name in fs.promises) {\n    if (name in tagMakers) {\n      shimmer.unwrap(fs.promises, name)\n    }\n  }\n}\n\nfunction unpatchDirFunctions (fs) {\n  shimmer.unwrap(fs.Dir.prototype, 'close')\n  shimmer.unwrap(fs.Dir.prototype, 'closeSync')\n  shimmer.unwrap(fs.Dir.prototype, 'read')\n  shimmer.unwrap(fs.Dir.prototype, 'readSync')\n  shimmer.unwrap(fs.Dir.prototype, Symbol.asyncIterator)\n}\n\nconst hookChannel = channel('apm:fs:hook')\n\nhookChannel.subscribe(fs => {\n  fsInstance = fs\n})\n\nclass FsPlugin extends Plugin {\n  static get name () {\n    return 'fs'\n  }\n\n  configure (config) {\n    fsConfig = config\n\n    super.configure(config)\n\n    this._unpatch()\n\n    if (this._enabled) {\n      this._patch()\n    }\n  }\n\n  _patch () {\n    const fs = fsInstance\n    const tracer = this.tracer\n    const config = this.config\n    const realpathNative = fs.realpath.native\n    const realpathSyncNative = fs.realpathSync.native\n    patchClassicFunctions.call(this, fs, tracer, config)\n    if (fs.promises) {\n      patchFileHandle.call(this, fs, tracer, config)\n      patchPromiseFunctions.call(this, fs, tracer, config)\n    }\n    if (fs.Dir) {\n      patchDirFunctions.call(this, fs, tracer, config)\n    }\n    shimmer.wrap(fs, 'createReadStream', createWrapCreateReadStream(config, tracer))\n    shimmer.wrap(fs, 'createWriteStream', createWrapCreateWriteStream(config, tracer))\n    shimmer.wrap(fs, 'existsSync', createWrap(tracer, config, 'existsSync', createPathTags))\n    shimmer.wrap(fs, 'exists', createWrapExists(config, tracer))\n    if (realpathNative) {\n      fs.realpath.native = createWrapCb(tracer, config, 'realpath.native', createPathTags)(realpathNative)\n    }\n    if (realpathSyncNative) {\n      fs.realpathSync.native = createWrap(tracer, config, 'realpath.native', createPathTags)(realpathSyncNative)\n    }\n  }\n\n  _unpatch () {\n    const fs = fsInstance\n    unpatchClassicFunctions.call(this, fs)\n    if (fs.promises) {\n      unpatchFileHandle.call(this, fs)\n      unpatchPromiseFunctions.call(this, fs)\n    }\n    if (fs.Dir) {\n      unpatchDirFunctions.call(this, fs)\n    }\n    shimmer.unwrap(fs, 'createReadStream')\n    shimmer.unwrap(fs, 'createWriteStream')\n    shimmer.unwrap(fs, 'existsSync')\n    shimmer.unwrap(fs, 'exists')\n  }\n}\n\nmodule.exports = FsPlugin\n\n/** TODO fs functions:\n\nunwatchFile\nwatch\nwatchFile\n*/\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}