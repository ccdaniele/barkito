{"ast":null,"code":"'use strict';\n\nconst {\n  channel\n} = require('diagnostics_channel');\n\nconst path = require('path');\n\nconst semver = require('semver');\n\nconst Hook = require('./hook');\n\nconst requirePackageJson = require('../../../dd-trace/src/require-package-json');\n\nconst log = require('../../../dd-trace/src/log');\n\nconst hooks = require('./hooks');\n\nconst instrumentations = require('./instrumentations');\n\nconst names = Object.keys(hooks);\nconst pathSepExpr = new RegExp(`\\\\${path.sep}`, 'g');\nconst loadChannel = channel('dd-trace:instrumentation:load'); // TODO: make this more efficient\n\nfor (const packageName of names) {\n  Hook([packageName], (moduleExports, moduleName, moduleBaseDir) => {\n    moduleName = moduleName.replace(pathSepExpr, '/');\n    hooks[packageName]();\n\n    for (const {\n      name,\n      file,\n      versions,\n      hook\n    } of instrumentations[packageName]) {\n      const fullFilename = filename(name, file);\n\n      if (moduleName === fullFilename) {\n        const version = getVersion(moduleBaseDir);\n\n        if (matchVersion(version, versions)) {\n          try {\n            loadChannel.publish({\n              name,\n              version,\n              file\n            });\n            moduleExports = hook(moduleExports);\n          } catch (e) {\n            log.error(e);\n          }\n        }\n      }\n    }\n\n    return moduleExports;\n  });\n}\n\nfunction matchVersion(version, ranges) {\n  return !version || ranges && ranges.some(range => semver.satisfies(semver.coerce(version), range));\n}\n\nfunction getVersion(moduleBaseDir) {\n  if (moduleBaseDir) {\n    return requirePackageJson(moduleBaseDir, module).version;\n  }\n}\n\nfunction filename(name, file) {\n  return [name, file].filter(val => val).join('/');\n}","map":{"version":3,"names":["channel","require","path","semver","Hook","requirePackageJson","log","hooks","instrumentations","names","Object","keys","pathSepExpr","RegExp","sep","loadChannel","packageName","moduleExports","moduleName","moduleBaseDir","replace","name","file","versions","hook","fullFilename","filename","version","getVersion","matchVersion","publish","e","error","ranges","some","range","satisfies","coerce","module","filter","val","join"],"sources":["/Users/daniel.calderon/Projects/barkito/barkito_front/node_modules/dd-trace/packages/datadog-instrumentations/src/helpers/register.js"],"sourcesContent":["'use strict'\n\nconst { channel } = require('diagnostics_channel')\nconst path = require('path')\nconst semver = require('semver')\nconst Hook = require('./hook')\nconst requirePackageJson = require('../../../dd-trace/src/require-package-json')\nconst log = require('../../../dd-trace/src/log')\n\nconst hooks = require('./hooks')\nconst instrumentations = require('./instrumentations')\nconst names = Object.keys(hooks)\nconst pathSepExpr = new RegExp(`\\\\${path.sep}`, 'g')\n\nconst loadChannel = channel('dd-trace:instrumentation:load')\n\n// TODO: make this more efficient\n\nfor (const packageName of names) {\n  Hook([packageName], (moduleExports, moduleName, moduleBaseDir) => {\n    moduleName = moduleName.replace(pathSepExpr, '/')\n\n    hooks[packageName]()\n\n    for (const { name, file, versions, hook } of instrumentations[packageName]) {\n      const fullFilename = filename(name, file)\n\n      if (moduleName === fullFilename) {\n        const version = getVersion(moduleBaseDir)\n\n        if (matchVersion(version, versions)) {\n          try {\n            loadChannel.publish({ name, version, file })\n\n            moduleExports = hook(moduleExports)\n          } catch (e) {\n            log.error(e)\n          }\n        }\n      }\n    }\n\n    return moduleExports\n  })\n}\n\nfunction matchVersion (version, ranges) {\n  return !version || (ranges && ranges.some(range => semver.satisfies(semver.coerce(version), range)))\n}\n\nfunction getVersion (moduleBaseDir) {\n  if (moduleBaseDir) {\n    return requirePackageJson(moduleBaseDir, module).version\n  }\n}\n\nfunction filename (name, file) {\n  return [name, file].filter(val => val).join('/')\n}\n"],"mappings":"AAAA;;AAEA,MAAM;EAAEA;AAAF,IAAcC,OAAO,CAAC,qBAAD,CAA3B;;AACA,MAAMC,IAAI,GAAGD,OAAO,CAAC,MAAD,CAApB;;AACA,MAAME,MAAM,GAAGF,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAMG,IAAI,GAAGH,OAAO,CAAC,QAAD,CAApB;;AACA,MAAMI,kBAAkB,GAAGJ,OAAO,CAAC,4CAAD,CAAlC;;AACA,MAAMK,GAAG,GAAGL,OAAO,CAAC,2BAAD,CAAnB;;AAEA,MAAMM,KAAK,GAAGN,OAAO,CAAC,SAAD,CAArB;;AACA,MAAMO,gBAAgB,GAAGP,OAAO,CAAC,oBAAD,CAAhC;;AACA,MAAMQ,KAAK,GAAGC,MAAM,CAACC,IAAP,CAAYJ,KAAZ,CAAd;AACA,MAAMK,WAAW,GAAG,IAAIC,MAAJ,CAAY,KAAIX,IAAI,CAACY,GAAI,EAAzB,EAA4B,GAA5B,CAApB;AAEA,MAAMC,WAAW,GAAGf,OAAO,CAAC,+BAAD,CAA3B,C,CAEA;;AAEA,KAAK,MAAMgB,WAAX,IAA0BP,KAA1B,EAAiC;EAC/BL,IAAI,CAAC,CAACY,WAAD,CAAD,EAAgB,CAACC,aAAD,EAAgBC,UAAhB,EAA4BC,aAA5B,KAA8C;IAChED,UAAU,GAAGA,UAAU,CAACE,OAAX,CAAmBR,WAAnB,EAAgC,GAAhC,CAAb;IAEAL,KAAK,CAACS,WAAD,CAAL;;IAEA,KAAK,MAAM;MAAEK,IAAF;MAAQC,IAAR;MAAcC,QAAd;MAAwBC;IAAxB,CAAX,IAA6ChB,gBAAgB,CAACQ,WAAD,CAA7D,EAA4E;MAC1E,MAAMS,YAAY,GAAGC,QAAQ,CAACL,IAAD,EAAOC,IAAP,CAA7B;;MAEA,IAAIJ,UAAU,KAAKO,YAAnB,EAAiC;QAC/B,MAAME,OAAO,GAAGC,UAAU,CAACT,aAAD,CAA1B;;QAEA,IAAIU,YAAY,CAACF,OAAD,EAAUJ,QAAV,CAAhB,EAAqC;UACnC,IAAI;YACFR,WAAW,CAACe,OAAZ,CAAoB;cAAET,IAAF;cAAQM,OAAR;cAAiBL;YAAjB,CAApB;YAEAL,aAAa,GAAGO,IAAI,CAACP,aAAD,CAApB;UACD,CAJD,CAIE,OAAOc,CAAP,EAAU;YACVzB,GAAG,CAAC0B,KAAJ,CAAUD,CAAV;UACD;QACF;MACF;IACF;;IAED,OAAOd,aAAP;EACD,CAxBG,CAAJ;AAyBD;;AAED,SAASY,YAAT,CAAuBF,OAAvB,EAAgCM,MAAhC,EAAwC;EACtC,OAAO,CAACN,OAAD,IAAaM,MAAM,IAAIA,MAAM,CAACC,IAAP,CAAYC,KAAK,IAAIhC,MAAM,CAACiC,SAAP,CAAiBjC,MAAM,CAACkC,MAAP,CAAcV,OAAd,CAAjB,EAAyCQ,KAAzC,CAArB,CAA9B;AACD;;AAED,SAASP,UAAT,CAAqBT,aAArB,EAAoC;EAClC,IAAIA,aAAJ,EAAmB;IACjB,OAAOd,kBAAkB,CAACc,aAAD,EAAgBmB,MAAhB,CAAlB,CAA0CX,OAAjD;EACD;AACF;;AAED,SAASD,QAAT,CAAmBL,IAAnB,EAAyBC,IAAzB,EAA+B;EAC7B,OAAO,CAACD,IAAD,EAAOC,IAAP,EAAaiB,MAAb,CAAoBC,GAAG,IAAIA,GAA3B,EAAgCC,IAAhC,CAAqC,GAArC,CAAP;AACD"},"metadata":{},"sourceType":"script"}