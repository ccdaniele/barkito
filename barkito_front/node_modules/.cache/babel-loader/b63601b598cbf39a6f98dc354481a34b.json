{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SourceMapper = void 0; // Originally copied from cloud-debug-nodejs's sourcemapper.ts from\n// https://github.com/googleapis/cloud-debug-nodejs/blob/7bdc2f1f62a3b45b7b53ea79f9444c8ed50e138b/src/agent/io/sourcemapper.ts\n// Modified to map from generated code to source code, rather than from source\n// code to generated code.\n\nconst fs = require(\"fs\");\n\nconst path = require(\"path\"); // Apparently the source-map module feature-detects the browser by checking\n// if the fetch function exists. Because it now exists in Node.js v18, the\n// source-map module thinks it's running in a browser and doesn't work.\n\n\nconst desc = Object.getOwnPropertyDescriptor(globalThis, 'fetch'); // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\n\ndelete globalThis.fetch;\n\nconst sourceMap = require(\"source-map\");\n\nif (desc) {\n  Object.defineProperty(globalThis, 'fetch', desc);\n}\n\nconst scanner = require(\"../../third_party/cloud-debug-nodejs/src/agent/io/scanner\");\n\nconst pify = require('pify');\n\nconst pLimit = require('p-limit');\n\nconst readFile = pify(fs.readFile);\nconst CONCURRENCY = 10;\nconst MAP_EXT = '.map';\n/**\n * @param {!Map} infoMap The map that maps input source files to\n *  SourceMapConsumer objects that are used to calculate mapping information\n * @param {string} mapPath The path to the source map file to process.  The\n *  path should be relative to the process's current working directory\n * @private\n */\n\nasync function processSourceMap(infoMap, mapPath) {\n  // this handles the case when the path is undefined, null, or\n  // the empty string\n  if (!mapPath || !mapPath.endsWith(MAP_EXT)) {\n    throw new Error(`The path \"${mapPath}\" does not specify a source map file`);\n  }\n\n  mapPath = path.normalize(mapPath);\n  let contents;\n\n  try {\n    contents = await readFile(mapPath, 'utf8');\n  } catch (e) {\n    throw new Error('Could not read source map file ' + mapPath + ': ' + e);\n  }\n\n  let consumer;\n\n  try {\n    // TODO: Determine how to reconsile the type conflict where `consumer`\n    //       is constructed as a SourceMapConsumer but is used as a\n    //       RawSourceMap.\n    // TODO: Resolve the cast of `contents as any` (This is needed because the\n    //       type is expected to be of `RawSourceMap` but the existing\n    //       working code uses a string.)\n    consumer = await new sourceMap.SourceMapConsumer(contents);\n  } catch (e) {\n    throw new Error('An error occurred while reading the ' + 'sourceMap file ' + mapPath + ': ' + e);\n  }\n  /*\n   * If the source map file defines a \"file\" attribute, use it as\n   * the output file where the path is relative to the directory\n   * containing the map file.  Otherwise, use the name of the output\n   * file (with the .map extension removed) as the output file.\n   */\n\n\n  const dir = path.dirname(mapPath);\n  const generatedBase = consumer.file ? consumer.file : path.basename(mapPath, MAP_EXT);\n  const generatedPath = path.resolve(dir, generatedBase);\n  infoMap.set(generatedPath, {\n    mapFileDir: dir,\n    mapConsumer: consumer\n  });\n}\n\nclass SourceMapper {\n  /**\n   * @param {Array.<string>} sourceMapPaths An array of paths to .map source map\n   *  files that should be processed.  The paths should be relative to the\n   *  current process's current working directory\n   * @param {Logger} logger A logger that reports errors that occurred while\n   *  processing the given source map files\n   * @constructor\n   */\n  constructor() {\n    this.infoMap = new Map();\n  }\n\n  static async create(searchDirs) {\n    const mapFiles = [];\n\n    for (const dir of searchDirs) {\n      try {\n        const mf = await getMapFiles(dir);\n        mf.forEach(mapFile => {\n          mapFiles.push(path.resolve(dir, mapFile));\n        });\n      } catch (e) {\n        throw new Error(`failed to get source maps from ${dir}: ${e}`);\n      }\n    }\n\n    return createFromMapFiles(mapFiles);\n  }\n  /**\n   * Used to get the information about the transpiled file from a given input\n   * source file provided there isn't any ambiguity with associating the input\n   * path to exactly one output transpiled file.\n   *\n   * @param inputPath The (possibly relative) path to the original source file.\n   * @return The `MapInfoCompiled` object that describes the transpiled file\n   *  associated with the specified input path.  `null` is returned if either\n   *  zero files are associated with the input path or if more than one file\n   *  could possibly be associated with the given input path.\n   */\n\n\n  getMappingInfo(inputPath) {\n    if (this.infoMap.has(path.normalize(inputPath))) {\n      return this.infoMap.get(inputPath);\n    }\n\n    return null;\n  }\n  /**\n   * Used to determine if the source file specified by the given path has\n   * a .map file and an output file associated with it.\n   *\n   * If there is no such mapping, it could be because the input file is not\n   * the input to a transpilation process or it is the input to a transpilation\n   * process but its corresponding .map file was not given to the constructor\n   * of this mapper.\n   *\n   * @param {string} inputPath The path to an input file that could\n   *  possibly be the input to a transpilation process.  The path should be\n   *  relative to the process's current working directory.\n   */\n\n\n  hasMappingInfo(inputPath) {\n    return this.getMappingInfo(inputPath) !== null;\n  }\n  /**\n   * @param {string} inputPath The path to an input file that could possibly\n   *  be the input to a transpilation process.  The path should be relative to\n   *  the process's current working directory\n   * @param {number} The line number in the input file where the line number is\n   *   zero-based.\n   * @param {number} (Optional) The column number in the line of the file\n   *   specified where the column number is zero-based.\n   * @return {Object} The object returned has a \"file\" attribute for the\n   *   path of the output file associated with the given input file (where the\n   *   path is relative to the process's current working directory),\n   *   a \"line\" attribute of the line number in the output file associated with\n   *   the given line number for the input file, and an optional \"column\" number\n   *   of the column number of the output file associated with the given file\n   *   and line information.\n   *\n   *   If the given input file does not have mapping information associated\n   *   with it then the input location is returned.\n   */\n\n\n  mappingInfo(location) {\n    const inputPath = path.normalize(location.file);\n    const entry = this.getMappingInfo(inputPath);\n\n    if (entry === null) {\n      return location;\n    }\n\n    const generatedPos = {\n      line: location.line,\n      column: location.column\n    }; // TODO: Determine how to remove the explicit cast here.\n\n    const consumer = entry.mapConsumer;\n    const pos = consumer.originalPositionFor(generatedPos);\n\n    if (pos.source === null) {\n      return location;\n    }\n\n    return {\n      file: path.resolve(entry.mapFileDir, pos.source),\n      line: pos.line || undefined,\n      name: pos.name || location.name,\n      column: pos.column || undefined\n    };\n  }\n\n}\n\nexports.SourceMapper = SourceMapper;\n\nasync function createFromMapFiles(mapFiles) {\n  const limit = pLimit(CONCURRENCY);\n  const mapper = new SourceMapper();\n  const promises = mapFiles.map(mapPath => limit(() => processSourceMap(mapper.infoMap, mapPath)));\n\n  try {\n    await Promise.all(promises);\n  } catch (err) {\n    throw new Error('An error occurred while processing the source map files' + err);\n  }\n\n  return mapper;\n}\n\nasync function getMapFiles(baseDir) {\n  const fileStats = await scanner.scan(false, baseDir, /.js.map$/);\n  const mapFiles = fileStats.selectFiles(/.js.map$/, process.cwd());\n  return mapFiles;\n}","map":{"version":3,"mappings":"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","names":["desc","Object","getOwnPropertyDescriptor","globalThis","fetch","defineProperty","pify","require","pLimit","readFile","fs","CONCURRENCY","MAP_EXT","processSourceMap","infoMap","mapPath","endsWith","Error","path","normalize","contents","e","consumer","sourceMap","SourceMapConsumer","dir","dirname","generatedBase","file","basename","generatedPath","resolve","set","mapFileDir","mapConsumer","SourceMapper","constructor","Map","create","searchDirs","mapFiles","mf","getMapFiles","forEach","mapFile","push","createFromMapFiles","getMappingInfo","inputPath","has","get","hasMappingInfo","mappingInfo","location","entry","generatedPos","line","column","pos","originalPositionFor","source","undefined","name","exports","limit","mapper","promises","map","Promise","all","err","baseDir","fileStats","scanner","scan","selectFiles","process","cwd"],"sources":["../../../ts/src/sourcemapper/sourcemapper.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}