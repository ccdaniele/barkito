{"ast":null,"code":"'use strict';\n\nconst log = require('../../log');\n\nconst addresses = require('../addresses');\n\nconst Gateway = require('../gateway/engine');\n\nconst Reporter = require('../reporter');\n\nconst validAddressSet = new Set(Object.values(addresses)); // TODO: put reusable code in a base class\n\nclass WAFCallback {\n  static loadDDWAF(rules, config) {\n    try {\n      // require in `try/catch` because this can throw at require time\n      const {\n        DDWAF\n      } = require('@datadog/native-appsec');\n\n      return new DDWAF(rules, config);\n    } catch (err) {\n      log.error('AppSec could not load native package. In-app WAF features will not be available.');\n      throw err;\n    }\n  }\n\n  constructor(rules, config) {\n    const {\n      wafTimeout,\n      obfuscatorKeyRegex,\n      obfuscatorValueRegex\n    } = config;\n    this.ddwaf = WAFCallback.loadDDWAF(rules, {\n      obfuscatorKeyRegex,\n      obfuscatorValueRegex\n    });\n    this.wafTimeout = wafTimeout;\n    const version = this.ddwaf.constructor.version();\n    Reporter.metricsQueue.set('_dd.appsec.waf.version', `${version.major}.${version.minor}.${version.patch}`);\n    const {\n      loaded,\n      failed,\n      errors\n    } = this.ddwaf.rulesInfo;\n    Reporter.metricsQueue.set('_dd.appsec.event_rules.loaded', loaded);\n    Reporter.metricsQueue.set('_dd.appsec.event_rules.error_count', failed);\n    if (failed) Reporter.metricsQueue.set('_dd.appsec.event_rules.errors', JSON.stringify(errors));\n    Reporter.metricsQueue.set('manual.keep', true);\n    this.wafContextCache = new WeakMap(); // closures are faster than binds\n\n    const self = this;\n\n    const method = (params, store) => {\n      return self.action(params, store);\n    }; // might be its own class with more info later\n\n\n    const callback = {\n      method\n    };\n    const subscribedAddresses = new Set();\n\n    for (const rule of rules.rules) {\n      for (const condition of rule.conditions) {\n        for (const input of condition.parameters.inputs) {\n          const address = input.address.split(':', 2)[0];\n          if (!validAddressSet.has(address) || subscribedAddresses.has(address)) continue;\n          subscribedAddresses.add(address);\n          Gateway.manager.addSubscription({\n            addresses: [address],\n            callback\n          });\n        }\n      }\n    }\n  }\n\n  action(params, store) {\n    let wafContext;\n\n    if (store) {\n      const key = store.get('context');\n\n      if (key) {\n        if (this.wafContextCache.has(key)) {\n          wafContext = this.wafContextCache.get(key);\n        } else {\n          wafContext = this.ddwaf.createContext();\n          this.wafContextCache.set(key, wafContext);\n        }\n      }\n    }\n\n    if (!wafContext || wafContext.disposed) {\n      wafContext = this.ddwaf.createContext();\n    } // cast status code to string\n\n\n    if (params[addresses.HTTP_INCOMING_RESPONSE_CODE]) {\n      params[addresses.HTTP_INCOMING_RESPONSE_CODE] = params[addresses.HTTP_INCOMING_RESPONSE_CODE] + '';\n    }\n\n    try {\n      // TODO: possible optimizaion: only send params that haven't already been sent to this wafContext\n      const start = process.hrtime.bigint();\n      const result = wafContext.run(params, this.wafTimeout);\n      result.durationExt = parseInt(process.hrtime.bigint() - start);\n      return this.applyResult(result, store);\n    } catch (err) {\n      log.error('Error while running the AppSec WAF');\n      log.error(err);\n    } finally {\n      wafContext.dispose();\n    }\n  }\n\n  applyResult(result, store) {\n    Reporter.reportMetrics({\n      duration: result.totalRuntime / 1e3,\n      durationExt: result.durationExt / 1e3,\n      rulesVersion: this.ddwaf.rulesInfo.version\n    }, store);\n\n    if (result.data && result.data !== '[]') {\n      Reporter.reportAttack(result.data, store);\n    }\n  }\n\n  clear() {\n    this.ddwaf.dispose();\n    this.wafContextCache = new WeakMap();\n    Gateway.manager.clear();\n  }\n\n}\n\nmodule.exports = WAFCallback;","map":{"version":3,"names":["log","require","addresses","Gateway","Reporter","validAddressSet","Set","Object","values","WAFCallback","loadDDWAF","rules","config","DDWAF","err","error","constructor","wafTimeout","obfuscatorKeyRegex","obfuscatorValueRegex","ddwaf","version","metricsQueue","set","major","minor","patch","loaded","failed","errors","rulesInfo","JSON","stringify","wafContextCache","WeakMap","self","method","params","store","action","callback","subscribedAddresses","rule","condition","conditions","input","parameters","inputs","address","split","has","add","manager","addSubscription","wafContext","key","get","createContext","disposed","HTTP_INCOMING_RESPONSE_CODE","start","process","hrtime","bigint","result","run","durationExt","parseInt","applyResult","dispose","reportMetrics","duration","totalRuntime","rulesVersion","data","reportAttack","clear","module","exports"],"sources":["/Users/daniel.calderon/Projects/barkito/barkito_front/node_modules/dd-trace/packages/dd-trace/src/appsec/callbacks/ddwaf.js"],"sourcesContent":["'use strict'\n\nconst log = require('../../log')\nconst addresses = require('../addresses')\nconst Gateway = require('../gateway/engine')\nconst Reporter = require('../reporter')\n\nconst validAddressSet = new Set(Object.values(addresses))\n\n// TODO: put reusable code in a base class\nclass WAFCallback {\n  static loadDDWAF (rules, config) {\n    try {\n      // require in `try/catch` because this can throw at require time\n      const { DDWAF } = require('@datadog/native-appsec')\n\n      return new DDWAF(rules, config)\n    } catch (err) {\n      log.error('AppSec could not load native package. In-app WAF features will not be available.')\n\n      throw err\n    }\n  }\n\n  constructor (rules, config) {\n    const { wafTimeout, obfuscatorKeyRegex, obfuscatorValueRegex } = config\n\n    this.ddwaf = WAFCallback.loadDDWAF(rules, { obfuscatorKeyRegex, obfuscatorValueRegex })\n\n    this.wafTimeout = wafTimeout\n\n    const version = this.ddwaf.constructor.version()\n\n    Reporter.metricsQueue.set('_dd.appsec.waf.version', `${version.major}.${version.minor}.${version.patch}`)\n\n    const { loaded, failed, errors } = this.ddwaf.rulesInfo\n\n    Reporter.metricsQueue.set('_dd.appsec.event_rules.loaded', loaded)\n    Reporter.metricsQueue.set('_dd.appsec.event_rules.error_count', failed)\n    if (failed) Reporter.metricsQueue.set('_dd.appsec.event_rules.errors', JSON.stringify(errors))\n\n    Reporter.metricsQueue.set('manual.keep', true)\n\n    this.wafContextCache = new WeakMap()\n\n    // closures are faster than binds\n    const self = this\n    const method = (params, store) => {\n      return self.action(params, store)\n    }\n\n    // might be its own class with more info later\n    const callback = { method }\n\n    const subscribedAddresses = new Set()\n\n    for (const rule of rules.rules) {\n      for (const condition of rule.conditions) {\n        for (const input of condition.parameters.inputs) {\n          const address = input.address.split(':', 2)[0]\n\n          if (!validAddressSet.has(address) || subscribedAddresses.has(address)) continue\n\n          subscribedAddresses.add(address)\n\n          Gateway.manager.addSubscription({ addresses: [ address ], callback })\n        }\n      }\n    }\n  }\n\n  action (params, store) {\n    let wafContext\n\n    if (store) {\n      const key = store.get('context')\n\n      if (key) {\n        if (this.wafContextCache.has(key)) {\n          wafContext = this.wafContextCache.get(key)\n        } else {\n          wafContext = this.ddwaf.createContext()\n          this.wafContextCache.set(key, wafContext)\n        }\n      }\n    }\n\n    if (!wafContext || wafContext.disposed) {\n      wafContext = this.ddwaf.createContext()\n    }\n\n    // cast status code to string\n    if (params[addresses.HTTP_INCOMING_RESPONSE_CODE]) {\n      params[addresses.HTTP_INCOMING_RESPONSE_CODE] = params[addresses.HTTP_INCOMING_RESPONSE_CODE] + ''\n    }\n\n    try {\n      // TODO: possible optimizaion: only send params that haven't already been sent to this wafContext\n      const start = process.hrtime.bigint()\n\n      const result = wafContext.run(params, this.wafTimeout)\n\n      result.durationExt = parseInt(process.hrtime.bigint() - start)\n\n      return this.applyResult(result, store)\n    } catch (err) {\n      log.error('Error while running the AppSec WAF')\n      log.error(err)\n    } finally {\n      wafContext.dispose()\n    }\n  }\n\n  applyResult (result, store) {\n    Reporter.reportMetrics({\n      duration: result.totalRuntime / 1e3,\n      durationExt: result.durationExt / 1e3,\n      rulesVersion: this.ddwaf.rulesInfo.version\n    }, store)\n\n    if (result.data && result.data !== '[]') {\n      Reporter.reportAttack(result.data, store)\n    }\n  }\n\n  clear () {\n    this.ddwaf.dispose()\n\n    this.wafContextCache = new WeakMap()\n\n    Gateway.manager.clear()\n  }\n}\n\nmodule.exports = WAFCallback\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}