{"ast":null,"code":"'use strict';\n\nconst path = require('path');\n\nconst Module = require('module');\n\nconst parse = require('module-details-from-path');\n\nconst dc = require('diagnostics_channel');\n\nconst origRequire = Module.prototype.require; // derived from require-in-the-middle@3 with tweaks\n\nmodule.exports = Hook;\nlet moduleHooks = Object.create(null);\nlet cache = Object.create(null);\nlet patching = Object.create(null);\nlet patchedRequire = null;\nconst moduleLoadStartChannel = dc.channel('dd-trace:moduleLoadStart');\n\nfunction Hook(modules, options, onrequire) {\n  if (!(this instanceof Hook)) return new Hook(modules, options, onrequire);\n\n  if (typeof modules === 'function') {\n    onrequire = modules;\n    modules = null;\n    options = {};\n  } else if (typeof options === 'function') {\n    onrequire = options;\n    options = {};\n  }\n\n  modules = modules || [];\n  options = options || {};\n  this.modules = modules;\n  this.options = options;\n  this.onrequire = onrequire;\n\n  if (Array.isArray(modules)) {\n    for (const mod of modules) {\n      const hooks = moduleHooks[mod];\n\n      if (hooks) {\n        hooks.push(onrequire);\n      } else {\n        moduleHooks[mod] = [onrequire];\n      }\n    }\n  }\n\n  if (patchedRequire) return;\n\n  patchedRequire = Module.prototype.require = function (request) {\n    const filename = Module._resolveFilename(request, this);\n\n    const core = filename.indexOf(path.sep) === -1;\n    let name, basedir, hooks; // return known patched modules immediately\n\n    if (cache[filename]) {\n      // require.cache was potentially altered externally\n      if (require.cache[filename] && require.cache[filename].exports !== cache[filename].original) {\n        return require.cache[filename].exports;\n      }\n\n      return cache[filename].exports;\n    } // Check if this module has a patcher in-progress already.\n    // Otherwise, mark this module as patching in-progress.\n\n\n    const patched = patching[filename];\n\n    if (!patched) {\n      patching[filename] = true;\n    }\n\n    const exports = origRequire.apply(this, arguments); // If it's already patched, just return it as-is.\n\n    if (patched) return exports; // The module has already been loaded,\n    // so the patching mark can be cleaned up.\n\n    delete patching[filename];\n\n    if (moduleLoadStartChannel.hasSubscribers) {\n      moduleLoadStartChannel.publish({\n        filename,\n        module: exports,\n        request\n      });\n    }\n\n    if (core) {\n      hooks = moduleHooks[filename];\n      if (!hooks) return exports; // abort if module name isn't on whitelist\n\n      name = filename;\n    } else {\n      const stat = parse(filename);\n      if (!stat) return exports; // abort if filename could not be parsed\n\n      name = stat.name;\n      basedir = stat.basedir;\n      hooks = moduleHooks[name];\n      if (!hooks) return exports; // abort if module name isn't on whitelist\n      // figure out if this is the main module file, or a file inside the module\n\n      const paths = Module._resolveLookupPaths(name, this, true);\n\n      if (!paths) {\n        // abort if _resolveLookupPaths return null\n        return exports;\n      }\n\n      const res = Module._findPath(name, [basedir, ...paths]);\n\n      if (res !== filename) {\n        // this is a module-internal file\n        // use the module-relative path to the file, prefixed by original module name\n        name = name + path.sep + path.relative(basedir, filename);\n      }\n    } // ensure that the cache entry is assigned a value before calling\n    // onrequire, in case calling onrequire requires the same module.\n\n\n    cache[filename] = {\n      exports\n    };\n    cache[filename].original = exports;\n\n    for (const hook of hooks) {\n      cache[filename].exports = hook(cache[filename].exports, name, basedir);\n    }\n\n    return cache[filename].exports;\n  };\n}\n\nHook.reset = function () {\n  Module.prototype.require = origRequire;\n  patchedRequire = null;\n  patching = Object.create(null);\n  cache = Object.create(null);\n  moduleHooks = Object.create(null);\n};\n\nHook.prototype.unhook = function () {\n  for (const mod of this.modules) {\n    const hooks = (moduleHooks[mod] || []).filter(hook => hook !== this.onrequire);\n\n    if (hooks.length > 0) {\n      moduleHooks[mod] = hooks;\n    } else {\n      delete moduleHooks[mod];\n    }\n  }\n\n  if (Object.keys(moduleHooks).length === 0) {\n    Hook.reset();\n  }\n};","map":{"version":3,"names":["path","require","Module","parse","dc","origRequire","prototype","module","exports","Hook","moduleHooks","Object","create","cache","patching","patchedRequire","moduleLoadStartChannel","channel","modules","options","onrequire","Array","isArray","mod","hooks","push","request","filename","_resolveFilename","core","indexOf","sep","name","basedir","original","patched","apply","arguments","hasSubscribers","publish","stat","paths","_resolveLookupPaths","res","_findPath","relative","hook","reset","unhook","filter","length","keys"],"sources":["/Users/daniel.calderon/Projects/barkito/barkito_front/node_modules/dd-trace/packages/dd-trace/src/ritm.js"],"sourcesContent":["'use strict'\n\nconst path = require('path')\nconst Module = require('module')\nconst parse = require('module-details-from-path')\nconst dc = require('diagnostics_channel')\n\nconst origRequire = Module.prototype.require\n\n// derived from require-in-the-middle@3 with tweaks\n\nmodule.exports = Hook\n\nlet moduleHooks = Object.create(null)\nlet cache = Object.create(null)\nlet patching = Object.create(null)\nlet patchedRequire = null\nconst moduleLoadStartChannel = dc.channel('dd-trace:moduleLoadStart')\nfunction Hook (modules, options, onrequire) {\n  if (!(this instanceof Hook)) return new Hook(modules, options, onrequire)\n  if (typeof modules === 'function') {\n    onrequire = modules\n    modules = null\n    options = {}\n  } else if (typeof options === 'function') {\n    onrequire = options\n    options = {}\n  }\n\n  modules = modules || []\n  options = options || {}\n\n  this.modules = modules\n  this.options = options\n  this.onrequire = onrequire\n\n  if (Array.isArray(modules)) {\n    for (const mod of modules) {\n      const hooks = moduleHooks[mod]\n\n      if (hooks) {\n        hooks.push(onrequire)\n      } else {\n        moduleHooks[mod] = [onrequire]\n      }\n    }\n  }\n\n  if (patchedRequire) return\n\n  patchedRequire = Module.prototype.require = function (request) {\n    const filename = Module._resolveFilename(request, this)\n    const core = filename.indexOf(path.sep) === -1\n    let name, basedir, hooks\n\n    // return known patched modules immediately\n    if (cache[filename]) {\n      // require.cache was potentially altered externally\n      if (require.cache[filename] && require.cache[filename].exports !== cache[filename].original) {\n        return require.cache[filename].exports\n      }\n\n      return cache[filename].exports\n    }\n\n    // Check if this module has a patcher in-progress already.\n    // Otherwise, mark this module as patching in-progress.\n    const patched = patching[filename]\n    if (!patched) {\n      patching[filename] = true\n    }\n\n    const exports = origRequire.apply(this, arguments)\n\n    // If it's already patched, just return it as-is.\n    if (patched) return exports\n\n    // The module has already been loaded,\n    // so the patching mark can be cleaned up.\n    delete patching[filename]\n\n    if (moduleLoadStartChannel.hasSubscribers) {\n      moduleLoadStartChannel.publish({\n        filename,\n        module: exports,\n        request\n      })\n    }\n\n    if (core) {\n      hooks = moduleHooks[filename]\n      if (!hooks) return exports // abort if module name isn't on whitelist\n      name = filename\n    } else {\n      const stat = parse(filename)\n      if (!stat) return exports // abort if filename could not be parsed\n      name = stat.name\n      basedir = stat.basedir\n\n      hooks = moduleHooks[name]\n      if (!hooks) return exports // abort if module name isn't on whitelist\n\n      // figure out if this is the main module file, or a file inside the module\n      const paths = Module._resolveLookupPaths(name, this, true)\n      if (!paths) {\n        // abort if _resolveLookupPaths return null\n        return exports\n      }\n      const res = Module._findPath(name, [basedir, ...paths])\n      if (res !== filename) {\n        // this is a module-internal file\n        // use the module-relative path to the file, prefixed by original module name\n        name = name + path.sep + path.relative(basedir, filename)\n      }\n    }\n\n    // ensure that the cache entry is assigned a value before calling\n    // onrequire, in case calling onrequire requires the same module.\n    cache[filename] = { exports }\n    cache[filename].original = exports\n\n    for (const hook of hooks) {\n      cache[filename].exports = hook(cache[filename].exports, name, basedir)\n    }\n\n    return cache[filename].exports\n  }\n}\n\nHook.reset = function () {\n  Module.prototype.require = origRequire\n  patchedRequire = null\n  patching = Object.create(null)\n  cache = Object.create(null)\n  moduleHooks = Object.create(null)\n}\n\nHook.prototype.unhook = function () {\n  for (const mod of this.modules) {\n    const hooks = (moduleHooks[mod] || []).filter(hook => hook !== this.onrequire)\n\n    if (hooks.length > 0) {\n      moduleHooks[mod] = hooks\n    } else {\n      delete moduleHooks[mod]\n    }\n  }\n\n  if (Object.keys(moduleHooks).length === 0) {\n    Hook.reset()\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}