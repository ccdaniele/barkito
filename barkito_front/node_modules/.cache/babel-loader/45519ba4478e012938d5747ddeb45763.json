{"ast":null,"code":"\"use strict\";\n/*\n * Unless explicitly stated otherwise all files in this repository are licensed\n * under the Apache 2.0 license (see LICENSE).\n * This product includes software developed at Datadog (https://www.datadoghq.com/).\n * Copyright 2020 Datadog, Inc.\n */\n\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DenseStore = void 0;\n\nvar util_1 = require(\"./util\");\n/** The default number of bins to grow when necessary */\n\n\nvar CHUNK_SIZE = 128;\n/**\n * `DenseStore` is a store that keeps all the bins between\n * the bin for the `minKey` and the `maxKey`.\n */\n\nvar DenseStore =\n/** @class */\nfunction () {\n  /**\n   * Initialize a new DenseStore\n   *\n   * @param chunkSize The number of bins to add each time the bins grow (default 128)\n   */\n  function DenseStore(chunkSize) {\n    if (chunkSize === void 0) {\n      chunkSize = CHUNK_SIZE;\n    }\n\n    this.chunkSize = chunkSize;\n    this.bins = [];\n    this.count = 0;\n    this.minKey = Infinity;\n    this.maxKey = -Infinity;\n    this.offset = 0;\n  }\n  /**\n   * Update the counter at the specified index key, growing the number of bins if necessary\n   *\n   * @param key The key of the index to update\n   * @param weight The amount to weight the key (default 1.0)\n   */\n\n\n  DenseStore.prototype.add = function (key, weight) {\n    if (weight === void 0) {\n      weight = 1;\n    }\n\n    var index = this._getIndex(key);\n\n    this.bins[index] += weight;\n    this.count += weight;\n  };\n  /**\n   * Return the key for the value at the given rank\n   *\n   * E.g., if the non-zero bins are [1, 1] for keys a, b with no offset\n   *\n   * if lower = True:\n   *     keyAtRank(x) = a for x in [0, 1)\n   *     keyAtRank(x) = b for x in [1, 2)\n   * if lower = False:\n   *     keyAtRank(x) = a for x in (-1, 0]\n   *     keyAtRank(x) = b for x in (0, 1]\n   *\n   * @param rank The rank at which to retrieve the key\n   */\n\n\n  DenseStore.prototype.keyAtRank = function (rank, lower) {\n    if (lower === void 0) {\n      lower = true;\n    }\n\n    var runningCount = 0;\n\n    for (var i = 0; i < this.length(); i++) {\n      var bin = this.bins[i];\n      runningCount += bin;\n\n      if (lower && runningCount > rank || !lower && runningCount >= rank + 1) {\n        return i + this.offset;\n      }\n    }\n\n    return this.maxKey;\n  };\n  /**\n   * Merge the contents of the parameter `store` into this store\n   *\n   * @param store The store to merge into the caller store\n   */\n\n\n  DenseStore.prototype.merge = function (store) {\n    if (store.count === 0) {\n      return;\n    }\n\n    if (this.count === 0) {\n      this.copy(store);\n      return;\n    }\n\n    if (store.minKey < this.minKey || store.maxKey > this.maxKey) {\n      this._extendRange(store.minKey, store.maxKey);\n    }\n\n    var collapseStartIndex = store.minKey - store.offset;\n    var collapseEndIndex = Math.min(this.minKey, store.maxKey + 1) - store.offset;\n\n    if (collapseEndIndex > collapseStartIndex) {\n      var collapseCount = (0, util_1.sumOfRange)(store.bins, collapseStartIndex, collapseEndIndex);\n      this.bins[0] += collapseCount;\n    } else {\n      collapseEndIndex = collapseStartIndex;\n    }\n\n    for (var key = collapseEndIndex + store.offset; key < store.maxKey + 1; key++) {\n      this.bins[key - this.offset] += store.bins[key - store.offset];\n    }\n\n    this.count += store.count;\n  };\n  /**\n   * Directly clone the contents of the parameter `store` into this store\n   *\n   * @param store The store to be copied into the caller store\n   */\n\n\n  DenseStore.prototype.copy = function (store) {\n    this.bins = __spreadArray([], store.bins, true);\n    this.count = store.count;\n    this.minKey = store.minKey;\n    this.maxKey = store.maxKey;\n    this.offset = store.offset;\n  };\n  /**\n   * Return the length of the underlying storage (`bins`)\n   */\n\n\n  DenseStore.prototype.length = function () {\n    return this.bins.length;\n  };\n\n  DenseStore.prototype._getNewLength = function (newMinKey, newMaxKey) {\n    var desiredLength = newMaxKey - newMinKey + 1;\n    return this.chunkSize * Math.ceil(desiredLength / this.chunkSize);\n  };\n  /**\n   * Adjust the `bins`, the `offset`, the `minKey`, and the `maxKey`\n   * without resizing the bins, in order to try to make it fit the specified range.\n   * Collapse to the left if necessary\n   */\n\n\n  DenseStore.prototype._adjust = function (newMinKey, newMaxKey) {\n    this._centerBins(newMinKey, newMaxKey);\n\n    this.minKey = newMinKey;\n    this.maxKey = newMaxKey;\n  };\n  /** Shift the bins by `shift`. This changes the `offset` */\n\n\n  DenseStore.prototype._shiftBins = function (shift) {\n    var _a, _b;\n\n    if (shift > 0) {\n      this.bins = this.bins.slice(0, -shift);\n\n      (_a = this.bins).unshift.apply(_a, new Array(shift).fill(0));\n    } else {\n      this.bins = this.bins.slice(Math.abs(shift));\n\n      (_b = this.bins).push.apply(_b, new Array(Math.abs(shift)).fill(0));\n    }\n\n    this.offset -= shift;\n  };\n  /** Center the bins. This changes the `offset` */\n\n\n  DenseStore.prototype._centerBins = function (newMinKey, newMaxKey) {\n    var middleKey = newMinKey + Math.floor((newMaxKey - newMinKey + 1) / 2);\n\n    this._shiftBins(Math.floor(this.offset + this.length() / 2) - middleKey);\n  };\n  /** Grow the bins as necessary, and call _adjust */\n\n\n  DenseStore.prototype._extendRange = function (key, secondKey) {\n    var _a;\n\n    secondKey = secondKey || key;\n    var newMinKey = Math.min(key, secondKey, this.minKey);\n    var newMaxKey = Math.max(key, secondKey, this.maxKey);\n\n    if (this.length() === 0) {\n      this.bins = new Array(this._getNewLength(newMinKey, newMaxKey)).fill(0);\n      this.offset = newMinKey;\n\n      this._adjust(newMinKey, newMaxKey);\n    } else if (newMinKey >= this.minKey && newMaxKey < this.offset + this.length()) {\n      // No need to change the range, just update the min and max keys\n      this.minKey = newMinKey;\n      this.maxKey = newMaxKey;\n    } else {\n      // Grow the bins\n      var newLength = this._getNewLength(newMinKey, newMaxKey);\n\n      if (newLength > this.length()) {\n        (_a = this.bins).push.apply(_a, new Array(newLength - this.length()).fill(0));\n      }\n\n      this._adjust(newMinKey, newMaxKey);\n    }\n  };\n  /** Calculate the bin index for the key, extending the range if necessary */\n\n\n  DenseStore.prototype._getIndex = function (key) {\n    if (key < this.minKey) {\n      this._extendRange(key);\n    } else if (key > this.maxKey) {\n      this._extendRange(key);\n    }\n\n    return key - this.offset;\n  };\n\n  DenseStore.prototype.toProto = function () {\n    var ProtoStore = require('../proto/compiled').Store;\n\n    return ProtoStore.create({\n      contiguousBinCounts: this.bins,\n      contiguousBinIndexOffset: this.offset\n    });\n  };\n\n  DenseStore.fromProto = function (protoStore) {\n    if (!protoStore ||\n    /* Double equals (==) is intentional here to check for\n     * `null` | `undefined` without including `0` */\n    protoStore.contiguousBinCounts == null || protoStore.contiguousBinIndexOffset == null) {\n      throw Error('Failed to decode store from protobuf');\n    }\n\n    var store = new this();\n    var index = protoStore.contiguousBinIndexOffset;\n    store.offset = index;\n\n    for (var _i = 0, _a = protoStore.contiguousBinCounts; _i < _a.length; _i++) {\n      var count = _a[_i];\n      store.add(index, count);\n      index += 1;\n    }\n\n    return store;\n  };\n\n  return DenseStore;\n}();\n\nexports.DenseStore = DenseStore;","map":{"version":3,"names":["__spreadArray","to","from","pack","arguments","length","i","l","ar","Array","prototype","slice","call","concat","Object","defineProperty","exports","value","DenseStore","util_1","require","CHUNK_SIZE","chunkSize","bins","count","minKey","Infinity","maxKey","offset","add","key","weight","index","_getIndex","keyAtRank","rank","lower","runningCount","bin","merge","store","copy","_extendRange","collapseStartIndex","collapseEndIndex","Math","min","collapseCount","sumOfRange","_getNewLength","newMinKey","newMaxKey","desiredLength","ceil","_adjust","_centerBins","_shiftBins","shift","_a","_b","unshift","apply","fill","abs","push","middleKey","floor","secondKey","max","newLength","toProto","ProtoStore","Store","create","contiguousBinCounts","contiguousBinIndexOffset","fromProto","protoStore","Error","_i"],"sources":["/Users/daniel.calderon/Projects/barkito/barkito_front/node_modules/@datadog/sketches-js/dist/ddsketch/store/DenseStore.js"],"sourcesContent":["\"use strict\";\n/*\n * Unless explicitly stated otherwise all files in this repository are licensed\n * under the Apache 2.0 license (see LICENSE).\n * This product includes software developed at Datadog (https://www.datadoghq.com/).\n * Copyright 2020 Datadog, Inc.\n */\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DenseStore = void 0;\nvar util_1 = require(\"./util\");\n/** The default number of bins to grow when necessary */\nvar CHUNK_SIZE = 128;\n/**\n * `DenseStore` is a store that keeps all the bins between\n * the bin for the `minKey` and the `maxKey`.\n */\nvar DenseStore = /** @class */ (function () {\n    /**\n     * Initialize a new DenseStore\n     *\n     * @param chunkSize The number of bins to add each time the bins grow (default 128)\n     */\n    function DenseStore(chunkSize) {\n        if (chunkSize === void 0) { chunkSize = CHUNK_SIZE; }\n        this.chunkSize = chunkSize;\n        this.bins = [];\n        this.count = 0;\n        this.minKey = Infinity;\n        this.maxKey = -Infinity;\n        this.offset = 0;\n    }\n    /**\n     * Update the counter at the specified index key, growing the number of bins if necessary\n     *\n     * @param key The key of the index to update\n     * @param weight The amount to weight the key (default 1.0)\n     */\n    DenseStore.prototype.add = function (key, weight) {\n        if (weight === void 0) { weight = 1; }\n        var index = this._getIndex(key);\n        this.bins[index] += weight;\n        this.count += weight;\n    };\n    /**\n     * Return the key for the value at the given rank\n     *\n     * E.g., if the non-zero bins are [1, 1] for keys a, b with no offset\n     *\n     * if lower = True:\n     *     keyAtRank(x) = a for x in [0, 1)\n     *     keyAtRank(x) = b for x in [1, 2)\n     * if lower = False:\n     *     keyAtRank(x) = a for x in (-1, 0]\n     *     keyAtRank(x) = b for x in (0, 1]\n     *\n     * @param rank The rank at which to retrieve the key\n     */\n    DenseStore.prototype.keyAtRank = function (rank, lower) {\n        if (lower === void 0) { lower = true; }\n        var runningCount = 0;\n        for (var i = 0; i < this.length(); i++) {\n            var bin = this.bins[i];\n            runningCount += bin;\n            if ((lower && runningCount > rank) ||\n                (!lower && runningCount >= rank + 1)) {\n                return i + this.offset;\n            }\n        }\n        return this.maxKey;\n    };\n    /**\n     * Merge the contents of the parameter `store` into this store\n     *\n     * @param store The store to merge into the caller store\n     */\n    DenseStore.prototype.merge = function (store) {\n        if (store.count === 0) {\n            return;\n        }\n        if (this.count === 0) {\n            this.copy(store);\n            return;\n        }\n        if (store.minKey < this.minKey || store.maxKey > this.maxKey) {\n            this._extendRange(store.minKey, store.maxKey);\n        }\n        var collapseStartIndex = store.minKey - store.offset;\n        var collapseEndIndex = Math.min(this.minKey, store.maxKey + 1) - store.offset;\n        if (collapseEndIndex > collapseStartIndex) {\n            var collapseCount = (0, util_1.sumOfRange)(store.bins, collapseStartIndex, collapseEndIndex);\n            this.bins[0] += collapseCount;\n        }\n        else {\n            collapseEndIndex = collapseStartIndex;\n        }\n        for (var key = collapseEndIndex + store.offset; key < store.maxKey + 1; key++) {\n            this.bins[key - this.offset] += store.bins[key - store.offset];\n        }\n        this.count += store.count;\n    };\n    /**\n     * Directly clone the contents of the parameter `store` into this store\n     *\n     * @param store The store to be copied into the caller store\n     */\n    DenseStore.prototype.copy = function (store) {\n        this.bins = __spreadArray([], store.bins, true);\n        this.count = store.count;\n        this.minKey = store.minKey;\n        this.maxKey = store.maxKey;\n        this.offset = store.offset;\n    };\n    /**\n     * Return the length of the underlying storage (`bins`)\n     */\n    DenseStore.prototype.length = function () {\n        return this.bins.length;\n    };\n    DenseStore.prototype._getNewLength = function (newMinKey, newMaxKey) {\n        var desiredLength = newMaxKey - newMinKey + 1;\n        return this.chunkSize * Math.ceil(desiredLength / this.chunkSize);\n    };\n    /**\n     * Adjust the `bins`, the `offset`, the `minKey`, and the `maxKey`\n     * without resizing the bins, in order to try to make it fit the specified range.\n     * Collapse to the left if necessary\n     */\n    DenseStore.prototype._adjust = function (newMinKey, newMaxKey) {\n        this._centerBins(newMinKey, newMaxKey);\n        this.minKey = newMinKey;\n        this.maxKey = newMaxKey;\n    };\n    /** Shift the bins by `shift`. This changes the `offset` */\n    DenseStore.prototype._shiftBins = function (shift) {\n        var _a, _b;\n        if (shift > 0) {\n            this.bins = this.bins.slice(0, -shift);\n            (_a = this.bins).unshift.apply(_a, new Array(shift).fill(0));\n        }\n        else {\n            this.bins = this.bins.slice(Math.abs(shift));\n            (_b = this.bins).push.apply(_b, new Array(Math.abs(shift)).fill(0));\n        }\n        this.offset -= shift;\n    };\n    /** Center the bins. This changes the `offset` */\n    DenseStore.prototype._centerBins = function (newMinKey, newMaxKey) {\n        var middleKey = newMinKey + Math.floor((newMaxKey - newMinKey + 1) / 2);\n        this._shiftBins(Math.floor(this.offset + this.length() / 2) - middleKey);\n    };\n    /** Grow the bins as necessary, and call _adjust */\n    DenseStore.prototype._extendRange = function (key, secondKey) {\n        var _a;\n        secondKey = secondKey || key;\n        var newMinKey = Math.min(key, secondKey, this.minKey);\n        var newMaxKey = Math.max(key, secondKey, this.maxKey);\n        if (this.length() === 0) {\n            this.bins = new Array(this._getNewLength(newMinKey, newMaxKey)).fill(0);\n            this.offset = newMinKey;\n            this._adjust(newMinKey, newMaxKey);\n        }\n        else if (newMinKey >= this.minKey &&\n            newMaxKey < this.offset + this.length()) {\n            // No need to change the range, just update the min and max keys\n            this.minKey = newMinKey;\n            this.maxKey = newMaxKey;\n        }\n        else {\n            // Grow the bins\n            var newLength = this._getNewLength(newMinKey, newMaxKey);\n            if (newLength > this.length()) {\n                (_a = this.bins).push.apply(_a, new Array(newLength - this.length()).fill(0));\n            }\n            this._adjust(newMinKey, newMaxKey);\n        }\n    };\n    /** Calculate the bin index for the key, extending the range if necessary */\n    DenseStore.prototype._getIndex = function (key) {\n        if (key < this.minKey) {\n            this._extendRange(key);\n        }\n        else if (key > this.maxKey) {\n            this._extendRange(key);\n        }\n        return key - this.offset;\n    };\n    DenseStore.prototype.toProto = function () {\n        var ProtoStore = require('../proto/compiled').Store;\n        return ProtoStore.create({\n            contiguousBinCounts: this.bins,\n            contiguousBinIndexOffset: this.offset\n        });\n    };\n    DenseStore.fromProto = function (protoStore) {\n        if (!protoStore ||\n            /* Double equals (==) is intentional here to check for\n             * `null` | `undefined` without including `0` */\n            protoStore.contiguousBinCounts == null ||\n            protoStore.contiguousBinIndexOffset == null) {\n            throw Error('Failed to decode store from protobuf');\n        }\n        var store = new this();\n        var index = protoStore.contiguousBinIndexOffset;\n        store.offset = index;\n        for (var _i = 0, _a = protoStore.contiguousBinCounts; _i < _a.length; _i++) {\n            var count = _a[_i];\n            store.add(index, count);\n            index += 1;\n        }\n        return store;\n    };\n    return DenseStore;\n}());\nexports.DenseStore = DenseStore;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}