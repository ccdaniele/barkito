{"ast":null,"code":"'use strict';\n\nconst {\n  addHook,\n  channel,\n  AsyncResource\n} = require('./helpers/instrument');\n\nconst shimmer = require('../../datadog-shimmer');\n/** cached objects */\n\n\nconst contexts = new WeakMap();\nconst documentSources = new WeakMap();\nconst patchedResolvers = new WeakSet();\nconst patchedTypes = new WeakSet();\n/** CHANNELS */\n// execute channels\n\nconst startExecuteCh = channel('apm:graphql:execute:start');\nconst finishExecuteCh = channel('apm:graphql:execute:finish');\nconst executeErrorCh = channel('apm:graphql:execute:error'); // resolve channels\n\nconst startResolveCh = channel('apm:graphql:resolve:start');\nconst finishResolveCh = channel('apm:graphql:resolve:finish');\nconst updateFieldCh = channel('apm:graphql:resolve:updateField');\nconst resolveErrorCh = channel('apm:graphql:resolve:error'); // parse channels\n\nconst parseStartCh = channel('apm:graphql:parser:start');\nconst parseFinishCh = channel('apm:graphql:parser:finish');\nconst parseErrorCh = channel('apm:graphql:parser:error'); // validate channels\n\nconst validateStartCh = channel('apm:graphql:validate:start');\nconst validateFinishCh = channel('apm:graphql:validate:finish');\nconst validateErrorCh = channel('apm:graphql:validate:error');\n\nfunction getOperation(document, operationName) {\n  if (!document || !Array.isArray(document.definitions)) {\n    return;\n  }\n\n  const definitions = document.definitions.filter(def => def);\n  const types = ['query', 'mutation', 'subscription'];\n\n  if (operationName) {\n    return definitions.filter(def => types.indexOf(def.operation) !== -1).find(def => operationName === (def.name && def.name.value));\n  } else {\n    return definitions.find(def => types.indexOf(def.operation) !== -1);\n  }\n}\n\nfunction normalizeArgs(args, defaultFieldResolver) {\n  if (args.length !== 1) return normalizePositional(args, defaultFieldResolver);\n  args[0].contextValue = args[0].contextValue || {};\n  args[0].fieldResolver = wrapResolve(args[0].fieldResolver || defaultFieldResolver);\n  return args[0];\n}\n\nfunction normalizePositional(args, defaultFieldResolver) {\n  args[3] = args[3] || {}; // contextValue\n\n  args[6] = wrapResolve(args[6] || defaultFieldResolver); // fieldResolver\n\n  args.length = Math.max(args.length, 7);\n  return {\n    schema: args[0],\n    document: args[1],\n    rootValue: args[2],\n    contextValue: args[3],\n    variableValues: args[4],\n    operationName: args[5],\n    fieldResolver: args[6]\n  };\n}\n\nfunction wrapParse(parse) {\n  return function (source) {\n    if (!parseStartCh.hasSubscribers) {\n      return parse.apply(this, arguments);\n    }\n\n    const asyncResource = new AsyncResource('bound-anonymous-fn');\n    return asyncResource.runInAsyncScope(() => {\n      parseStartCh.publish();\n      let document;\n\n      try {\n        document = parse.apply(this, arguments);\n        const operation = getOperation(document);\n        if (!operation) return document;\n\n        if (source) {\n          documentSources.set(document, source.body || source);\n        }\n\n        return document;\n      } catch (err) {\n        err.stack;\n        parseErrorCh.publish(err);\n        throw err;\n      } finally {\n        parseFinishCh.publish({\n          source,\n          document,\n          docSource: documentSources.get(document)\n        });\n      }\n    });\n  };\n}\n\nfunction wrapValidate(validate) {\n  return function (_schema, document, _rules, _typeInfo) {\n    if (!validateStartCh.hasSubscribers) {\n      return validate.apply(this, arguments);\n    }\n\n    const asyncResource = new AsyncResource('bound-anonymous-fn');\n    return asyncResource.runInAsyncScope(() => {\n      validateStartCh.publish({\n        docSource: documentSources.get(document),\n        document\n      });\n      let errors;\n\n      try {\n        errors = validate.apply(this, arguments);\n\n        if (errors && errors[0]) {\n          validateErrorCh.publish(errors && errors[0]);\n        }\n\n        return errors;\n      } catch (err) {\n        err.stack;\n        validateErrorCh.publish(err);\n        throw err;\n      } finally {\n        validateFinishCh.publish({\n          document,\n          errors\n        });\n      }\n    });\n  };\n}\n\nfunction wrapExecute(execute) {\n  return function (exe) {\n    const defaultFieldResolver = execute.defaultFieldResolver;\n    return function () {\n      if (!startExecuteCh.hasSubscribers) {\n        return exe.apply(this, arguments);\n      }\n\n      const asyncResource = new AsyncResource('bound-anonymous-fn');\n      return asyncResource.runInAsyncScope(() => {\n        const args = normalizeArgs(arguments, defaultFieldResolver);\n        const schema = args.schema;\n        const document = args.document;\n        const source = documentSources.get(document);\n        const contextValue = args.contextValue;\n        const operation = getOperation(document, args.operationName);\n\n        if (contexts.has(contextValue)) {\n          return exe.apply(this, arguments);\n        }\n\n        if (schema) {\n          wrapFields(schema._queryType);\n          wrapFields(schema._mutationType);\n        }\n\n        startExecuteCh.publish({\n          operation,\n          args,\n          docSource: documentSources.get(document)\n        });\n        const context = {\n          source,\n          asyncResource,\n          fields: {}\n        };\n        contexts.set(contextValue, context);\n        return callInAsyncScope(exe, asyncResource, this, arguments, (err, res) => {\n          if (finishResolveCh.hasSubscribers) finishResolvers(context);\n          const error = err || res && res.errors && res.errors[0];\n\n          if (error) {\n            executeErrorCh.publish(error);\n          }\n\n          finishExecuteCh.publish({\n            res,\n            args\n          });\n        });\n      });\n    };\n  };\n}\n\nfunction wrapResolve(resolve) {\n  if (typeof resolve !== 'function' || patchedResolvers.has(resolve)) return resolve;\n\n  function resolveAsync(source, args, contextValue, info) {\n    if (!startResolveCh.hasSubscribers) return resolve.apply(this, arguments);\n    const context = contexts.get(contextValue);\n    if (!context) return resolve.apply(this, arguments);\n    const field = assertField(context, info);\n    return callInAsyncScope(resolve, field.asyncResource, this, arguments, err => {\n      updateFieldCh.publish({\n        field,\n        info,\n        err\n      });\n    });\n  }\n\n  patchedResolvers.add(resolveAsync);\n  return resolveAsync;\n}\n\nfunction callInAsyncScope(fn, aR, thisArg, args, cb) {\n  cb = cb || (() => {});\n\n  return aR.runInAsyncScope(() => {\n    try {\n      const result = fn.apply(thisArg, args);\n\n      if (result && typeof result.then === 'function') {\n        // bind callback to this scope\n        result.then(aR.bind(res => cb(null, res)), aR.bind(err => cb(err)));\n      } else {\n        cb(null, result);\n      }\n\n      return result;\n    } catch (err) {\n      cb(err);\n      throw err;\n    }\n  });\n}\n\nfunction pathToArray(path) {\n  const flattened = [];\n  let curr = path;\n\n  while (curr) {\n    flattened.push(curr.key);\n    curr = curr.prev;\n  }\n\n  return flattened.reverse();\n}\n\nfunction assertField(context, info) {\n  const pathInfo = info && info.path;\n  const path = pathToArray(pathInfo);\n  const pathString = path.join('.');\n  const fields = context.fields;\n  let field = fields[pathString];\n\n  if (!field) {\n    const parent = getParentField(context, path); // we want to spawn the new span off of the parent, not a new async resource\n\n    parent.asyncResource.runInAsyncScope(() => {\n      /* this child resource will run a branched scope off of the parent resource, which\n      accesses the parent span from the storage unit in its own scope */\n      const childResource = new AsyncResource('bound-anonymous-fn');\n      childResource.runInAsyncScope(() => {\n        startResolveCh.publish({\n          info,\n          context\n        });\n      });\n      field = fields[pathString] = {\n        parent,\n        asyncResource: childResource,\n        error: null\n      };\n    });\n  }\n\n  return field;\n}\n\nfunction getParentField(context, path) {\n  for (let i = path.length - 1; i > 0; i--) {\n    const field = getField(context, path.slice(0, i));\n\n    if (field) {\n      return field;\n    }\n  }\n\n  return {\n    asyncResource: context.asyncResource\n  };\n}\n\nfunction getField(context, path) {\n  return context.fields[path.join('.')];\n}\n\nfunction wrapFields(type) {\n  if (!type || !type._fields || patchedTypes.has(type)) {\n    return;\n  }\n\n  patchedTypes.add(type);\n  Object.keys(type._fields).forEach(key => {\n    const field = type._fields[key];\n    wrapFieldResolve(field);\n    wrapFieldType(field);\n  });\n}\n\nfunction wrapFieldResolve(field) {\n  if (!field || !field.resolve) return;\n  field.resolve = wrapResolve(field.resolve);\n}\n\nfunction wrapFieldType(field) {\n  if (!field || !field.type) return;\n  let unwrappedType = field.type;\n\n  while (unwrappedType.ofType) {\n    unwrappedType = unwrappedType.ofType;\n  }\n\n  wrapFields(unwrappedType);\n}\n\nfunction finishResolvers(_ref) {\n  let {\n    fields\n  } = _ref;\n  Object.keys(fields).reverse().forEach(key => {\n    const field = fields[key];\n    const asyncResource = field.asyncResource;\n    asyncResource.runInAsyncScope(() => {\n      if (field.error) {\n        resolveErrorCh.publish(field.error);\n      }\n\n      finishResolveCh.publish(field.finishTime);\n    });\n  });\n}\n\naddHook({\n  name: 'graphql',\n  file: 'execution/execute.js',\n  versions: ['>=0.10']\n}, execute => {\n  shimmer.wrap(execute, 'execute', wrapExecute(execute));\n  return execute;\n});\naddHook({\n  name: 'graphql',\n  file: 'language/parser.js',\n  versions: ['>=0.10']\n}, parser => {\n  shimmer.wrap(parser, 'parse', wrapParse);\n  return parser;\n});\naddHook({\n  name: 'graphql',\n  file: 'validation/validate.js',\n  versions: ['>=0.10']\n}, validate => {\n  shimmer.wrap(validate, 'validate', wrapValidate);\n  return validate;\n});","map":{"version":3,"names":["addHook","channel","AsyncResource","require","shimmer","contexts","WeakMap","documentSources","patchedResolvers","WeakSet","patchedTypes","startExecuteCh","finishExecuteCh","executeErrorCh","startResolveCh","finishResolveCh","updateFieldCh","resolveErrorCh","parseStartCh","parseFinishCh","parseErrorCh","validateStartCh","validateFinishCh","validateErrorCh","getOperation","document","operationName","Array","isArray","definitions","filter","def","types","indexOf","operation","find","name","value","normalizeArgs","args","defaultFieldResolver","length","normalizePositional","contextValue","fieldResolver","wrapResolve","Math","max","schema","rootValue","variableValues","wrapParse","parse","source","hasSubscribers","apply","arguments","asyncResource","runInAsyncScope","publish","set","body","err","stack","docSource","get","wrapValidate","validate","_schema","_rules","_typeInfo","errors","wrapExecute","execute","exe","has","wrapFields","_queryType","_mutationType","context","fields","callInAsyncScope","res","finishResolvers","error","resolve","resolveAsync","info","field","assertField","add","fn","aR","thisArg","cb","result","then","bind","pathToArray","path","flattened","curr","push","key","prev","reverse","pathInfo","pathString","join","parent","getParentField","childResource","i","getField","slice","type","_fields","Object","keys","forEach","wrapFieldResolve","wrapFieldType","unwrappedType","ofType","finishTime","file","versions","wrap","parser"],"sources":["/Users/daniel.calderon/Projects/barkito/barkito_front/node_modules/dd-trace/packages/datadog-instrumentations/src/graphql.js"],"sourcesContent":["'use strict'\n\nconst {\n  addHook,\n  channel,\n  AsyncResource\n} = require('./helpers/instrument')\nconst shimmer = require('../../datadog-shimmer')\n\n/** cached objects */\n\nconst contexts = new WeakMap()\nconst documentSources = new WeakMap()\nconst patchedResolvers = new WeakSet()\nconst patchedTypes = new WeakSet()\n\n/** CHANNELS */\n\n// execute channels\nconst startExecuteCh = channel('apm:graphql:execute:start')\nconst finishExecuteCh = channel('apm:graphql:execute:finish')\nconst executeErrorCh = channel('apm:graphql:execute:error')\n\n// resolve channels\nconst startResolveCh = channel('apm:graphql:resolve:start')\nconst finishResolveCh = channel('apm:graphql:resolve:finish')\nconst updateFieldCh = channel('apm:graphql:resolve:updateField')\nconst resolveErrorCh = channel('apm:graphql:resolve:error')\n\n// parse channels\nconst parseStartCh = channel('apm:graphql:parser:start')\nconst parseFinishCh = channel('apm:graphql:parser:finish')\nconst parseErrorCh = channel('apm:graphql:parser:error')\n\n// validate channels\nconst validateStartCh = channel('apm:graphql:validate:start')\nconst validateFinishCh = channel('apm:graphql:validate:finish')\nconst validateErrorCh = channel('apm:graphql:validate:error')\n\nfunction getOperation (document, operationName) {\n  if (!document || !Array.isArray(document.definitions)) {\n    return\n  }\n\n  const definitions = document.definitions.filter(def => def)\n  const types = ['query', 'mutation', 'subscription']\n\n  if (operationName) {\n    return definitions\n      .filter(def => types.indexOf(def.operation) !== -1)\n      .find(def => operationName === (def.name && def.name.value))\n  } else {\n    return definitions.find(def => types.indexOf(def.operation) !== -1)\n  }\n}\n\nfunction normalizeArgs (args, defaultFieldResolver) {\n  if (args.length !== 1) return normalizePositional(args, defaultFieldResolver)\n\n  args[0].contextValue = args[0].contextValue || {}\n  args[0].fieldResolver = wrapResolve(args[0].fieldResolver || defaultFieldResolver)\n\n  return args[0]\n}\n\nfunction normalizePositional (args, defaultFieldResolver) {\n  args[3] = args[3] || {} // contextValue\n  args[6] = wrapResolve(args[6] || defaultFieldResolver) // fieldResolver\n  args.length = Math.max(args.length, 7)\n\n  return {\n    schema: args[0],\n    document: args[1],\n    rootValue: args[2],\n    contextValue: args[3],\n    variableValues: args[4],\n    operationName: args[5],\n    fieldResolver: args[6]\n  }\n}\n\nfunction wrapParse (parse) {\n  return function (source) {\n    if (!parseStartCh.hasSubscribers) {\n      return parse.apply(this, arguments)\n    }\n\n    const asyncResource = new AsyncResource('bound-anonymous-fn')\n\n    return asyncResource.runInAsyncScope(() => {\n      parseStartCh.publish()\n      let document\n      try {\n        document = parse.apply(this, arguments)\n        const operation = getOperation(document)\n\n        if (!operation) return document\n\n        if (source) {\n          documentSources.set(document, source.body || source)\n        }\n\n        return document\n      } catch (err) {\n        err.stack\n        parseErrorCh.publish(err)\n\n        throw err\n      } finally {\n        parseFinishCh.publish({ source, document, docSource: documentSources.get(document) })\n      }\n    })\n  }\n}\n\nfunction wrapValidate (validate) {\n  return function (_schema, document, _rules, _typeInfo) {\n    if (!validateStartCh.hasSubscribers) {\n      return validate.apply(this, arguments)\n    }\n\n    const asyncResource = new AsyncResource('bound-anonymous-fn')\n\n    return asyncResource.runInAsyncScope(() => {\n      validateStartCh.publish({ docSource: documentSources.get(document), document })\n\n      let errors\n      try {\n        errors = validate.apply(this, arguments)\n        if (errors && errors[0]) {\n          validateErrorCh.publish(errors && errors[0])\n        }\n        return errors\n      } catch (err) {\n        err.stack\n        validateErrorCh.publish(err)\n\n        throw err\n      } finally {\n        validateFinishCh.publish({ document, errors })\n      }\n    })\n  }\n}\n\nfunction wrapExecute (execute) {\n  return function (exe) {\n    const defaultFieldResolver = execute.defaultFieldResolver\n    return function () {\n      if (!startExecuteCh.hasSubscribers) {\n        return exe.apply(this, arguments)\n      }\n\n      const asyncResource = new AsyncResource('bound-anonymous-fn')\n      return asyncResource.runInAsyncScope(() => {\n        const args = normalizeArgs(arguments, defaultFieldResolver)\n        const schema = args.schema\n        const document = args.document\n        const source = documentSources.get(document)\n        const contextValue = args.contextValue\n        const operation = getOperation(document, args.operationName)\n\n        if (contexts.has(contextValue)) {\n          return exe.apply(this, arguments)\n        }\n\n        if (schema) {\n          wrapFields(schema._queryType)\n          wrapFields(schema._mutationType)\n        }\n\n        startExecuteCh.publish({\n          operation,\n          args,\n          docSource: documentSources.get(document)\n        })\n\n        const context = { source, asyncResource, fields: {} }\n\n        contexts.set(contextValue, context)\n\n        return callInAsyncScope(exe, asyncResource, this, arguments, (err, res) => {\n          if (finishResolveCh.hasSubscribers) finishResolvers(context)\n\n          const error = err || (res && res.errors && res.errors[0])\n\n          if (error) {\n            executeErrorCh.publish(error)\n          }\n\n          finishExecuteCh.publish({ res, args })\n        })\n      })\n    }\n  }\n}\n\nfunction wrapResolve (resolve) {\n  if (typeof resolve !== 'function' || patchedResolvers.has(resolve)) return resolve\n\n  function resolveAsync (source, args, contextValue, info) {\n    if (!startResolveCh.hasSubscribers) return resolve.apply(this, arguments)\n\n    const context = contexts.get(contextValue)\n\n    if (!context) return resolve.apply(this, arguments)\n\n    const field = assertField(context, info)\n\n    return callInAsyncScope(resolve, field.asyncResource, this, arguments, (err) => {\n      updateFieldCh.publish({ field, info, err })\n    })\n  }\n\n  patchedResolvers.add(resolveAsync)\n\n  return resolveAsync\n}\n\nfunction callInAsyncScope (fn, aR, thisArg, args, cb) {\n  cb = cb || (() => {})\n\n  return aR.runInAsyncScope(() => {\n    try {\n      const result = fn.apply(thisArg, args)\n      if (result && typeof result.then === 'function') {\n        // bind callback to this scope\n        result.then(\n          aR.bind(res => cb(null, res)),\n          aR.bind(err => cb(err))\n        )\n      } else {\n        cb(null, result)\n      }\n      return result\n    } catch (err) {\n      cb(err)\n      throw err\n    }\n  })\n}\n\nfunction pathToArray (path) {\n  const flattened = []\n  let curr = path\n  while (curr) {\n    flattened.push(curr.key)\n    curr = curr.prev\n  }\n  return flattened.reverse()\n}\n\nfunction assertField (context, info) {\n  const pathInfo = info && info.path\n\n  const path = pathToArray(pathInfo)\n\n  const pathString = path.join('.')\n  const fields = context.fields\n\n  let field = fields[pathString]\n\n  if (!field) {\n    const parent = getParentField(context, path)\n\n    // we want to spawn the new span off of the parent, not a new async resource\n    parent.asyncResource.runInAsyncScope(() => {\n      /* this child resource will run a branched scope off of the parent resource, which\n      accesses the parent span from the storage unit in its own scope */\n      const childResource = new AsyncResource('bound-anonymous-fn')\n\n      childResource.runInAsyncScope(() => {\n        startResolveCh.publish({\n          info,\n          context\n        })\n      })\n\n      field = fields[pathString] = {\n        parent,\n        asyncResource: childResource,\n        error: null\n      }\n    })\n  }\n\n  return field\n}\n\nfunction getParentField (context, path) {\n  for (let i = path.length - 1; i > 0; i--) {\n    const field = getField(context, path.slice(0, i))\n    if (field) {\n      return field\n    }\n  }\n\n  return {\n    asyncResource: context.asyncResource\n  }\n}\n\nfunction getField (context, path) {\n  return context.fields[path.join('.')]\n}\n\nfunction wrapFields (type) {\n  if (!type || !type._fields || patchedTypes.has(type)) {\n    return\n  }\n\n  patchedTypes.add(type)\n\n  Object.keys(type._fields).forEach(key => {\n    const field = type._fields[key]\n\n    wrapFieldResolve(field)\n    wrapFieldType(field)\n  })\n}\n\nfunction wrapFieldResolve (field) {\n  if (!field || !field.resolve) return\n  field.resolve = wrapResolve(field.resolve)\n}\n\nfunction wrapFieldType (field) {\n  if (!field || !field.type) return\n\n  let unwrappedType = field.type\n\n  while (unwrappedType.ofType) {\n    unwrappedType = unwrappedType.ofType\n  }\n\n  wrapFields(unwrappedType)\n}\n\nfunction finishResolvers ({ fields }) {\n  Object.keys(fields).reverse().forEach(key => {\n    const field = fields[key]\n    const asyncResource = field.asyncResource\n    asyncResource.runInAsyncScope(() => {\n      if (field.error) {\n        resolveErrorCh.publish(field.error)\n      }\n      finishResolveCh.publish(field.finishTime)\n    })\n  })\n}\n\naddHook({ name: 'graphql', file: 'execution/execute.js', versions: ['>=0.10'] }, execute => {\n  shimmer.wrap(execute, 'execute', wrapExecute(execute))\n  return execute\n})\n\naddHook({ name: 'graphql', file: 'language/parser.js', versions: ['>=0.10'] }, parser => {\n  shimmer.wrap(parser, 'parse', wrapParse)\n  return parser\n})\n\naddHook({ name: 'graphql', file: 'validation/validate.js', versions: ['>=0.10'] }, validate => {\n  shimmer.wrap(validate, 'validate', wrapValidate)\n\n  return validate\n})\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}