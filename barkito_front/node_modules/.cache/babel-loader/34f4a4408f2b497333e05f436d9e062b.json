{"ast":null,"code":"\"use strict\";\n/*\n * Unless explicitly stated otherwise all files in this repository are licensed\n * under the Apache 2.0 license (see LICENSE).\n * This product includes software developed at Datadog (https://www.datadoghq.com/).\n * Copyright 2020 Datadog, Inc.\n */\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CollapsingLowestDenseStore = void 0;\n\nvar DenseStore_1 = require(\"./DenseStore\");\n\nvar util_1 = require(\"./util\");\n/**\n * `CollapsingLowestDenseStore` is a dense store that keeps all the bins between\n * the bin for the `minKey` and the `maxKey`, but collapsing the left-most bins\n * if the number of bins exceeds `binLimit`\n */\n\n\nvar CollapsingLowestDenseStore =\n/** @class */\nfunction (_super) {\n  __extends(CollapsingLowestDenseStore, _super);\n  /**\n   * Initialize a new CollapsingLowestDenseStore\n   *\n   * @param binLimit The maximum number of bins\n   * @param chunkSize The number of bins to add each time the bins grow (default 128)\n   */\n\n\n  function CollapsingLowestDenseStore(binLimit, chunkSize) {\n    var _this = _super.call(this, chunkSize) || this;\n\n    _this.binLimit = binLimit;\n    _this.isCollapsed = false;\n    return _this;\n  }\n  /**\n   * Merge the contents of the parameter `store` into this store\n   *\n   * @param store The store to merge into the caller store\n   */\n\n\n  CollapsingLowestDenseStore.prototype.merge = function (store) {\n    if (store.count === 0) {\n      return;\n    }\n\n    if (this.count === 0) {\n      this.copy(store);\n      return;\n    }\n\n    if (store.minKey < this.minKey || store.maxKey > this.maxKey) {\n      this._extendRange(store.minKey, store.maxKey);\n    }\n\n    var collapseStartIndex = store.minKey - store.offset;\n    var collapseEndIndex = Math.min(this.minKey, store.maxKey + 1) - store.offset;\n\n    if (collapseEndIndex > collapseStartIndex) {\n      var collapseCount = (0, util_1.sumOfRange)(store.bins, collapseStartIndex, collapseEndIndex);\n      this.bins[0] += collapseCount;\n    } else {\n      collapseEndIndex = collapseStartIndex;\n    }\n\n    for (var key = collapseEndIndex + store.offset; key < store.maxKey + 1; key++) {\n      this.bins[key - this.offset] += store.bins[key - store.offset];\n    }\n\n    this.count += store.count;\n  };\n  /**\n   * Directly clone the contents of the parameter `store` into this store\n   *\n   * @param store The store to be copied into the caller store\n   */\n\n\n  CollapsingLowestDenseStore.prototype.copy = function (store) {\n    _super.prototype.copy.call(this, store);\n\n    this.isCollapsed = store.isCollapsed;\n  };\n\n  CollapsingLowestDenseStore.prototype._getNewLength = function (newMinKey, newMaxKey) {\n    var desiredLength = newMaxKey - newMinKey + 1;\n    return Math.min(this.chunkSize * Math.ceil(desiredLength / this.chunkSize), this.binLimit);\n  };\n  /**\n   * Adjust the `bins`, the `offset`, the `minKey`, and the `maxKey`\n   * without resizing the bins, in order to try to make it fit the specified range.\n   * Collapse to the left if necessary\n   */\n\n\n  CollapsingLowestDenseStore.prototype._adjust = function (newMinKey, newMaxKey) {\n    if (newMaxKey - newMinKey + 1 > this.length()) {\n      // The range of keys is too wide, the lowest bins need to be collapsed\n      newMinKey = newMaxKey - this.length() + 1;\n\n      if (newMinKey >= this.maxKey) {\n        // Put everything in the first bin\n        this.offset = newMinKey;\n        this.minKey = newMinKey;\n        this.bins.fill(0);\n        this.bins[0] = this.count;\n      } else {\n        var shift = this.offset - newMinKey;\n\n        if (shift < 0) {\n          var collapseStartIndex = this.minKey - this.offset;\n          var collapseEndIndex = newMinKey - this.offset;\n          var collapsedCount = (0, util_1.sumOfRange)(this.bins, collapseStartIndex, collapseEndIndex);\n          this.bins.fill(0, collapseStartIndex, collapseEndIndex);\n          this.bins[collapseEndIndex] += collapsedCount;\n          this.minKey = newMinKey;\n\n          this._shiftBins(shift);\n        } else {\n          this.minKey = newMinKey; // Shift the buckets to make room for newMinKey\n\n          this._shiftBins(shift);\n        }\n      }\n\n      this.maxKey = newMaxKey;\n      this.isCollapsed = true;\n    } else {\n      this._centerBins(newMinKey, newMaxKey);\n\n      this.minKey = newMinKey;\n      this.maxKey = newMaxKey;\n    }\n  };\n  /** Calculate the bin index for the key, extending the range if necessary */\n\n\n  CollapsingLowestDenseStore.prototype._getIndex = function (key) {\n    if (key < this.minKey) {\n      if (this.isCollapsed) {\n        return 0;\n      }\n\n      this._extendRange(key);\n\n      if (this.isCollapsed) {\n        return 0;\n      }\n    } else if (key > this.maxKey) {\n      this._extendRange(key);\n    }\n\n    return key - this.offset;\n  };\n\n  return CollapsingLowestDenseStore;\n}(DenseStore_1.DenseStore);\n\nexports.CollapsingLowestDenseStore = CollapsingLowestDenseStore;","map":{"version":3,"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","defineProperty","exports","value","CollapsingLowestDenseStore","DenseStore_1","require","util_1","_super","binLimit","chunkSize","_this","isCollapsed","merge","store","count","copy","minKey","maxKey","_extendRange","collapseStartIndex","offset","collapseEndIndex","Math","min","collapseCount","sumOfRange","bins","key","_getNewLength","newMinKey","newMaxKey","desiredLength","ceil","_adjust","length","fill","shift","collapsedCount","_shiftBins","_centerBins","_getIndex","DenseStore"],"sources":["/Users/daniel.calderon/Projects/barkito/barkito_front/node_modules/@datadog/sketches-js/dist/ddsketch/store/CollapsingLowestDenseStore.js"],"sourcesContent":["\"use strict\";\n/*\n * Unless explicitly stated otherwise all files in this repository are licensed\n * under the Apache 2.0 license (see LICENSE).\n * This product includes software developed at Datadog (https://www.datadoghq.com/).\n * Copyright 2020 Datadog, Inc.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CollapsingLowestDenseStore = void 0;\nvar DenseStore_1 = require(\"./DenseStore\");\nvar util_1 = require(\"./util\");\n/**\n * `CollapsingLowestDenseStore` is a dense store that keeps all the bins between\n * the bin for the `minKey` and the `maxKey`, but collapsing the left-most bins\n * if the number of bins exceeds `binLimit`\n */\nvar CollapsingLowestDenseStore = /** @class */ (function (_super) {\n    __extends(CollapsingLowestDenseStore, _super);\n    /**\n     * Initialize a new CollapsingLowestDenseStore\n     *\n     * @param binLimit The maximum number of bins\n     * @param chunkSize The number of bins to add each time the bins grow (default 128)\n     */\n    function CollapsingLowestDenseStore(binLimit, chunkSize) {\n        var _this = _super.call(this, chunkSize) || this;\n        _this.binLimit = binLimit;\n        _this.isCollapsed = false;\n        return _this;\n    }\n    /**\n     * Merge the contents of the parameter `store` into this store\n     *\n     * @param store The store to merge into the caller store\n     */\n    CollapsingLowestDenseStore.prototype.merge = function (store) {\n        if (store.count === 0) {\n            return;\n        }\n        if (this.count === 0) {\n            this.copy(store);\n            return;\n        }\n        if (store.minKey < this.minKey || store.maxKey > this.maxKey) {\n            this._extendRange(store.minKey, store.maxKey);\n        }\n        var collapseStartIndex = store.minKey - store.offset;\n        var collapseEndIndex = Math.min(this.minKey, store.maxKey + 1) - store.offset;\n        if (collapseEndIndex > collapseStartIndex) {\n            var collapseCount = (0, util_1.sumOfRange)(store.bins, collapseStartIndex, collapseEndIndex);\n            this.bins[0] += collapseCount;\n        }\n        else {\n            collapseEndIndex = collapseStartIndex;\n        }\n        for (var key = collapseEndIndex + store.offset; key < store.maxKey + 1; key++) {\n            this.bins[key - this.offset] += store.bins[key - store.offset];\n        }\n        this.count += store.count;\n    };\n    /**\n     * Directly clone the contents of the parameter `store` into this store\n     *\n     * @param store The store to be copied into the caller store\n     */\n    CollapsingLowestDenseStore.prototype.copy = function (store) {\n        _super.prototype.copy.call(this, store);\n        this.isCollapsed = store.isCollapsed;\n    };\n    CollapsingLowestDenseStore.prototype._getNewLength = function (newMinKey, newMaxKey) {\n        var desiredLength = newMaxKey - newMinKey + 1;\n        return Math.min(this.chunkSize * Math.ceil(desiredLength / this.chunkSize), this.binLimit);\n    };\n    /**\n     * Adjust the `bins`, the `offset`, the `minKey`, and the `maxKey`\n     * without resizing the bins, in order to try to make it fit the specified range.\n     * Collapse to the left if necessary\n     */\n    CollapsingLowestDenseStore.prototype._adjust = function (newMinKey, newMaxKey) {\n        if (newMaxKey - newMinKey + 1 > this.length()) {\n            // The range of keys is too wide, the lowest bins need to be collapsed\n            newMinKey = newMaxKey - this.length() + 1;\n            if (newMinKey >= this.maxKey) {\n                // Put everything in the first bin\n                this.offset = newMinKey;\n                this.minKey = newMinKey;\n                this.bins.fill(0);\n                this.bins[0] = this.count;\n            }\n            else {\n                var shift = this.offset - newMinKey;\n                if (shift < 0) {\n                    var collapseStartIndex = this.minKey - this.offset;\n                    var collapseEndIndex = newMinKey - this.offset;\n                    var collapsedCount = (0, util_1.sumOfRange)(this.bins, collapseStartIndex, collapseEndIndex);\n                    this.bins.fill(0, collapseStartIndex, collapseEndIndex);\n                    this.bins[collapseEndIndex] += collapsedCount;\n                    this.minKey = newMinKey;\n                    this._shiftBins(shift);\n                }\n                else {\n                    this.minKey = newMinKey;\n                    // Shift the buckets to make room for newMinKey\n                    this._shiftBins(shift);\n                }\n            }\n            this.maxKey = newMaxKey;\n            this.isCollapsed = true;\n        }\n        else {\n            this._centerBins(newMinKey, newMaxKey);\n            this.minKey = newMinKey;\n            this.maxKey = newMaxKey;\n        }\n    };\n    /** Calculate the bin index for the key, extending the range if necessary */\n    CollapsingLowestDenseStore.prototype._getIndex = function (key) {\n        if (key < this.minKey) {\n            if (this.isCollapsed) {\n                return 0;\n            }\n            this._extendRange(key);\n            if (this.isCollapsed) {\n                return 0;\n            }\n        }\n        else if (key > this.maxKey) {\n            this._extendRange(key);\n        }\n        return key - this.offset;\n    };\n    return CollapsingLowestDenseStore;\n}(DenseStore_1.DenseStore));\nexports.CollapsingLowestDenseStore = CollapsingLowestDenseStore;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}