{"ast":null,"code":"'use strict';\n\nconst METHODS = require('methods').concat('all');\n\nconst pathToRegExp = require('path-to-regexp');\n\nconst shimmer = require('../../datadog-shimmer');\n\nconst {\n  addHook,\n  channel,\n  AsyncResource\n} = require('./helpers/instrument');\n\nfunction createWrapRouterMethod(name) {\n  const enterChannel = channel(`apm:${name}:middleware:enter`);\n  const exitChannel = channel(`apm:${name}:middleware:exit`);\n  const errorChannel = channel(`apm:${name}:middleware:error`);\n  const nextChannel = channel(`apm:${name}:middleware:next`);\n  const layerMatchers = new WeakMap();\n  const regexpCache = Object.create(null);\n\n  function wrapLayerHandle(layer, original) {\n    original._name = original._name || layer.name;\n    const handle = shimmer.wrap(original, function () {\n      if (!enterChannel.hasSubscribers) return original.apply(this, arguments);\n      const matchers = layerMatchers.get(layer);\n      const middlewareResource = new AsyncResource('bound-anonymous-fn');\n      const lastIndex = arguments.length - 1;\n      const name = original._name || original.name;\n      const req = arguments[arguments.length > 3 ? 1 : 0];\n      const next = arguments[lastIndex];\n\n      if (typeof next === 'function') {\n        arguments[lastIndex] = wrapNext(req, next);\n      }\n\n      return middlewareResource.runInAsyncScope(() => {\n        let route;\n\n        if (matchers) {\n          // Try to guess which path actually matched\n          for (let i = 0; i < matchers.length; i++) {\n            if (matchers[i].test(layer)) {\n              route = matchers[i].path;\n              break;\n            }\n          }\n        }\n\n        enterChannel.publish({\n          name,\n          req,\n          route\n        });\n\n        try {\n          return original.apply(this, arguments);\n        } catch (error) {\n          errorChannel.publish({\n            req,\n            error\n          });\n          nextChannel.publish({\n            req\n          });\n          exitChannel.publish({\n            req\n          });\n          throw error;\n        }\n      });\n    }); // This is a workaround for the `loopback` library so that it can find the correct express layer\n    // that contains the real handle function\n\n    handle._datadog_orig = original;\n    return handle;\n  }\n\n  function wrapStack(stack, offset, matchers) {\n    [].concat(stack).slice(offset).forEach(layer => {\n      if (layer.__handle) {\n        // express-async-errors\n        layer.__handle = wrapLayerHandle(layer, layer.__handle);\n      } else {\n        layer.handle = wrapLayerHandle(layer, layer.handle);\n      }\n\n      layerMatchers.set(layer, matchers);\n\n      if (layer.route) {\n        METHODS.forEach(method => {\n          if (typeof layer.route.stack === 'function') {\n            layer.route.stack = [{\n              handle: layer.route.stack\n            }];\n          }\n\n          layer.route[method] = wrapMethod(layer.route[method]);\n        });\n      }\n    });\n  }\n\n  function wrapNext(req, next) {\n    return function (error) {\n      if (error) {\n        errorChannel.publish({\n          req,\n          error\n        });\n      }\n\n      nextChannel.publish({\n        req\n      });\n      exitChannel.publish({\n        req\n      });\n      next.apply(this, arguments);\n    };\n  }\n\n  function extractMatchers(fn) {\n    const arg = flatten([].concat(fn));\n\n    if (typeof arg[0] === 'function') {\n      return [];\n    }\n\n    return arg.map(pattern => ({\n      path: pattern instanceof RegExp ? `(${pattern})` : pattern,\n      test: layer => {\n        const matchers = layerMatchers.get(layer);\n        return !isFastStar(layer, matchers) && !isFastSlash(layer, matchers) && cachedPathToRegExp(pattern).test(layer.path);\n      }\n    }));\n  }\n\n  function isFastStar(layer, matchers) {\n    if (layer.regexp.fast_star !== undefined) {\n      return layer.regexp.fast_star;\n    }\n\n    return matchers.some(matcher => matcher.path === '*');\n  }\n\n  function isFastSlash(layer, matchers) {\n    if (layer.regexp.fast_slash !== undefined) {\n      return layer.regexp.fast_slash;\n    }\n\n    return matchers.some(matcher => matcher.path === '/');\n  }\n\n  function flatten(arr) {\n    return arr.reduce((acc, val) => Array.isArray(val) ? acc.concat(flatten(val)) : acc.concat(val), []);\n  }\n\n  function cachedPathToRegExp(pattern) {\n    const maybeCached = regexpCache[pattern];\n\n    if (maybeCached) {\n      return maybeCached;\n    }\n\n    const regexp = pathToRegExp(pattern);\n    regexpCache[pattern] = regexp;\n    return regexp;\n  }\n\n  function wrapMethod(original) {\n    return function methodWithTrace(fn) {\n      const offset = this.stack ? [].concat(this.stack).length : 0;\n      const router = original.apply(this, arguments);\n\n      if (typeof this.stack === 'function') {\n        this.stack = [{\n          handle: this.stack\n        }];\n      }\n\n      wrapStack(this.stack, offset, extractMatchers(fn));\n      return router;\n    };\n  }\n\n  return wrapMethod;\n}\n\nconst wrapRouterMethod = createWrapRouterMethod('router');\naddHook({\n  name: 'router',\n  versions: ['>=1']\n}, Router => {\n  shimmer.wrap(Router.prototype, 'use', wrapRouterMethod);\n  shimmer.wrap(Router.prototype, 'route', wrapRouterMethod);\n  return Router;\n});\nmodule.exports = {\n  createWrapRouterMethod\n};","map":{"version":3,"names":["METHODS","require","concat","pathToRegExp","shimmer","addHook","channel","AsyncResource","createWrapRouterMethod","name","enterChannel","exitChannel","errorChannel","nextChannel","layerMatchers","WeakMap","regexpCache","Object","create","wrapLayerHandle","layer","original","_name","handle","wrap","hasSubscribers","apply","arguments","matchers","get","middlewareResource","lastIndex","length","req","next","wrapNext","runInAsyncScope","route","i","test","path","publish","error","_datadog_orig","wrapStack","stack","offset","slice","forEach","__handle","set","method","wrapMethod","extractMatchers","fn","arg","flatten","map","pattern","RegExp","isFastStar","isFastSlash","cachedPathToRegExp","regexp","fast_star","undefined","some","matcher","fast_slash","arr","reduce","acc","val","Array","isArray","maybeCached","methodWithTrace","router","wrapRouterMethod","versions","Router","prototype","module","exports"],"sources":["/Users/daniel.calderon/Projects/barkito/barkito_front/node_modules/dd-trace/packages/datadog-instrumentations/src/router.js"],"sourcesContent":["'use strict'\n\nconst METHODS = require('methods').concat('all')\nconst pathToRegExp = require('path-to-regexp')\nconst shimmer = require('../../datadog-shimmer')\nconst { addHook, channel, AsyncResource } = require('./helpers/instrument')\n\nfunction createWrapRouterMethod (name) {\n  const enterChannel = channel(`apm:${name}:middleware:enter`)\n  const exitChannel = channel(`apm:${name}:middleware:exit`)\n  const errorChannel = channel(`apm:${name}:middleware:error`)\n  const nextChannel = channel(`apm:${name}:middleware:next`)\n\n  const layerMatchers = new WeakMap()\n  const regexpCache = Object.create(null)\n\n  function wrapLayerHandle (layer, original) {\n    original._name = original._name || layer.name\n\n    const handle = shimmer.wrap(original, function () {\n      if (!enterChannel.hasSubscribers) return original.apply(this, arguments)\n\n      const matchers = layerMatchers.get(layer)\n      const middlewareResource = new AsyncResource('bound-anonymous-fn')\n      const lastIndex = arguments.length - 1\n      const name = original._name || original.name\n      const req = arguments[arguments.length > 3 ? 1 : 0]\n      const next = arguments[lastIndex]\n\n      if (typeof next === 'function') {\n        arguments[lastIndex] = wrapNext(req, next)\n      }\n\n      return middlewareResource.runInAsyncScope(() => {\n        let route\n\n        if (matchers) {\n          // Try to guess which path actually matched\n          for (let i = 0; i < matchers.length; i++) {\n            if (matchers[i].test(layer)) {\n              route = matchers[i].path\n\n              break\n            }\n          }\n        }\n\n        enterChannel.publish({ name, req, route })\n\n        try {\n          return original.apply(this, arguments)\n        } catch (error) {\n          errorChannel.publish({ req, error })\n          nextChannel.publish({ req })\n          exitChannel.publish({ req })\n\n          throw error\n        }\n      })\n    })\n\n    // This is a workaround for the `loopback` library so that it can find the correct express layer\n    // that contains the real handle function\n    handle._datadog_orig = original\n\n    return handle\n  }\n\n  function wrapStack (stack, offset, matchers) {\n    [].concat(stack).slice(offset).forEach(layer => {\n      if (layer.__handle) { // express-async-errors\n        layer.__handle = wrapLayerHandle(layer, layer.__handle)\n      } else {\n        layer.handle = wrapLayerHandle(layer, layer.handle)\n      }\n\n      layerMatchers.set(layer, matchers)\n\n      if (layer.route) {\n        METHODS.forEach(method => {\n          if (typeof layer.route.stack === 'function') {\n            layer.route.stack = [{ handle: layer.route.stack }]\n          }\n\n          layer.route[method] = wrapMethod(layer.route[method])\n        })\n      }\n    })\n  }\n\n  function wrapNext (req, next) {\n    return function (error) {\n      if (error) {\n        errorChannel.publish({ req, error })\n      }\n\n      nextChannel.publish({ req })\n      exitChannel.publish({ req })\n\n      next.apply(this, arguments)\n    }\n  }\n\n  function extractMatchers (fn) {\n    const arg = flatten([].concat(fn))\n\n    if (typeof arg[0] === 'function') {\n      return []\n    }\n\n    return arg.map(pattern => ({\n      path: pattern instanceof RegExp ? `(${pattern})` : pattern,\n      test: layer => {\n        const matchers = layerMatchers.get(layer)\n\n        return !isFastStar(layer, matchers) &&\n          !isFastSlash(layer, matchers) &&\n          cachedPathToRegExp(pattern).test(layer.path)\n      }\n    }))\n  }\n\n  function isFastStar (layer, matchers) {\n    if (layer.regexp.fast_star !== undefined) {\n      return layer.regexp.fast_star\n    }\n\n    return matchers.some(matcher => matcher.path === '*')\n  }\n\n  function isFastSlash (layer, matchers) {\n    if (layer.regexp.fast_slash !== undefined) {\n      return layer.regexp.fast_slash\n    }\n\n    return matchers.some(matcher => matcher.path === '/')\n  }\n\n  function flatten (arr) {\n    return arr.reduce((acc, val) => Array.isArray(val) ? acc.concat(flatten(val)) : acc.concat(val), [])\n  }\n\n  function cachedPathToRegExp (pattern) {\n    const maybeCached = regexpCache[pattern]\n    if (maybeCached) {\n      return maybeCached\n    }\n    const regexp = pathToRegExp(pattern)\n    regexpCache[pattern] = regexp\n    return regexp\n  }\n\n  function wrapMethod (original) {\n    return function methodWithTrace (fn) {\n      const offset = this.stack ? [].concat(this.stack).length : 0\n      const router = original.apply(this, arguments)\n\n      if (typeof this.stack === 'function') {\n        this.stack = [{ handle: this.stack }]\n      }\n\n      wrapStack(this.stack, offset, extractMatchers(fn))\n\n      return router\n    }\n  }\n\n  return wrapMethod\n}\n\nconst wrapRouterMethod = createWrapRouterMethod('router')\n\naddHook({ name: 'router', versions: ['>=1'] }, Router => {\n  shimmer.wrap(Router.prototype, 'use', wrapRouterMethod)\n  shimmer.wrap(Router.prototype, 'route', wrapRouterMethod)\n\n  return Router\n})\n\nmodule.exports = { createWrapRouterMethod }\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}