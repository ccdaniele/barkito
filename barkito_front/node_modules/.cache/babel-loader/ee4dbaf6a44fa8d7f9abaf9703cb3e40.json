{"ast":null,"code":"'use strict';\n\nconst Runner = require('./runner');\n\nconst MAX_CONTEXT_SIZE = 1024;\n\nclass SubscriptionManager {\n  constructor() {\n    this.addressToSubscriptions = new Map();\n    this.addresses = new Set();\n    this.subscriptions = new Set();\n  }\n\n  clear() {\n    this.addressToSubscriptions = new Map();\n    this.addresses = new Set();\n    this.subscriptions = new Set();\n  }\n\n  addSubscription(subscription) {\n    if (!subscription.addresses.length || this.subscriptions.has(subscription)) return;\n\n    for (let i = 0; i < subscription.addresses.length; ++i) {\n      const address = subscription.addresses[i];\n      this.addresses.add(address);\n      const list = this.addressToSubscriptions.get(address);\n\n      if (list === undefined) {\n        this.addressToSubscriptions.set(address, [subscription]);\n      } else {\n        list.push(subscription);\n      }\n    }\n\n    this.subscriptions.add(subscription);\n  }\n\n  matchSubscriptions(newAddresses, allAddresses) {\n    const addresses = new Set();\n    const subscriptions = new Set();\n    const knownSubscriptions = new Set(); // TODO: possible optimization: collect matchedSubscriptions on the fly in Context#setValue\n\n    newAddresses.forEach(newAddress => {\n      const matchedSubscriptions = this.addressToSubscriptions.get(newAddress);\n      if (matchedSubscriptions === undefined) return;\n\n      for (let j = 0; j < matchedSubscriptions.length; ++j) {\n        const subscription = matchedSubscriptions[j];\n        if (knownSubscriptions.has(subscription) === true) continue;\n        knownSubscriptions.add(subscription);\n        const isFulfilled = subscription.addresses.every(allAddresses.has, allAddresses);\n\n        if (isFulfilled === true) {\n          for (let k = 0; k < subscription.addresses.length; ++k) {\n            addresses.add(subscription.addresses[k]);\n          }\n\n          subscriptions.add(subscription);\n        }\n      }\n    });\n    return {\n      addresses,\n      subscriptions\n    };\n  }\n\n  dispatch(newAddresses, allAddresses, context) {\n    const matches = this.matchSubscriptions(newAddresses, allAddresses); // TODO: possible optimization\n    // check if matches.subscriptions is empty here instead of in runner.js\n\n    const params = {};\n    matches.addresses.forEach(address => {\n      params[address] = context.resolve(address);\n    });\n    return Runner.runSubscriptions(matches.subscriptions, params);\n  }\n\n}\n\nclass Context {\n  static setManager(manager) {\n    this.manager = manager;\n  }\n\n  constructor() {\n    // TODO: this probably don't need to be a Map()\n    this.store = new Map();\n    this.allAddresses = new Set();\n    this.newAddresses = new Set();\n  }\n\n  clear() {\n    this.store = new Map();\n    this.allAddresses = new Set();\n    this.newAddresses = new Set();\n  }\n\n  setValue(address, value) {\n    if (this.allAddresses.size >= MAX_CONTEXT_SIZE) return this; // cannot optimize for objects because they're pointers\n\n    if (typeof value !== 'object') {\n      const oldValue = this.store.get(address);\n      if (oldValue === value) return this;\n    }\n\n    this.store.set(address, value);\n    this.allAddresses.add(address);\n    this.newAddresses.add(address);\n    return this;\n  }\n\n  dispatch() {\n    if (this.newAddresses.size === 0) return [];\n    const result = Context.manager.dispatch(this.newAddresses, this.allAddresses, this);\n    this.newAddresses.clear();\n    return result;\n  }\n\n  resolve(address) {\n    return this.store.get(address);\n  }\n\n}\n\nmodule.exports = {\n  SubscriptionManager,\n  Context\n};","map":{"version":3,"names":["Runner","require","MAX_CONTEXT_SIZE","SubscriptionManager","constructor","addressToSubscriptions","Map","addresses","Set","subscriptions","clear","addSubscription","subscription","length","has","i","address","add","list","get","undefined","set","push","matchSubscriptions","newAddresses","allAddresses","knownSubscriptions","forEach","newAddress","matchedSubscriptions","j","isFulfilled","every","k","dispatch","context","matches","params","resolve","runSubscriptions","Context","setManager","manager","store","setValue","value","size","oldValue","result","module","exports"],"sources":["/Users/daniel.calderon/Projects/barkito/barkito_front/node_modules/dd-trace/packages/dd-trace/src/appsec/gateway/engine/engine.js"],"sourcesContent":["'use strict'\n\nconst Runner = require('./runner')\n\nconst MAX_CONTEXT_SIZE = 1024\n\nclass SubscriptionManager {\n  constructor () {\n    this.addressToSubscriptions = new Map()\n    this.addresses = new Set()\n    this.subscriptions = new Set()\n  }\n\n  clear () {\n    this.addressToSubscriptions = new Map()\n    this.addresses = new Set()\n    this.subscriptions = new Set()\n  }\n\n  addSubscription (subscription) {\n    if (!subscription.addresses.length || this.subscriptions.has(subscription)) return\n\n    for (let i = 0; i < subscription.addresses.length; ++i) {\n      const address = subscription.addresses[i]\n\n      this.addresses.add(address)\n\n      const list = this.addressToSubscriptions.get(address)\n\n      if (list === undefined) {\n        this.addressToSubscriptions.set(address, [ subscription ])\n      } else {\n        list.push(subscription)\n      }\n    }\n\n    this.subscriptions.add(subscription)\n  }\n\n  matchSubscriptions (newAddresses, allAddresses) {\n    const addresses = new Set()\n    const subscriptions = new Set()\n    const knownSubscriptions = new Set()\n\n    // TODO: possible optimization: collect matchedSubscriptions on the fly in Context#setValue\n    newAddresses.forEach((newAddress) => {\n      const matchedSubscriptions = this.addressToSubscriptions.get(newAddress)\n\n      if (matchedSubscriptions === undefined) return\n\n      for (let j = 0; j < matchedSubscriptions.length; ++j) {\n        const subscription = matchedSubscriptions[j]\n\n        if (knownSubscriptions.has(subscription) === true) continue\n        knownSubscriptions.add(subscription)\n\n        const isFulfilled = subscription.addresses.every(allAddresses.has, allAddresses)\n\n        if (isFulfilled === true) {\n          for (let k = 0; k < subscription.addresses.length; ++k) {\n            addresses.add(subscription.addresses[k])\n          }\n\n          subscriptions.add(subscription)\n        }\n      }\n    })\n\n    return { addresses, subscriptions }\n  }\n\n  dispatch (newAddresses, allAddresses, context) {\n    const matches = this.matchSubscriptions(newAddresses, allAddresses)\n\n    // TODO: possible optimization\n    // check if matches.subscriptions is empty here instead of in runner.js\n\n    const params = {}\n\n    matches.addresses.forEach((address) => {\n      params[address] = context.resolve(address)\n    })\n\n    return Runner.runSubscriptions(matches.subscriptions, params)\n  }\n}\n\nclass Context {\n  static setManager (manager) {\n    this.manager = manager\n  }\n\n  constructor () {\n    // TODO: this probably don't need to be a Map()\n    this.store = new Map()\n    this.allAddresses = new Set()\n    this.newAddresses = new Set()\n  }\n\n  clear () {\n    this.store = new Map()\n    this.allAddresses = new Set()\n    this.newAddresses = new Set()\n  }\n\n  setValue (address, value) {\n    if (this.allAddresses.size >= MAX_CONTEXT_SIZE) return this\n\n    // cannot optimize for objects because they're pointers\n    if (typeof value !== 'object') {\n      const oldValue = this.store.get(address)\n      if (oldValue === value) return this\n    }\n\n    this.store.set(address, value)\n    this.allAddresses.add(address)\n    this.newAddresses.add(address)\n\n    return this\n  }\n\n  dispatch () {\n    if (this.newAddresses.size === 0) return []\n\n    const result = Context.manager.dispatch(this.newAddresses, this.allAddresses, this)\n\n    this.newAddresses.clear()\n\n    return result\n  }\n\n  resolve (address) {\n    return this.store.get(address)\n  }\n}\n\nmodule.exports = {\n  SubscriptionManager,\n  Context\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}