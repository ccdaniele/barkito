{"ast":null,"code":"'use strict';\n\nconst {\n  storage\n} = require('../../datadog-core'); // TODO: deprecate binding event emitters in 3.0\n\n\nconst originals = new WeakMap();\nconst listenerMaps = new WeakMap();\nconst emitterSpans = new WeakMap();\nconst emitterScopes = new WeakMap();\nconst emitters = new WeakSet();\n\nclass Scope {\n  active() {\n    const store = storage.getStore();\n    return store && store.span || null;\n  }\n\n  activate(span, callback) {\n    if (typeof callback !== 'function') return callback;\n    const oldStore = storage.getStore();\n    const newStore = span ? span._store : oldStore;\n    storage.enterWith({ ...newStore,\n      span\n    });\n\n    try {\n      return callback();\n    } catch (e) {\n      if (span && typeof span.setTag === 'function') {\n        span.setTag('error', e);\n      }\n\n      throw e;\n    } finally {\n      storage.enterWith(oldStore);\n    }\n  }\n\n  bind(target, span) {\n    target = this._bindEmitter(target, span);\n    target = this._bindPromise(target, span);\n    target = this._bindFn(target, span);\n    return target;\n  }\n\n  unbind(target) {\n    target = this._unbindFn(target);\n    target = this._unbindPromise(target);\n    target = this._unbindEmitter(target);\n    return target;\n  }\n\n  _bindFn(fn, span) {\n    if (typeof fn !== 'function') return fn;\n    const scope = this;\n\n    const spanOrActive = this._spanOrActive(span);\n\n    const bound = function () {\n      return scope.activate(spanOrActive, () => {\n        return fn.apply(this, arguments);\n      });\n    };\n\n    originals.set(bound, fn);\n    return bound;\n  }\n\n  _unbindFn(fn) {\n    if (typeof fn !== 'function') return fn;\n    return originals.get(fn) || fn;\n  }\n\n  _bindEmitter(emitter, span) {\n    if (!this._isEmitter(emitter)) return emitter;\n\n    if (!emitters.has(emitter)) {\n      Scope._wrapEmitter(emitter);\n    }\n\n    emitterSpans.set(emitter, span);\n    emitterScopes.set(emitter, this);\n    return emitter;\n  } // Occasionally we want to wrap a prototype rather than emitter instances,\n  // so we're exposing this as a static method. This gives us a faster\n  // path for binding instances of known EventEmitter subclasses.\n\n\n  static _wrapEmitter(emitter) {\n    wrapMethod(emitter, 'addListener', wrapAddListener);\n    wrapMethod(emitter, 'prependListener', wrapAddListener);\n    wrapMethod(emitter, 'on', wrapAddListener);\n    wrapMethod(emitter, 'once', wrapAddListener);\n    wrapMethod(emitter, 'removeListener', wrapRemoveListener);\n    wrapMethod(emitter, 'off', wrapRemoveListener);\n    wrapMethod(emitter, 'removeAllListeners', wrapRemoveAllListeners);\n    emitters.add(emitter);\n  }\n\n  _unbindEmitter(emitter) {\n    if (!this._isEmitter(emitter)) return emitter;\n    emitterScopes.delete(emitter);\n    emitterSpans.delete(emitter);\n    return emitter;\n  }\n\n  _bindPromise(promise, span) {\n    if (!this._isPromise(promise)) return promise;\n    wrapMethod(promise, 'then', wrapThen, this, span);\n    return promise;\n  }\n\n  _unbindPromise(promise) {\n    if (!this._isPromise(promise)) return promise;\n    promise.then = originals.get(promise.then) || promise.then;\n    return promise;\n  }\n\n  _spanOrActive(span) {\n    return span !== undefined ? span : this.active();\n  }\n\n  _isEmitter(emitter) {\n    return emitter && typeof emitter.emit === 'function' && typeof emitter.on === 'function' && typeof emitter.addListener === 'function' && typeof emitter.removeListener === 'function';\n  }\n\n  _isPromise(promise) {\n    return promise && typeof promise.then === 'function';\n  }\n\n}\n\nfunction getScope(emitter) {\n  return emitterScopes.get(emitter) || emitterScopes.get(emitter.constructor.prototype);\n}\n\nfunction getSpan(emitter) {\n  return emitterSpans.get(emitter) || emitterSpans.get(emitter.constructor.prototype);\n}\n\nfunction hasScope(emitter) {\n  return emitterScopes.has(emitter) || emitterScopes.has(emitter.constructor.prototype);\n}\n\nfunction wrapThen(then, scope, span) {\n  return function thenWithTrace(onFulfilled, onRejected) {\n    const args = new Array(arguments.length);\n\n    for (let i = 0, l = args.length; i < l; i++) {\n      args[i] = scope.bind(arguments[i], span);\n    }\n\n    return then.apply(this, args);\n  };\n}\n\nfunction wrapAddListener(addListener) {\n  return function addListenerWithTrace(eventName, listener) {\n    const scope = getScope(this);\n\n    if (!scope || !listener || originals.has(listener) || listener.listener) {\n      return addListener.apply(this, arguments);\n    }\n\n    const span = getSpan(this);\n    const bound = scope.bind(listener, scope._spanOrActive(span));\n    const listenerMap = listenerMaps.get(this) || {};\n    listenerMaps.set(this, listenerMap);\n\n    if (!listenerMap[eventName]) {\n      listenerMap[eventName] = new WeakMap();\n    }\n\n    const events = listenerMap[eventName];\n\n    if (!events.has(listener)) {\n      events.set(listener, []);\n    }\n\n    events.get(listener).push(bound);\n    return addListener.call(this, eventName, bound);\n  };\n}\n\nfunction wrapRemoveListener(removeListener) {\n  return function removeListenerWithTrace(eventName, listener) {\n    if (!hasScope(this)) {\n      return removeListener.apply(this, arguments);\n    }\n\n    const listenerMap = listenerMaps.get(this);\n    const listeners = listenerMap && listenerMap[eventName];\n\n    if (!listener || !listeners || !listeners.has(listener)) {\n      return removeListener.apply(this, arguments);\n    }\n\n    for (const bound of listeners.get(listener)) {\n      removeListener.call(this, eventName, bound);\n    }\n\n    listeners.delete(listener);\n    return removeListener.apply(this, arguments);\n  };\n}\n\nfunction wrapRemoveAllListeners(removeAllListeners) {\n  return function removeAllListenersWithTrace(eventName) {\n    const listenerMap = listenerMaps.get(this);\n\n    if (hasScope(this) && listenerMap) {\n      if (eventName) {\n        delete listenerMap[eventName];\n      } else {\n        listenerMaps.delete(this);\n      }\n    }\n\n    return removeAllListeners.apply(this, arguments);\n  };\n}\n\nfunction wrapMethod(target, name, wrapper) {\n  if (!target[name] || originals.has(target[name])) return;\n  const original = target[name];\n\n  for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n    args[_key - 3] = arguments[_key];\n  }\n\n  target[name] = wrapper(target[name], ...args);\n  originals.set(target[name], original);\n}\n\nmodule.exports = Scope;","map":{"version":3,"names":["storage","require","originals","WeakMap","listenerMaps","emitterSpans","emitterScopes","emitters","WeakSet","Scope","active","store","getStore","span","activate","callback","oldStore","newStore","_store","enterWith","e","setTag","bind","target","_bindEmitter","_bindPromise","_bindFn","unbind","_unbindFn","_unbindPromise","_unbindEmitter","fn","scope","spanOrActive","_spanOrActive","bound","apply","arguments","set","get","emitter","_isEmitter","has","_wrapEmitter","wrapMethod","wrapAddListener","wrapRemoveListener","wrapRemoveAllListeners","add","delete","promise","_isPromise","wrapThen","then","undefined","emit","on","addListener","removeListener","getScope","constructor","prototype","getSpan","hasScope","thenWithTrace","onFulfilled","onRejected","args","Array","length","i","l","addListenerWithTrace","eventName","listener","listenerMap","events","push","call","removeListenerWithTrace","listeners","removeAllListeners","removeAllListenersWithTrace","name","wrapper","original","module","exports"],"sources":["/Users/daniel.calderon/Projects/barkito/barkito_front/node_modules/dd-trace/packages/dd-trace/src/scope.js"],"sourcesContent":["'use strict'\n\nconst { storage } = require('../../datadog-core')\n\n// TODO: deprecate binding event emitters in 3.0\n\nconst originals = new WeakMap()\nconst listenerMaps = new WeakMap()\nconst emitterSpans = new WeakMap()\nconst emitterScopes = new WeakMap()\nconst emitters = new WeakSet()\n\nclass Scope {\n  active () {\n    const store = storage.getStore()\n\n    return (store && store.span) || null\n  }\n\n  activate (span, callback) {\n    if (typeof callback !== 'function') return callback\n\n    const oldStore = storage.getStore()\n    const newStore = span ? span._store : oldStore\n\n    storage.enterWith({ ...newStore, span })\n\n    try {\n      return callback()\n    } catch (e) {\n      if (span && typeof span.setTag === 'function') {\n        span.setTag('error', e)\n      }\n\n      throw e\n    } finally {\n      storage.enterWith(oldStore)\n    }\n  }\n\n  bind (target, span) {\n    target = this._bindEmitter(target, span)\n    target = this._bindPromise(target, span)\n    target = this._bindFn(target, span)\n\n    return target\n  }\n\n  unbind (target) {\n    target = this._unbindFn(target)\n    target = this._unbindPromise(target)\n    target = this._unbindEmitter(target)\n\n    return target\n  }\n\n  _bindFn (fn, span) {\n    if (typeof fn !== 'function') return fn\n\n    const scope = this\n    const spanOrActive = this._spanOrActive(span)\n\n    const bound = function () {\n      return scope.activate(spanOrActive, () => {\n        return fn.apply(this, arguments)\n      })\n    }\n\n    originals.set(bound, fn)\n\n    return bound\n  }\n\n  _unbindFn (fn) {\n    if (typeof fn !== 'function') return fn\n\n    return originals.get(fn) || fn\n  }\n\n  _bindEmitter (emitter, span) {\n    if (!this._isEmitter(emitter)) return emitter\n    if (!emitters.has(emitter)) {\n      Scope._wrapEmitter(emitter)\n    }\n    emitterSpans.set(emitter, span)\n    emitterScopes.set(emitter, this)\n    return emitter\n  }\n\n  // Occasionally we want to wrap a prototype rather than emitter instances,\n  // so we're exposing this as a static method. This gives us a faster\n  // path for binding instances of known EventEmitter subclasses.\n  static _wrapEmitter (emitter) {\n    wrapMethod(emitter, 'addListener', wrapAddListener)\n    wrapMethod(emitter, 'prependListener', wrapAddListener)\n    wrapMethod(emitter, 'on', wrapAddListener)\n    wrapMethod(emitter, 'once', wrapAddListener)\n    wrapMethod(emitter, 'removeListener', wrapRemoveListener)\n    wrapMethod(emitter, 'off', wrapRemoveListener)\n    wrapMethod(emitter, 'removeAllListeners', wrapRemoveAllListeners)\n    emitters.add(emitter)\n  }\n\n  _unbindEmitter (emitter) {\n    if (!this._isEmitter(emitter)) return emitter\n    emitterScopes.delete(emitter)\n    emitterSpans.delete(emitter)\n    return emitter\n  }\n\n  _bindPromise (promise, span) {\n    if (!this._isPromise(promise)) return promise\n\n    wrapMethod(promise, 'then', wrapThen, this, span)\n\n    return promise\n  }\n\n  _unbindPromise (promise) {\n    if (!this._isPromise(promise)) return promise\n\n    promise.then = originals.get(promise.then) || promise.then\n\n    return promise\n  }\n\n  _spanOrActive (span) {\n    return span !== undefined ? span : this.active()\n  }\n\n  _isEmitter (emitter) {\n    return emitter &&\n      typeof emitter.emit === 'function' &&\n      typeof emitter.on === 'function' &&\n      typeof emitter.addListener === 'function' &&\n      typeof emitter.removeListener === 'function'\n  }\n\n  _isPromise (promise) {\n    return promise && typeof promise.then === 'function'\n  }\n}\n\nfunction getScope (emitter) {\n  return emitterScopes.get(emitter) || emitterScopes.get(emitter.constructor.prototype)\n}\n\nfunction getSpan (emitter) {\n  return emitterSpans.get(emitter) || emitterSpans.get(emitter.constructor.prototype)\n}\n\nfunction hasScope (emitter) {\n  return emitterScopes.has(emitter) || emitterScopes.has(emitter.constructor.prototype)\n}\n\nfunction wrapThen (then, scope, span) {\n  return function thenWithTrace (onFulfilled, onRejected) {\n    const args = new Array(arguments.length)\n\n    for (let i = 0, l = args.length; i < l; i++) {\n      args[i] = scope.bind(arguments[i], span)\n    }\n\n    return then.apply(this, args)\n  }\n}\n\nfunction wrapAddListener (addListener) {\n  return function addListenerWithTrace (eventName, listener) {\n    const scope = getScope(this)\n    if (!scope || !listener || originals.has(listener) || listener.listener) {\n      return addListener.apply(this, arguments)\n    }\n    const span = getSpan(this)\n\n    const bound = scope.bind(listener, scope._spanOrActive(span))\n    const listenerMap = listenerMaps.get(this) || {}\n\n    listenerMaps.set(this, listenerMap)\n\n    if (!listenerMap[eventName]) {\n      listenerMap[eventName] = new WeakMap()\n    }\n\n    const events = listenerMap[eventName]\n\n    if (!events.has(listener)) {\n      events.set(listener, [])\n    }\n\n    events.get(listener).push(bound)\n\n    return addListener.call(this, eventName, bound)\n  }\n}\n\nfunction wrapRemoveListener (removeListener) {\n  return function removeListenerWithTrace (eventName, listener) {\n    if (!hasScope(this)) {\n      return removeListener.apply(this, arguments)\n    }\n\n    const listenerMap = listenerMaps.get(this)\n    const listeners = listenerMap && listenerMap[eventName]\n\n    if (!listener || !listeners || !listeners.has(listener)) {\n      return removeListener.apply(this, arguments)\n    }\n\n    for (const bound of listeners.get(listener)) {\n      removeListener.call(this, eventName, bound)\n    }\n\n    listeners.delete(listener)\n\n    return removeListener.apply(this, arguments)\n  }\n}\n\nfunction wrapRemoveAllListeners (removeAllListeners) {\n  return function removeAllListenersWithTrace (eventName) {\n    const listenerMap = listenerMaps.get(this)\n\n    if (hasScope(this) && listenerMap) {\n      if (eventName) {\n        delete listenerMap[eventName]\n      } else {\n        listenerMaps.delete(this)\n      }\n    }\n\n    return removeAllListeners.apply(this, arguments)\n  }\n}\n\nfunction wrapMethod (target, name, wrapper, ...args) {\n  if (!target[name] || originals.has(target[name])) return\n\n  const original = target[name]\n\n  target[name] = wrapper(target[name], ...args)\n  originals.set(target[name], original)\n}\n\nmodule.exports = Scope\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}