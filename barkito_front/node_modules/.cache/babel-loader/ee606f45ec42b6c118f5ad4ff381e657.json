{"ast":null,"code":"'use strict';\n\nconst {\n  truncateSpan,\n  normalizeSpan\n} = require('./tags-processors');\n\nconst Chunk = require('./chunk');\n\nconst log = require('../log');\n\nconst SOFT_LIMIT = 8 * 1024 * 1024; // 8MB\n\nconst float64Array = new Float64Array(1);\nconst uInt8Float64Array = new Uint8Array(float64Array.buffer);\nfloat64Array[0] = -1;\nconst bigEndian = uInt8Float64Array[7] === 0;\n\nfunction formatSpan(span) {\n  return normalizeSpan(truncateSpan(span));\n}\n\nclass AgentEncoder {\n  constructor(writer) {\n    let limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SOFT_LIMIT;\n    this._limit = limit;\n    this._traceBytes = new Chunk();\n    this._stringBytes = new Chunk();\n    this._writer = writer;\n\n    this._reset();\n  }\n\n  count() {\n    return this._traceCount;\n  }\n\n  encode(trace) {\n    const bytes = this._traceBytes;\n    const start = bytes.length;\n    this._traceCount++;\n\n    this._encode(bytes, trace);\n\n    const end = bytes.length;\n    log.debug(() => {\n      const hex = bytes.buffer.subarray(start, end).toString('hex').match(/../g).join(' ');\n      return `Adding encoded trace to buffer: ${hex}`;\n    }); // we can go over the soft limit since the agent has a 50MB hard limit\n\n    if (this._traceBytes.length > this._limit || this._stringBytes.length > this._limit) {\n      log.debug('Buffer went over soft limit, flushing');\n\n      this._writer.flush();\n    }\n  }\n\n  makePayload() {\n    const traceSize = this._traceBytes.length + 5;\n    const buffer = Buffer.allocUnsafe(traceSize);\n\n    this._writeTraces(buffer);\n\n    this._reset();\n\n    return buffer;\n  }\n\n  reset() {\n    this._reset();\n  }\n\n  _encode(bytes, trace) {\n    this._encodeArrayPrefix(bytes, trace);\n\n    for (let span of trace) {\n      span = formatSpan(span);\n      bytes.reserve(1);\n\n      if (span.type) {\n        bytes.buffer[bytes.length++] = 0x8c;\n\n        this._encodeString(bytes, 'type');\n\n        this._encodeString(bytes, span.type);\n      } else {\n        bytes.buffer[bytes.length++] = 0x8b;\n      }\n\n      this._encodeString(bytes, 'trace_id');\n\n      this._encodeId(bytes, span.trace_id);\n\n      this._encodeString(bytes, 'span_id');\n\n      this._encodeId(bytes, span.span_id);\n\n      this._encodeString(bytes, 'parent_id');\n\n      this._encodeId(bytes, span.parent_id);\n\n      this._encodeString(bytes, 'name');\n\n      this._encodeString(bytes, span.name);\n\n      this._encodeString(bytes, 'resource');\n\n      this._encodeString(bytes, span.resource);\n\n      this._encodeString(bytes, 'service');\n\n      this._encodeString(bytes, span.service);\n\n      this._encodeString(bytes, 'error');\n\n      this._encodeInteger(bytes, span.error);\n\n      this._encodeString(bytes, 'start');\n\n      this._encodeLong(bytes, span.start);\n\n      this._encodeString(bytes, 'duration');\n\n      this._encodeLong(bytes, span.duration);\n\n      this._encodeString(bytes, 'meta');\n\n      this._encodeMap(bytes, span.meta);\n\n      this._encodeString(bytes, 'metrics');\n\n      this._encodeMap(bytes, span.metrics);\n    }\n  }\n\n  _reset() {\n    this._traceCount = 0;\n    this._traceBytes.length = 0;\n    this._stringCount = 0;\n    this._stringBytes.length = 0;\n    this._stringMap = {};\n\n    this._cacheString('');\n  }\n\n  _encodeArrayPrefix(bytes, value) {\n    const length = value.length;\n    const offset = bytes.length;\n    bytes.reserve(5);\n    bytes.length += 5;\n    bytes.buffer[offset] = 0xdd;\n    bytes.buffer[offset + 1] = length >> 24;\n    bytes.buffer[offset + 2] = length >> 16;\n    bytes.buffer[offset + 3] = length >> 8;\n    bytes.buffer[offset + 4] = length;\n  }\n\n  _encodeMapPrefix(bytes, keysLength) {\n    const offset = bytes.length;\n    bytes.reserve(5);\n    bytes.length += 5;\n    bytes.buffer[offset] = 0xdf;\n    bytes.buffer[offset + 1] = keysLength >> 24;\n    bytes.buffer[offset + 2] = keysLength >> 16;\n    bytes.buffer[offset + 3] = keysLength >> 8;\n    bytes.buffer[offset + 4] = keysLength;\n  }\n\n  _encodeByte(bytes, value) {\n    bytes.reserve(1);\n    bytes.buffer[bytes.length++] = value;\n  }\n\n  _encodeId(bytes, id) {\n    const offset = bytes.length;\n    bytes.reserve(9);\n    bytes.length += 9;\n    id = id.toArray();\n    bytes.buffer[offset] = 0xcf;\n    bytes.buffer[offset + 1] = id[0];\n    bytes.buffer[offset + 2] = id[1];\n    bytes.buffer[offset + 3] = id[2];\n    bytes.buffer[offset + 4] = id[3];\n    bytes.buffer[offset + 5] = id[4];\n    bytes.buffer[offset + 6] = id[5];\n    bytes.buffer[offset + 7] = id[6];\n    bytes.buffer[offset + 8] = id[7];\n  }\n\n  _encodeInteger(bytes, value) {\n    const offset = bytes.length;\n    bytes.reserve(5);\n    bytes.length += 5;\n    bytes.buffer[offset] = 0xce;\n    bytes.buffer[offset + 1] = value >> 24;\n    bytes.buffer[offset + 2] = value >> 16;\n    bytes.buffer[offset + 3] = value >> 8;\n    bytes.buffer[offset + 4] = value;\n  }\n\n  _encodeLong(bytes, value) {\n    const offset = bytes.length;\n    const hi = value / Math.pow(2, 32) >> 0;\n    const lo = value >>> 0;\n    bytes.reserve(9);\n    bytes.length += 9;\n    bytes.buffer[offset] = 0xcf;\n    bytes.buffer[offset + 1] = hi >> 24;\n    bytes.buffer[offset + 2] = hi >> 16;\n    bytes.buffer[offset + 3] = hi >> 8;\n    bytes.buffer[offset + 4] = hi;\n    bytes.buffer[offset + 5] = lo >> 24;\n    bytes.buffer[offset + 6] = lo >> 16;\n    bytes.buffer[offset + 7] = lo >> 8;\n    bytes.buffer[offset + 8] = lo;\n  }\n\n  _encodeMap(bytes, value) {\n    const keys = Object.keys(value);\n    const validKeys = keys.filter(key => typeof value[key] === 'string' || typeof value[key] === 'number');\n\n    this._encodeMapPrefix(bytes, validKeys.length);\n\n    for (const key of validKeys) {\n      this._encodeString(bytes, key);\n\n      this._encodeValue(bytes, value[key]);\n    }\n  }\n\n  _encodeValue(bytes, value) {\n    switch (typeof value) {\n      case 'string':\n        this._encodeString(bytes, value);\n\n        break;\n\n      case 'number':\n        this._encodeFloat(bytes, value);\n\n        break;\n\n      default: // should not happen\n\n    }\n  }\n\n  _encodeString(bytes) {\n    let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n    this._cacheString(value);\n\n    const {\n      start,\n      end\n    } = this._stringMap[value];\n\n    this._stringBytes.copy(bytes, start, end);\n  }\n\n  _encodeFloat(bytes, value) {\n    float64Array[0] = value;\n    const offset = bytes.length;\n    bytes.reserve(9);\n    bytes.length += 9;\n    bytes.buffer[offset] = 0xcb;\n\n    if (bigEndian) {\n      for (let i = 0; i <= 7; i++) {\n        bytes.buffer[offset + i + 1] = uInt8Float64Array[i];\n      }\n    } else {\n      for (let i = 7; i >= 0; i--) {\n        bytes.buffer[bytes.length - i - 1] = uInt8Float64Array[i];\n      }\n    }\n  }\n\n  _cacheString(value) {\n    if (!(value in this._stringMap)) {\n      this._stringCount++;\n      this._stringMap[value] = {\n        start: this._stringBytes.length,\n        end: this._stringBytes.length + this._stringBytes.write(value)\n      };\n    }\n  }\n\n  _writeArrayPrefix(buffer, offset, count) {\n    buffer[offset++] = 0xdd;\n    buffer.writeUInt32BE(count, offset);\n    return offset + 4;\n  }\n\n  _writeTraces(buffer) {\n    let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    offset = this._writeArrayPrefix(buffer, offset, this._traceCount);\n    offset += this._traceBytes.buffer.copy(buffer, offset, 0, this._traceBytes.length);\n    return offset;\n  }\n\n}\n\nmodule.exports = {\n  AgentEncoder\n};","map":{"version":3,"names":["truncateSpan","normalizeSpan","require","Chunk","log","SOFT_LIMIT","float64Array","Float64Array","uInt8Float64Array","Uint8Array","buffer","bigEndian","formatSpan","span","AgentEncoder","constructor","writer","limit","_limit","_traceBytes","_stringBytes","_writer","_reset","count","_traceCount","encode","trace","bytes","start","length","_encode","end","debug","hex","subarray","toString","match","join","flush","makePayload","traceSize","Buffer","allocUnsafe","_writeTraces","reset","_encodeArrayPrefix","reserve","type","_encodeString","_encodeId","trace_id","span_id","parent_id","name","resource","service","_encodeInteger","error","_encodeLong","duration","_encodeMap","meta","metrics","_stringCount","_stringMap","_cacheString","value","offset","_encodeMapPrefix","keysLength","_encodeByte","id","toArray","hi","Math","pow","lo","keys","Object","validKeys","filter","key","_encodeValue","_encodeFloat","copy","i","write","_writeArrayPrefix","writeUInt32BE","module","exports"],"sources":["/Users/daniel.calderon/Projects/barkito/barkito_front/node_modules/dd-trace/packages/dd-trace/src/encode/0.4.js"],"sourcesContent":["'use strict'\n\nconst { truncateSpan, normalizeSpan } = require('./tags-processors')\nconst Chunk = require('./chunk')\nconst log = require('../log')\n\nconst SOFT_LIMIT = 8 * 1024 * 1024 // 8MB\n\nconst float64Array = new Float64Array(1)\nconst uInt8Float64Array = new Uint8Array(float64Array.buffer)\n\nfloat64Array[0] = -1\n\nconst bigEndian = uInt8Float64Array[7] === 0\n\nfunction formatSpan (span) {\n  return normalizeSpan(truncateSpan(span))\n}\n\nclass AgentEncoder {\n  constructor (writer, limit = SOFT_LIMIT) {\n    this._limit = limit\n    this._traceBytes = new Chunk()\n    this._stringBytes = new Chunk()\n    this._writer = writer\n    this._reset()\n  }\n\n  count () {\n    return this._traceCount\n  }\n\n  encode (trace) {\n    const bytes = this._traceBytes\n    const start = bytes.length\n\n    this._traceCount++\n\n    this._encode(bytes, trace)\n\n    const end = bytes.length\n\n    log.debug(() => {\n      const hex = bytes.buffer.subarray(start, end).toString('hex').match(/../g).join(' ')\n\n      return `Adding encoded trace to buffer: ${hex}`\n    })\n\n    // we can go over the soft limit since the agent has a 50MB hard limit\n    if (this._traceBytes.length > this._limit || this._stringBytes.length > this._limit) {\n      log.debug('Buffer went over soft limit, flushing')\n      this._writer.flush()\n    }\n  }\n\n  makePayload () {\n    const traceSize = this._traceBytes.length + 5\n    const buffer = Buffer.allocUnsafe(traceSize)\n\n    this._writeTraces(buffer)\n\n    this._reset()\n\n    return buffer\n  }\n\n  reset () {\n    this._reset()\n  }\n\n  _encode (bytes, trace) {\n    this._encodeArrayPrefix(bytes, trace)\n\n    for (let span of trace) {\n      span = formatSpan(span)\n      bytes.reserve(1)\n\n      if (span.type) {\n        bytes.buffer[bytes.length++] = 0x8c\n\n        this._encodeString(bytes, 'type')\n        this._encodeString(bytes, span.type)\n      } else {\n        bytes.buffer[bytes.length++] = 0x8b\n      }\n\n      this._encodeString(bytes, 'trace_id')\n      this._encodeId(bytes, span.trace_id)\n      this._encodeString(bytes, 'span_id')\n      this._encodeId(bytes, span.span_id)\n      this._encodeString(bytes, 'parent_id')\n      this._encodeId(bytes, span.parent_id)\n      this._encodeString(bytes, 'name')\n      this._encodeString(bytes, span.name)\n      this._encodeString(bytes, 'resource')\n      this._encodeString(bytes, span.resource)\n      this._encodeString(bytes, 'service')\n      this._encodeString(bytes, span.service)\n      this._encodeString(bytes, 'error')\n      this._encodeInteger(bytes, span.error)\n      this._encodeString(bytes, 'start')\n      this._encodeLong(bytes, span.start)\n      this._encodeString(bytes, 'duration')\n      this._encodeLong(bytes, span.duration)\n      this._encodeString(bytes, 'meta')\n      this._encodeMap(bytes, span.meta)\n      this._encodeString(bytes, 'metrics')\n      this._encodeMap(bytes, span.metrics)\n    }\n  }\n\n  _reset () {\n    this._traceCount = 0\n    this._traceBytes.length = 0\n    this._stringCount = 0\n    this._stringBytes.length = 0\n    this._stringMap = {}\n\n    this._cacheString('')\n  }\n\n  _encodeArrayPrefix (bytes, value) {\n    const length = value.length\n    const offset = bytes.length\n\n    bytes.reserve(5)\n    bytes.length += 5\n\n    bytes.buffer[offset] = 0xdd\n    bytes.buffer[offset + 1] = length >> 24\n    bytes.buffer[offset + 2] = length >> 16\n    bytes.buffer[offset + 3] = length >> 8\n    bytes.buffer[offset + 4] = length\n  }\n\n  _encodeMapPrefix (bytes, keysLength) {\n    const offset = bytes.length\n\n    bytes.reserve(5)\n    bytes.length += 5\n    bytes.buffer[offset] = 0xdf\n    bytes.buffer[offset + 1] = keysLength >> 24\n    bytes.buffer[offset + 2] = keysLength >> 16\n    bytes.buffer[offset + 3] = keysLength >> 8\n    bytes.buffer[offset + 4] = keysLength\n  }\n\n  _encodeByte (bytes, value) {\n    bytes.reserve(1)\n\n    bytes.buffer[bytes.length++] = value\n  }\n\n  _encodeId (bytes, id) {\n    const offset = bytes.length\n\n    bytes.reserve(9)\n    bytes.length += 9\n\n    id = id.toArray()\n\n    bytes.buffer[offset] = 0xcf\n    bytes.buffer[offset + 1] = id[0]\n    bytes.buffer[offset + 2] = id[1]\n    bytes.buffer[offset + 3] = id[2]\n    bytes.buffer[offset + 4] = id[3]\n    bytes.buffer[offset + 5] = id[4]\n    bytes.buffer[offset + 6] = id[5]\n    bytes.buffer[offset + 7] = id[6]\n    bytes.buffer[offset + 8] = id[7]\n  }\n\n  _encodeInteger (bytes, value) {\n    const offset = bytes.length\n\n    bytes.reserve(5)\n    bytes.length += 5\n\n    bytes.buffer[offset] = 0xce\n    bytes.buffer[offset + 1] = value >> 24\n    bytes.buffer[offset + 2] = value >> 16\n    bytes.buffer[offset + 3] = value >> 8\n    bytes.buffer[offset + 4] = value\n  }\n\n  _encodeLong (bytes, value) {\n    const offset = bytes.length\n    const hi = (value / Math.pow(2, 32)) >> 0\n    const lo = value >>> 0\n\n    bytes.reserve(9)\n    bytes.length += 9\n\n    bytes.buffer[offset] = 0xcf\n    bytes.buffer[offset + 1] = hi >> 24\n    bytes.buffer[offset + 2] = hi >> 16\n    bytes.buffer[offset + 3] = hi >> 8\n    bytes.buffer[offset + 4] = hi\n    bytes.buffer[offset + 5] = lo >> 24\n    bytes.buffer[offset + 6] = lo >> 16\n    bytes.buffer[offset + 7] = lo >> 8\n    bytes.buffer[offset + 8] = lo\n  }\n\n  _encodeMap (bytes, value) {\n    const keys = Object.keys(value)\n    const validKeys = keys.filter(key => typeof value[key] === 'string' || typeof value[key] === 'number')\n\n    this._encodeMapPrefix(bytes, validKeys.length)\n\n    for (const key of validKeys) {\n      this._encodeString(bytes, key)\n      this._encodeValue(bytes, value[key])\n    }\n  }\n\n  _encodeValue (bytes, value) {\n    switch (typeof value) {\n      case 'string':\n        this._encodeString(bytes, value)\n        break\n      case 'number':\n        this._encodeFloat(bytes, value)\n        break\n      default:\n        // should not happen\n    }\n  }\n\n  _encodeString (bytes, value = '') {\n    this._cacheString(value)\n\n    const { start, end } = this._stringMap[value]\n\n    this._stringBytes.copy(bytes, start, end)\n  }\n\n  _encodeFloat (bytes, value) {\n    float64Array[0] = value\n\n    const offset = bytes.length\n    bytes.reserve(9)\n    bytes.length += 9\n\n    bytes.buffer[offset] = 0xcb\n\n    if (bigEndian) {\n      for (let i = 0; i <= 7; i++) {\n        bytes.buffer[offset + i + 1] = uInt8Float64Array[i]\n      }\n    } else {\n      for (let i = 7; i >= 0; i--) {\n        bytes.buffer[bytes.length - i - 1] = uInt8Float64Array[i]\n      }\n    }\n  }\n\n  _cacheString (value) {\n    if (!(value in this._stringMap)) {\n      this._stringCount++\n      this._stringMap[value] = {\n        start: this._stringBytes.length,\n        end: this._stringBytes.length + this._stringBytes.write(value)\n      }\n    }\n  }\n\n  _writeArrayPrefix (buffer, offset, count) {\n    buffer[offset++] = 0xdd\n    buffer.writeUInt32BE(count, offset)\n\n    return offset + 4\n  }\n\n  _writeTraces (buffer, offset = 0) {\n    offset = this._writeArrayPrefix(buffer, offset, this._traceCount)\n    offset += this._traceBytes.buffer.copy(buffer, offset, 0, this._traceBytes.length)\n\n    return offset\n  }\n}\n\nmodule.exports = { AgentEncoder }\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}