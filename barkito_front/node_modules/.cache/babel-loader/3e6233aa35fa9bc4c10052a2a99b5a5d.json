{"ast":null,"code":"\"use strict\";\n/*\n * Unless explicitly stated otherwise all files in this repository are licensed\n * under the Apache 2.0 license (see LICENSE).\n * This product includes software developed at Datadog (https://www.datadoghq.com/).\n * Copyright 2020 Datadog, Inc.\n */\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CollapsingHighestDenseStore = void 0;\n\nvar DenseStore_1 = require(\"./DenseStore\");\n\nvar util_1 = require(\"./util\");\n/**\n * `CollapsingHighestDenseStore` is a dense store that keeps all the bins between\n * the bin for the `minKey` and the `maxKey`, but collapsing the left-most bins\n * if the number of bins exceeds `binLimit`\n */\n\n\nvar CollapsingHighestDenseStore =\n/** @class */\nfunction (_super) {\n  __extends(CollapsingHighestDenseStore, _super);\n  /**\n   * Initialize a new CollapsingHighestDenseStore\n   *\n   * @param binLimit The maximum number of bins\n   * @param chunkSize The number of bins to add each time the bins grow (default 128)\n   */\n\n\n  function CollapsingHighestDenseStore(binLimit, chunkSize) {\n    var _this = _super.call(this, chunkSize) || this;\n\n    _this.binLimit = binLimit;\n    _this.isCollapsed = false;\n    return _this;\n  }\n  /**\n   * Merge the contents of the parameter `store` into this store\n   *\n   * @param store The store to merge into the caller store\n   */\n\n\n  CollapsingHighestDenseStore.prototype.merge = function (store) {\n    if (store.count === 0) {\n      return;\n    }\n\n    if (this.count === 0) {\n      this.copy(store);\n      return;\n    }\n\n    if (store.minKey < this.minKey || store.maxKey > this.maxKey) {\n      this._extendRange(store.minKey, store.maxKey);\n    }\n\n    var collapseEndIndex = store.maxKey - store.offset + 1;\n    var collapseStartIndex = Math.max(this.maxKey + 1, store.minKey) - store.offset;\n\n    if (collapseEndIndex > collapseStartIndex) {\n      var collapseCount = (0, util_1.sumOfRange)(store.bins, collapseStartIndex, collapseEndIndex);\n      this.bins[this.length() - 1] += collapseCount;\n    } else {\n      collapseStartIndex = collapseEndIndex;\n    }\n\n    for (var key = store.minKey; key < collapseStartIndex + store.offset; key++) {\n      this.bins[key - this.offset] += store.bins[key - store.offset];\n    }\n\n    this.count += store.count;\n  };\n  /**\n   * Directly clone the contents of the parameter `store` into this store\n   *\n   * @param store The store to be copied into the caller store\n   */\n\n\n  CollapsingHighestDenseStore.prototype.copy = function (store) {\n    _super.prototype.copy.call(this, store);\n\n    this.isCollapsed = store.isCollapsed;\n  };\n\n  CollapsingHighestDenseStore.prototype._getNewLength = function (newMinKey, newMaxKey) {\n    var desiredLength = newMaxKey - newMinKey + 1;\n    return Math.min(this.chunkSize * Math.ceil(desiredLength / this.chunkSize), this.binLimit);\n  };\n  /**\n   * Adjust the `bins`, the `offset`, the `minKey`, and the `maxKey`\n   * without resizing the bins, in order to try to make it fit the specified range.\n   * Collapse to the left if necessary\n   */\n\n\n  CollapsingHighestDenseStore.prototype._adjust = function (newMinKey, newMaxKey) {\n    if (newMaxKey - newMinKey + 1 > this.length()) {\n      // The range of keys is too wide, the lowest bins need to be collapsed\n      newMaxKey = newMinKey + this.length() + 1;\n\n      if (newMaxKey <= this.minKey) {\n        // Put everything in the first bin\n        this.offset = newMinKey;\n        this.maxKey = newMaxKey;\n        this.bins.fill(0);\n        this.bins[this.length() - 1] = this.count;\n      } else {\n        var shift = this.offset - newMinKey;\n\n        if (shift > 0) {\n          var collapseStartIndex = newMaxKey - this.offset + 1;\n          var collapseEndIndex = this.maxKey - this.offset + 1;\n          var collapsedCount = (0, util_1.sumOfRange)(this.bins, collapseStartIndex, collapseEndIndex);\n          this.bins.fill(0, collapseStartIndex, collapseEndIndex);\n          this.bins[collapseStartIndex - 1] += collapsedCount;\n          this.maxKey = newMaxKey;\n\n          this._shiftBins(shift);\n        } else {\n          this.maxKey = newMaxKey; // Shift the buckets to make room for newMinKey\n\n          this._shiftBins(shift);\n        }\n\n        this.minKey = newMinKey;\n        this.isCollapsed = true;\n      }\n    } else {\n      this._centerBins(newMinKey, newMaxKey);\n\n      this.minKey = newMinKey;\n      this.maxKey = newMaxKey;\n    }\n  };\n  /** Calculate the bin index for the key, extending the range if necessary */\n\n\n  CollapsingHighestDenseStore.prototype._getIndex = function (key) {\n    if (key < this.minKey) {\n      if (this.isCollapsed) {\n        return this.length() - 1;\n      }\n\n      this._extendRange(key);\n\n      if (this.isCollapsed) {\n        return this.length() - 1;\n      }\n    } else if (key > this.maxKey) {\n      this._extendRange(key);\n    }\n\n    return key - this.offset;\n  };\n\n  return CollapsingHighestDenseStore;\n}(DenseStore_1.DenseStore);\n\nexports.CollapsingHighestDenseStore = CollapsingHighestDenseStore;","map":{"version":3,"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","defineProperty","exports","value","CollapsingHighestDenseStore","DenseStore_1","require","util_1","_super","binLimit","chunkSize","_this","isCollapsed","merge","store","count","copy","minKey","maxKey","_extendRange","collapseEndIndex","offset","collapseStartIndex","Math","max","collapseCount","sumOfRange","bins","length","key","_getNewLength","newMinKey","newMaxKey","desiredLength","min","ceil","_adjust","fill","shift","collapsedCount","_shiftBins","_centerBins","_getIndex","DenseStore"],"sources":["/Users/daniel.calderon/Projects/barkito/barkito_front/node_modules/@datadog/sketches-js/dist/ddsketch/store/CollapsingHighestDenseStore.js"],"sourcesContent":["\"use strict\";\n/*\n * Unless explicitly stated otherwise all files in this repository are licensed\n * under the Apache 2.0 license (see LICENSE).\n * This product includes software developed at Datadog (https://www.datadoghq.com/).\n * Copyright 2020 Datadog, Inc.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CollapsingHighestDenseStore = void 0;\nvar DenseStore_1 = require(\"./DenseStore\");\nvar util_1 = require(\"./util\");\n/**\n * `CollapsingHighestDenseStore` is a dense store that keeps all the bins between\n * the bin for the `minKey` and the `maxKey`, but collapsing the left-most bins\n * if the number of bins exceeds `binLimit`\n */\nvar CollapsingHighestDenseStore = /** @class */ (function (_super) {\n    __extends(CollapsingHighestDenseStore, _super);\n    /**\n     * Initialize a new CollapsingHighestDenseStore\n     *\n     * @param binLimit The maximum number of bins\n     * @param chunkSize The number of bins to add each time the bins grow (default 128)\n     */\n    function CollapsingHighestDenseStore(binLimit, chunkSize) {\n        var _this = _super.call(this, chunkSize) || this;\n        _this.binLimit = binLimit;\n        _this.isCollapsed = false;\n        return _this;\n    }\n    /**\n     * Merge the contents of the parameter `store` into this store\n     *\n     * @param store The store to merge into the caller store\n     */\n    CollapsingHighestDenseStore.prototype.merge = function (store) {\n        if (store.count === 0) {\n            return;\n        }\n        if (this.count === 0) {\n            this.copy(store);\n            return;\n        }\n        if (store.minKey < this.minKey || store.maxKey > this.maxKey) {\n            this._extendRange(store.minKey, store.maxKey);\n        }\n        var collapseEndIndex = store.maxKey - store.offset + 1;\n        var collapseStartIndex = Math.max(this.maxKey + 1, store.minKey) - store.offset;\n        if (collapseEndIndex > collapseStartIndex) {\n            var collapseCount = (0, util_1.sumOfRange)(store.bins, collapseStartIndex, collapseEndIndex);\n            this.bins[this.length() - 1] += collapseCount;\n        }\n        else {\n            collapseStartIndex = collapseEndIndex;\n        }\n        for (var key = store.minKey; key < collapseStartIndex + store.offset; key++) {\n            this.bins[key - this.offset] += store.bins[key - store.offset];\n        }\n        this.count += store.count;\n    };\n    /**\n     * Directly clone the contents of the parameter `store` into this store\n     *\n     * @param store The store to be copied into the caller store\n     */\n    CollapsingHighestDenseStore.prototype.copy = function (store) {\n        _super.prototype.copy.call(this, store);\n        this.isCollapsed = store.isCollapsed;\n    };\n    CollapsingHighestDenseStore.prototype._getNewLength = function (newMinKey, newMaxKey) {\n        var desiredLength = newMaxKey - newMinKey + 1;\n        return Math.min(this.chunkSize * Math.ceil(desiredLength / this.chunkSize), this.binLimit);\n    };\n    /**\n     * Adjust the `bins`, the `offset`, the `minKey`, and the `maxKey`\n     * without resizing the bins, in order to try to make it fit the specified range.\n     * Collapse to the left if necessary\n     */\n    CollapsingHighestDenseStore.prototype._adjust = function (newMinKey, newMaxKey) {\n        if (newMaxKey - newMinKey + 1 > this.length()) {\n            // The range of keys is too wide, the lowest bins need to be collapsed\n            newMaxKey = newMinKey + this.length() + 1;\n            if (newMaxKey <= this.minKey) {\n                // Put everything in the first bin\n                this.offset = newMinKey;\n                this.maxKey = newMaxKey;\n                this.bins.fill(0);\n                this.bins[this.length() - 1] = this.count;\n            }\n            else {\n                var shift = this.offset - newMinKey;\n                if (shift > 0) {\n                    var collapseStartIndex = newMaxKey - this.offset + 1;\n                    var collapseEndIndex = this.maxKey - this.offset + 1;\n                    var collapsedCount = (0, util_1.sumOfRange)(this.bins, collapseStartIndex, collapseEndIndex);\n                    this.bins.fill(0, collapseStartIndex, collapseEndIndex);\n                    this.bins[collapseStartIndex - 1] += collapsedCount;\n                    this.maxKey = newMaxKey;\n                    this._shiftBins(shift);\n                }\n                else {\n                    this.maxKey = newMaxKey;\n                    // Shift the buckets to make room for newMinKey\n                    this._shiftBins(shift);\n                }\n                this.minKey = newMinKey;\n                this.isCollapsed = true;\n            }\n        }\n        else {\n            this._centerBins(newMinKey, newMaxKey);\n            this.minKey = newMinKey;\n            this.maxKey = newMaxKey;\n        }\n    };\n    /** Calculate the bin index for the key, extending the range if necessary */\n    CollapsingHighestDenseStore.prototype._getIndex = function (key) {\n        if (key < this.minKey) {\n            if (this.isCollapsed) {\n                return this.length() - 1;\n            }\n            this._extendRange(key);\n            if (this.isCollapsed) {\n                return this.length() - 1;\n            }\n        }\n        else if (key > this.maxKey) {\n            this._extendRange(key);\n        }\n        return key - this.offset;\n    };\n    return CollapsingHighestDenseStore;\n}(DenseStore_1.DenseStore));\nexports.CollapsingHighestDenseStore = CollapsingHighestDenseStore;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}