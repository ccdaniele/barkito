{"ast":null,"code":"const {\n  addHook,\n  channel,\n  AsyncResource\n} = require('./helpers/instrument');\n\nconst shimmer = require('../../datadog-shimmer');\n\nconst testStartCh = channel('ci:mocha:test:start');\nconst errorCh = channel('ci:mocha:test:error');\nconst skipCh = channel('ci:mocha:test:skip');\nconst testFinishCh = channel('ci:mocha:test:finish');\nconst parameterizedTestCh = channel('ci:mocha:test:parameterize');\nconst testRunStartCh = channel('ci:mocha:run:start');\nconst testRunFinishCh = channel('ci:mocha:run:finish');\nconst testSuiteStartCh = channel('ci:mocha:test-suite:start');\nconst testSuiteFinishCh = channel('ci:mocha:test-suite:finish');\nconst testSuiteErrorCh = channel('ci:mocha:test-suite:error'); // TODO: remove when root hooks and fixtures are implemented\n\nconst patched = new WeakSet();\nconst testToAr = new WeakMap();\nconst originalFns = new WeakMap();\nconst testFileToSuiteAr = new Map();\n\nfunction getSuitesByTestFile(root) {\n  const suitesByTestFile = {};\n\n  function getSuites(suite) {\n    if (suite.file) {\n      if (suitesByTestFile[suite.file]) {\n        suitesByTestFile[suite.file].push(suite);\n      } else {\n        suitesByTestFile[suite.file] = [suite];\n      }\n    }\n\n    suite.suites.forEach(suite => {\n      getSuites(suite);\n    });\n  }\n\n  getSuites(root);\n  const numSuitesByTestFile = Object.keys(suitesByTestFile).reduce((acc, testFile) => {\n    acc[testFile] = suitesByTestFile[testFile].length;\n    return acc;\n  }, {});\n  return {\n    suitesByTestFile,\n    numSuitesByTestFile\n  };\n}\n\nfunction getTestStatus(test) {\n  if (test.pending) {\n    return 'skip';\n  }\n\n  if (test.state !== 'failed' && !test.timedOut) {\n    return 'pass';\n  }\n\n  return 'fail';\n}\n\nfunction isRetry(test) {\n  return test._currentRetry !== undefined && test._currentRetry !== 0;\n}\n\nfunction getTestAsyncResource(test) {\n  if (!test.fn) {\n    return testToAr.get(test);\n  }\n\n  if (!test.fn.asyncResource) {\n    return testToAr.get(test.fn);\n  }\n\n  const originalFn = originalFns.get(test.fn);\n  return testToAr.get(originalFn);\n}\n\nfunction mochaHook(Runner) {\n  if (patched.has(Runner)) return Runner;\n  patched.add(Runner);\n  shimmer.wrap(Runner.prototype, 'run', run => function () {\n    if (!testStartCh.hasSubscribers) {\n      return run.apply(this, arguments);\n    }\n\n    const {\n      suitesByTestFile,\n      numSuitesByTestFile\n    } = getSuitesByTestFile(this.suite);\n    const testRunAsyncResource = new AsyncResource('bound-anonymous-fn');\n    this.once('end', testRunAsyncResource.bind(function () {\n      let status = 'pass';\n\n      if (this.stats) {\n        status = this.stats.failures === 0 ? 'pass' : 'fail';\n      } else if (this.failures !== 0) {\n        status = 'fail';\n      }\n\n      testFileToSuiteAr.clear();\n      testRunFinishCh.publish(status);\n    }));\n    this.once('start', testRunAsyncResource.bind(function () {\n      const processArgv = process.argv.slice(2).join(' ');\n      const command = `mocha ${processArgv}`;\n      testRunStartCh.publish(command);\n    }));\n    this.on('suite', function (suite) {\n      if (suite.root || !suite.tests.length) {\n        return;\n      }\n\n      let asyncResource = testFileToSuiteAr.get(suite.file);\n\n      if (!asyncResource) {\n        asyncResource = new AsyncResource('bound-anonymous-fn');\n        testFileToSuiteAr.set(suite.file, asyncResource);\n        asyncResource.runInAsyncScope(() => {\n          testSuiteStartCh.publish(suite);\n        });\n      }\n    });\n    this.on('suite end', function (suite) {\n      if (suite.root) {\n        return;\n      }\n\n      const suitesInTestFile = suitesByTestFile[suite.file];\n      const isLastSuite = --numSuitesByTestFile[suite.file] === 0;\n\n      if (!isLastSuite) {\n        return;\n      }\n\n      let status = 'pass';\n\n      if (suitesInTestFile.every(suite => suite.pending)) {\n        status = 'skip';\n      } else {\n        // has to check every test in the test file\n        suitesInTestFile.forEach(suite => {\n          suite.eachTest(test => {\n            if (test.state === 'failed' || test.timedOut) {\n              status = 'fail';\n            }\n          });\n        });\n      }\n\n      const asyncResource = testFileToSuiteAr.get(suite.file);\n      asyncResource.runInAsyncScope(() => {\n        // get suite status\n        testSuiteFinishCh.publish(status);\n      });\n    });\n    this.on('test', test => {\n      if (isRetry(test)) {\n        return;\n      }\n\n      const asyncResource = new AsyncResource('bound-anonymous-fn');\n      testToAr.set(test.fn, asyncResource);\n      asyncResource.runInAsyncScope(() => {\n        testStartCh.publish(test);\n      });\n    });\n    this.on('test end', test => {\n      const asyncResource = getTestAsyncResource(test);\n      const status = getTestStatus(test); // if there are afterEach to be run, we don't finish the test yet\n\n      if (asyncResource && !test.parent._afterEach.length) {\n        asyncResource.runInAsyncScope(() => {\n          testFinishCh.publish(status);\n        });\n      }\n    }); // If the hook passes, 'hook end' will be emitted. Otherwise, 'fail' will be emitted\n\n    this.on('hook end', hook => {\n      const test = hook.ctx.currentTest;\n\n      if (test && hook.parent._afterEach.includes(hook)) {\n        // only if it's an afterEach\n        const isLastAfterEach = hook.parent._afterEach.indexOf(hook) === hook.parent._afterEach.length - 1;\n\n        if (isLastAfterEach) {\n          const status = getTestStatus(test);\n          const asyncResource = getTestAsyncResource(test);\n          asyncResource.runInAsyncScope(() => {\n            testFinishCh.publish(status);\n          });\n        }\n      }\n    });\n    this.on('fail', (testOrHook, err) => {\n      const testFile = testOrHook.file;\n      let test = testOrHook;\n      const isHook = testOrHook.type === 'hook';\n\n      if (isHook && testOrHook.ctx) {\n        test = testOrHook.ctx.currentTest;\n      }\n\n      let testAsyncResource;\n\n      if (test) {\n        testAsyncResource = getTestAsyncResource(test);\n      }\n\n      if (testAsyncResource) {\n        testAsyncResource.runInAsyncScope(() => {\n          if (isHook) {\n            err.message = `${testOrHook.fullTitle()}: ${err.message}`;\n            errorCh.publish(err); // if it's a hook and it has failed, 'test end' will not be called\n\n            testFinishCh.publish('fail');\n          } else {\n            errorCh.publish(err);\n          }\n        });\n      }\n\n      const testSuiteAsyncResource = testFileToSuiteAr.get(testFile);\n\n      if (testSuiteAsyncResource) {\n        // we propagate the error to the suite\n        const testSuiteError = new Error(`\"${testOrHook.parent.fullTitle()}\" failed with message \"${err.message}\"`);\n        testSuiteError.stack = err.stack;\n        testSuiteAsyncResource.runInAsyncScope(() => {\n          testSuiteErrorCh.publish(testSuiteError);\n        });\n      }\n    });\n    this.on('pending', test => {\n      const asyncResource = getTestAsyncResource(test);\n\n      if (asyncResource) {\n        asyncResource.runInAsyncScope(() => {\n          skipCh.publish(test);\n        });\n      } else {\n        // if there is no async resource, the test has been skipped through `test.skip``\n        const skippedTestAsyncResource = new AsyncResource('bound-anonymous-fn');\n\n        if (test.fn) {\n          testToAr.set(test.fn, skippedTestAsyncResource);\n        } else {\n          testToAr.set(test, skippedTestAsyncResource);\n        }\n\n        skippedTestAsyncResource.runInAsyncScope(() => {\n          skipCh.publish(test);\n        });\n      }\n    });\n    return run.apply(this, arguments);\n  });\n  shimmer.wrap(Runner.prototype, 'runTests', runTests => function () {\n    if (!testRunFinishCh.hasSubscribers) {\n      return runTests.apply(this, arguments);\n    }\n\n    return runTests.apply(this, arguments);\n  });\n  return Runner;\n}\n\nfunction mochaEachHook(mochaEach) {\n  if (patched.has(mochaEach)) return mochaEach;\n  patched.add(mochaEach);\n  return shimmer.wrap(mochaEach, function () {\n    const [params] = arguments;\n    const {\n      it,\n      ...rest\n    } = mochaEach.apply(this, arguments);\n    return {\n      it: function (name) {\n        parameterizedTestCh.publish({\n          name,\n          params\n        });\n        it.apply(this, arguments);\n      },\n      ...rest\n    };\n  });\n}\n\naddHook({\n  name: 'mocha',\n  versions: ['>=5.2.0'],\n  file: 'lib/runner.js'\n}, mochaHook);\naddHook({\n  name: 'mocha',\n  versions: ['>=5.2.0'],\n  file: 'lib/runnable.js'\n}, Runnable => {\n  shimmer.wrap(Runnable.prototype, 'run', run => function () {\n    const isBeforeEach = this.parent._beforeEach.includes(this);\n\n    const isAfterEach = this.parent._afterEach.includes(this);\n\n    const isTestHook = isBeforeEach || isAfterEach; // we restore the original user defined function\n\n    if (this.fn.asyncResource) {\n      const originalFn = originalFns.get(this.fn);\n      this.fn = originalFn;\n    }\n\n    if (isTestHook || this.type === 'test') {\n      const test = isTestHook ? this.ctx.currentTest : this;\n      const asyncResource = getTestAsyncResource(test); // we bind the test fn to the correct async resource\n\n      const newFn = asyncResource.bind(this.fn); // we store the original function, not to lose it\n\n      originalFns.set(newFn, this.fn);\n      this.fn = newFn;\n    }\n\n    return run.apply(this, arguments);\n  });\n  return Runnable;\n});\naddHook({\n  name: 'mocha-each',\n  versions: ['>=2.0.1']\n}, mochaEachHook);\nmodule.exports = {\n  mochaHook,\n  mochaEachHook\n};","map":{"version":3,"names":["addHook","channel","AsyncResource","require","shimmer","testStartCh","errorCh","skipCh","testFinishCh","parameterizedTestCh","testRunStartCh","testRunFinishCh","testSuiteStartCh","testSuiteFinishCh","testSuiteErrorCh","patched","WeakSet","testToAr","WeakMap","originalFns","testFileToSuiteAr","Map","getSuitesByTestFile","root","suitesByTestFile","getSuites","suite","file","push","suites","forEach","numSuitesByTestFile","Object","keys","reduce","acc","testFile","length","getTestStatus","test","pending","state","timedOut","isRetry","_currentRetry","undefined","getTestAsyncResource","fn","get","asyncResource","originalFn","mochaHook","Runner","has","add","wrap","prototype","run","hasSubscribers","apply","arguments","testRunAsyncResource","once","bind","status","stats","failures","clear","publish","processArgv","process","argv","slice","join","command","on","tests","set","runInAsyncScope","suitesInTestFile","isLastSuite","every","eachTest","parent","_afterEach","hook","ctx","currentTest","includes","isLastAfterEach","indexOf","testOrHook","err","isHook","type","testAsyncResource","message","fullTitle","testSuiteAsyncResource","testSuiteError","Error","stack","skippedTestAsyncResource","runTests","mochaEachHook","mochaEach","params","it","rest","name","versions","Runnable","isBeforeEach","_beforeEach","isAfterEach","isTestHook","newFn","module","exports"],"sources":["/Users/daniel.calderon/Projects/barkito/barkito_front/node_modules/dd-trace/packages/datadog-instrumentations/src/mocha.js"],"sourcesContent":["const { addHook, channel, AsyncResource } = require('./helpers/instrument')\nconst shimmer = require('../../datadog-shimmer')\n\nconst testStartCh = channel('ci:mocha:test:start')\nconst errorCh = channel('ci:mocha:test:error')\nconst skipCh = channel('ci:mocha:test:skip')\nconst testFinishCh = channel('ci:mocha:test:finish')\nconst parameterizedTestCh = channel('ci:mocha:test:parameterize')\n\nconst testRunStartCh = channel('ci:mocha:run:start')\nconst testRunFinishCh = channel('ci:mocha:run:finish')\n\nconst testSuiteStartCh = channel('ci:mocha:test-suite:start')\nconst testSuiteFinishCh = channel('ci:mocha:test-suite:finish')\nconst testSuiteErrorCh = channel('ci:mocha:test-suite:error')\n\n// TODO: remove when root hooks and fixtures are implemented\nconst patched = new WeakSet()\n\nconst testToAr = new WeakMap()\nconst originalFns = new WeakMap()\nconst testFileToSuiteAr = new Map()\n\nfunction getSuitesByTestFile (root) {\n  const suitesByTestFile = {}\n  function getSuites (suite) {\n    if (suite.file) {\n      if (suitesByTestFile[suite.file]) {\n        suitesByTestFile[suite.file].push(suite)\n      } else {\n        suitesByTestFile[suite.file] = [suite]\n      }\n    }\n    suite.suites.forEach(suite => {\n      getSuites(suite)\n    })\n  }\n  getSuites(root)\n\n  const numSuitesByTestFile = Object.keys(suitesByTestFile).reduce((acc, testFile) => {\n    acc[testFile] = suitesByTestFile[testFile].length\n    return acc\n  }, {})\n\n  return { suitesByTestFile, numSuitesByTestFile }\n}\n\nfunction getTestStatus (test) {\n  if (test.pending) {\n    return 'skip'\n  }\n  if (test.state !== 'failed' && !test.timedOut) {\n    return 'pass'\n  }\n  return 'fail'\n}\n\nfunction isRetry (test) {\n  return test._currentRetry !== undefined && test._currentRetry !== 0\n}\n\nfunction getTestAsyncResource (test) {\n  if (!test.fn) {\n    return testToAr.get(test)\n  }\n  if (!test.fn.asyncResource) {\n    return testToAr.get(test.fn)\n  }\n  const originalFn = originalFns.get(test.fn)\n  return testToAr.get(originalFn)\n}\n\nfunction mochaHook (Runner) {\n  if (patched.has(Runner)) return Runner\n\n  patched.add(Runner)\n\n  shimmer.wrap(Runner.prototype, 'run', run => function () {\n    if (!testStartCh.hasSubscribers) {\n      return run.apply(this, arguments)\n    }\n\n    const { suitesByTestFile, numSuitesByTestFile } = getSuitesByTestFile(this.suite)\n\n    const testRunAsyncResource = new AsyncResource('bound-anonymous-fn')\n\n    this.once('end', testRunAsyncResource.bind(function () {\n      let status = 'pass'\n      if (this.stats) {\n        status = this.stats.failures === 0 ? 'pass' : 'fail'\n      } else if (this.failures !== 0) {\n        status = 'fail'\n      }\n      testFileToSuiteAr.clear()\n      testRunFinishCh.publish(status)\n    }))\n\n    this.once('start', testRunAsyncResource.bind(function () {\n      const processArgv = process.argv.slice(2).join(' ')\n      const command = `mocha ${processArgv}`\n      testRunStartCh.publish(command)\n    }))\n\n    this.on('suite', function (suite) {\n      if (suite.root || !suite.tests.length) {\n        return\n      }\n      let asyncResource = testFileToSuiteAr.get(suite.file)\n      if (!asyncResource) {\n        asyncResource = new AsyncResource('bound-anonymous-fn')\n        testFileToSuiteAr.set(suite.file, asyncResource)\n        asyncResource.runInAsyncScope(() => {\n          testSuiteStartCh.publish(suite)\n        })\n      }\n    })\n\n    this.on('suite end', function (suite) {\n      if (suite.root) {\n        return\n      }\n      const suitesInTestFile = suitesByTestFile[suite.file]\n\n      const isLastSuite = --numSuitesByTestFile[suite.file] === 0\n      if (!isLastSuite) {\n        return\n      }\n\n      let status = 'pass'\n      if (suitesInTestFile.every(suite => suite.pending)) {\n        status = 'skip'\n      } else {\n        // has to check every test in the test file\n        suitesInTestFile.forEach(suite => {\n          suite.eachTest(test => {\n            if (test.state === 'failed' || test.timedOut) {\n              status = 'fail'\n            }\n          })\n        })\n      }\n\n      const asyncResource = testFileToSuiteAr.get(suite.file)\n      asyncResource.runInAsyncScope(() => {\n        // get suite status\n        testSuiteFinishCh.publish(status)\n      })\n    })\n\n    this.on('test', (test) => {\n      if (isRetry(test)) {\n        return\n      }\n      const asyncResource = new AsyncResource('bound-anonymous-fn')\n      testToAr.set(test.fn, asyncResource)\n      asyncResource.runInAsyncScope(() => {\n        testStartCh.publish(test)\n      })\n    })\n\n    this.on('test end', (test) => {\n      const asyncResource = getTestAsyncResource(test)\n      const status = getTestStatus(test)\n\n      // if there are afterEach to be run, we don't finish the test yet\n      if (asyncResource && !test.parent._afterEach.length) {\n        asyncResource.runInAsyncScope(() => {\n          testFinishCh.publish(status)\n        })\n      }\n    })\n\n    // If the hook passes, 'hook end' will be emitted. Otherwise, 'fail' will be emitted\n    this.on('hook end', (hook) => {\n      const test = hook.ctx.currentTest\n      if (test && hook.parent._afterEach.includes(hook)) { // only if it's an afterEach\n        const isLastAfterEach = hook.parent._afterEach.indexOf(hook) === hook.parent._afterEach.length - 1\n        if (isLastAfterEach) {\n          const status = getTestStatus(test)\n          const asyncResource = getTestAsyncResource(test)\n          asyncResource.runInAsyncScope(() => {\n            testFinishCh.publish(status)\n          })\n        }\n      }\n    })\n\n    this.on('fail', (testOrHook, err) => {\n      const testFile = testOrHook.file\n      let test = testOrHook\n      const isHook = testOrHook.type === 'hook'\n      if (isHook && testOrHook.ctx) {\n        test = testOrHook.ctx.currentTest\n      }\n      let testAsyncResource\n      if (test) {\n        testAsyncResource = getTestAsyncResource(test)\n      }\n      if (testAsyncResource) {\n        testAsyncResource.runInAsyncScope(() => {\n          if (isHook) {\n            err.message = `${testOrHook.fullTitle()}: ${err.message}`\n            errorCh.publish(err)\n            // if it's a hook and it has failed, 'test end' will not be called\n            testFinishCh.publish('fail')\n          } else {\n            errorCh.publish(err)\n          }\n        })\n      }\n      const testSuiteAsyncResource = testFileToSuiteAr.get(testFile)\n\n      if (testSuiteAsyncResource) {\n        // we propagate the error to the suite\n        const testSuiteError = new Error(\n          `\"${testOrHook.parent.fullTitle()}\" failed with message \"${err.message}\"`\n        )\n        testSuiteError.stack = err.stack\n        testSuiteAsyncResource.runInAsyncScope(() => {\n          testSuiteErrorCh.publish(testSuiteError)\n        })\n      }\n    })\n\n    this.on('pending', (test) => {\n      const asyncResource = getTestAsyncResource(test)\n      if (asyncResource) {\n        asyncResource.runInAsyncScope(() => {\n          skipCh.publish(test)\n        })\n      } else {\n        // if there is no async resource, the test has been skipped through `test.skip``\n        const skippedTestAsyncResource = new AsyncResource('bound-anonymous-fn')\n        if (test.fn) {\n          testToAr.set(test.fn, skippedTestAsyncResource)\n        } else {\n          testToAr.set(test, skippedTestAsyncResource)\n        }\n        skippedTestAsyncResource.runInAsyncScope(() => {\n          skipCh.publish(test)\n        })\n      }\n    })\n\n    return run.apply(this, arguments)\n  })\n\n  shimmer.wrap(Runner.prototype, 'runTests', runTests => function () {\n    if (!testRunFinishCh.hasSubscribers) {\n      return runTests.apply(this, arguments)\n    }\n    return runTests.apply(this, arguments)\n  })\n\n  return Runner\n}\n\nfunction mochaEachHook (mochaEach) {\n  if (patched.has(mochaEach)) return mochaEach\n\n  patched.add(mochaEach)\n\n  return shimmer.wrap(mochaEach, function () {\n    const [params] = arguments\n    const { it, ...rest } = mochaEach.apply(this, arguments)\n    return {\n      it: function (name) {\n        parameterizedTestCh.publish({ name, params })\n        it.apply(this, arguments)\n      },\n      ...rest\n    }\n  })\n}\n\naddHook({\n  name: 'mocha',\n  versions: ['>=5.2.0'],\n  file: 'lib/runner.js'\n}, mochaHook)\n\naddHook({\n  name: 'mocha',\n  versions: ['>=5.2.0'],\n  file: 'lib/runnable.js'\n}, (Runnable) => {\n  shimmer.wrap(Runnable.prototype, 'run', run => function () {\n    const isBeforeEach = this.parent._beforeEach.includes(this)\n    const isAfterEach = this.parent._afterEach.includes(this)\n\n    const isTestHook = isBeforeEach || isAfterEach\n\n    // we restore the original user defined function\n    if (this.fn.asyncResource) {\n      const originalFn = originalFns.get(this.fn)\n      this.fn = originalFn\n    }\n\n    if (isTestHook || this.type === 'test') {\n      const test = isTestHook ? this.ctx.currentTest : this\n      const asyncResource = getTestAsyncResource(test)\n\n      // we bind the test fn to the correct async resource\n      const newFn = asyncResource.bind(this.fn)\n\n      // we store the original function, not to lose it\n      originalFns.set(newFn, this.fn)\n\n      this.fn = newFn\n    }\n\n    return run.apply(this, arguments)\n  })\n  return Runnable\n})\n\naddHook({\n  name: 'mocha-each',\n  versions: ['>=2.0.1']\n}, mochaEachHook)\n\nmodule.exports = { mochaHook, mochaEachHook }\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}