{"ast":null,"code":"\"use strict\";\n/*\n * Unless explicitly stated otherwise all files in this repository are licensed\n * under the Apache 2.0 license (see LICENSE).\n * This product includes software developed at Datadog (https://www.datadoghq.com/).\n * Copyright 2020 Datadog, Inc.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.KeyMapping = void 0;\n\nvar index_1 = require(\"./index\"); // 1.1125369292536007e-308\n\n\nvar MIN_SAFE_FLOAT = Math.pow(2, -1023);\nvar MAX_SAFE_FLOAT = Number.MAX_VALUE;\n/**\n * A mapping between values and integer indices that imposes relative accuracy\n * guarantees. Specifically, for any value `minPossible() < value <\n * maxPossible` implementations of `KeyMapping` must be such that\n * `value(key(v))` is close to `v` with a relative error that is less than\n * `relativeAccuracy`.\n *\n * In implementations of KeyMapping, there is generally a trade-off between the\n * cost of computing the key and the number of keys that are required to cover a\n * given range of values (memory optimality). The most memory-optimal mapping is\n * the LogarithmicMapping, but it requires the costly evaluation of the logarithm\n * when computing the index. Other mappings can approximate the logarithmic\n * mapping, while being less computationally costly.\n */\n\nvar KeyMapping =\n/** @class */\nfunction () {\n  function KeyMapping(relativeAccuracy, offset) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n\n    if (relativeAccuracy <= 0 || relativeAccuracy >= 1) {\n      throw Error('Relative accuracy must be between 0 and 1 when initializing a KeyMapping');\n    }\n\n    this.relativeAccuracy = relativeAccuracy;\n    this._offset = offset;\n    var gammaMantissa = 2 * relativeAccuracy / (1 - relativeAccuracy);\n    this.gamma = 1 + gammaMantissa;\n    this._multiplier = 1 / Math.log1p(gammaMantissa);\n    this.minPossible = MIN_SAFE_FLOAT * this.gamma;\n    this.maxPossible = MAX_SAFE_FLOAT / this.gamma;\n  }\n\n  KeyMapping.fromGammaOffset = function (gamma, indexOffset) {\n    var relativeAccuracy = (gamma - 1) / (gamma + 1);\n    return new this(relativeAccuracy, indexOffset);\n  };\n  /** Retrieve the key specifying the bucket for a `value` */\n\n\n  KeyMapping.prototype.key = function (value) {\n    return Math.ceil(this._logGamma(value)) + this._offset;\n  };\n  /** Retrieve the value represented by the bucket at `key` */\n\n\n  KeyMapping.prototype.value = function (key) {\n    return this._powGamma(key - this._offset) * (2 / (1 + this.gamma));\n  };\n\n  KeyMapping.prototype.toProto = function () {\n    var ProtoIndexMapping = require('../proto/compiled').IndexMapping;\n\n    return ProtoIndexMapping.create({\n      gamma: this.gamma,\n      indexOffset: this._offset,\n      interpolation: this._protoInterpolation()\n    });\n  };\n\n  KeyMapping.fromProto = function (protoMapping) {\n    if (!protoMapping ||\n    /* Double equals (==) is intentional here to check for\n     * `null` | `undefined` without including `0` */\n    protoMapping.gamma == null || protoMapping.indexOffset == null) {\n      throw Error('Failed to decode mapping from protobuf');\n    }\n\n    var Interpolation = require('../proto/compiled').IndexMapping.Interpolation;\n\n    var interpolation = protoMapping.interpolation,\n        gamma = protoMapping.gamma,\n        indexOffset = protoMapping.indexOffset;\n\n    switch (interpolation) {\n      case Interpolation.NONE:\n        return index_1.LogarithmicMapping.fromGammaOffset(gamma, indexOffset);\n\n      case Interpolation.LINEAR:\n        return index_1.LinearlyInterpolatedMapping.fromGammaOffset(gamma, indexOffset);\n\n      case Interpolation.CUBIC:\n        return index_1.CubicallyInterpolatedMapping.fromGammaOffset(gamma, indexOffset);\n\n      default:\n        throw Error('Unrecognized mapping when decoding from protobuf');\n    }\n  };\n  /** Return (an approximation of) the logarithm of the value base gamma */\n\n\n  KeyMapping.prototype._logGamma = function (value) {\n    return Math.log2(value) * this._multiplier;\n  };\n  /** Return (an approximation of) gamma to the power value */\n\n\n  KeyMapping.prototype._powGamma = function (value) {\n    return Math.pow(2, value / this._multiplier);\n  };\n\n  KeyMapping.prototype._protoInterpolation = function () {\n    var Interpolation = require('../proto/compiled').IndexMapping.Interpolation;\n\n    return Interpolation.NONE;\n  };\n\n  return KeyMapping;\n}();\n\nexports.KeyMapping = KeyMapping;","map":{"version":3,"names":["Object","defineProperty","exports","value","KeyMapping","index_1","require","MIN_SAFE_FLOAT","Math","pow","MAX_SAFE_FLOAT","Number","MAX_VALUE","relativeAccuracy","offset","Error","_offset","gammaMantissa","gamma","_multiplier","log1p","minPossible","maxPossible","fromGammaOffset","indexOffset","prototype","key","ceil","_logGamma","_powGamma","toProto","ProtoIndexMapping","IndexMapping","create","interpolation","_protoInterpolation","fromProto","protoMapping","Interpolation","NONE","LogarithmicMapping","LINEAR","LinearlyInterpolatedMapping","CUBIC","CubicallyInterpolatedMapping","log2"],"sources":["/Users/daniel.calderon/Projects/barkito/barkito_front/node_modules/@datadog/sketches-js/dist/ddsketch/mapping/KeyMapping.js"],"sourcesContent":["\"use strict\";\n/*\n * Unless explicitly stated otherwise all files in this repository are licensed\n * under the Apache 2.0 license (see LICENSE).\n * This product includes software developed at Datadog (https://www.datadoghq.com/).\n * Copyright 2020 Datadog, Inc.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.KeyMapping = void 0;\nvar index_1 = require(\"./index\");\n// 1.1125369292536007e-308\nvar MIN_SAFE_FLOAT = Math.pow(2, -1023);\nvar MAX_SAFE_FLOAT = Number.MAX_VALUE;\n/**\n * A mapping between values and integer indices that imposes relative accuracy\n * guarantees. Specifically, for any value `minPossible() < value <\n * maxPossible` implementations of `KeyMapping` must be such that\n * `value(key(v))` is close to `v` with a relative error that is less than\n * `relativeAccuracy`.\n *\n * In implementations of KeyMapping, there is generally a trade-off between the\n * cost of computing the key and the number of keys that are required to cover a\n * given range of values (memory optimality). The most memory-optimal mapping is\n * the LogarithmicMapping, but it requires the costly evaluation of the logarithm\n * when computing the index. Other mappings can approximate the logarithmic\n * mapping, while being less computationally costly.\n */\nvar KeyMapping = /** @class */ (function () {\n    function KeyMapping(relativeAccuracy, offset) {\n        if (offset === void 0) { offset = 0; }\n        if (relativeAccuracy <= 0 || relativeAccuracy >= 1) {\n            throw Error('Relative accuracy must be between 0 and 1 when initializing a KeyMapping');\n        }\n        this.relativeAccuracy = relativeAccuracy;\n        this._offset = offset;\n        var gammaMantissa = (2 * relativeAccuracy) / (1 - relativeAccuracy);\n        this.gamma = 1 + gammaMantissa;\n        this._multiplier = 1 / Math.log1p(gammaMantissa);\n        this.minPossible = MIN_SAFE_FLOAT * this.gamma;\n        this.maxPossible = MAX_SAFE_FLOAT / this.gamma;\n    }\n    KeyMapping.fromGammaOffset = function (gamma, indexOffset) {\n        var relativeAccuracy = (gamma - 1) / (gamma + 1);\n        return new this(relativeAccuracy, indexOffset);\n    };\n    /** Retrieve the key specifying the bucket for a `value` */\n    KeyMapping.prototype.key = function (value) {\n        return Math.ceil(this._logGamma(value)) + this._offset;\n    };\n    /** Retrieve the value represented by the bucket at `key` */\n    KeyMapping.prototype.value = function (key) {\n        return this._powGamma(key - this._offset) * (2 / (1 + this.gamma));\n    };\n    KeyMapping.prototype.toProto = function () {\n        var ProtoIndexMapping = require('../proto/compiled').IndexMapping;\n        return ProtoIndexMapping.create({\n            gamma: this.gamma,\n            indexOffset: this._offset,\n            interpolation: this._protoInterpolation()\n        });\n    };\n    KeyMapping.fromProto = function (protoMapping) {\n        if (!protoMapping ||\n            /* Double equals (==) is intentional here to check for\n             * `null` | `undefined` without including `0` */\n            protoMapping.gamma == null ||\n            protoMapping.indexOffset == null) {\n            throw Error('Failed to decode mapping from protobuf');\n        }\n        var Interpolation = require('../proto/compiled').IndexMapping.Interpolation;\n        var interpolation = protoMapping.interpolation, gamma = protoMapping.gamma, indexOffset = protoMapping.indexOffset;\n        switch (interpolation) {\n            case Interpolation.NONE:\n                return index_1.LogarithmicMapping.fromGammaOffset(gamma, indexOffset);\n            case Interpolation.LINEAR:\n                return index_1.LinearlyInterpolatedMapping.fromGammaOffset(gamma, indexOffset);\n            case Interpolation.CUBIC:\n                return index_1.CubicallyInterpolatedMapping.fromGammaOffset(gamma, indexOffset);\n            default:\n                throw Error('Unrecognized mapping when decoding from protobuf');\n        }\n    };\n    /** Return (an approximation of) the logarithm of the value base gamma */\n    KeyMapping.prototype._logGamma = function (value) {\n        return Math.log2(value) * this._multiplier;\n    };\n    /** Return (an approximation of) gamma to the power value */\n    KeyMapping.prototype._powGamma = function (value) {\n        return Math.pow(2, value / this._multiplier);\n    };\n    KeyMapping.prototype._protoInterpolation = function () {\n        var Interpolation = require('../proto/compiled').IndexMapping.Interpolation;\n        return Interpolation.NONE;\n    };\n    return KeyMapping;\n}());\nexports.KeyMapping = KeyMapping;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}