{"ast":null,"code":"/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\n\"use strict\";\n\nvar $protobuf = require(\"protobufjs/minimal\"); // Common aliases\n\n\nvar $Reader = $protobuf.Reader,\n    $Writer = $protobuf.Writer,\n    $util = $protobuf.util; // Exported root namespace\n\nvar $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n\n$root.DDSketch = function () {\n  /**\n   * Properties of a DDSketch.\n   * @exports IDDSketch\n   * @interface IDDSketch\n   * @property {IIndexMapping|null} [mapping] DDSketch mapping\n   * @property {IStore|null} [positiveValues] DDSketch positiveValues\n   * @property {IStore|null} [negativeValues] DDSketch negativeValues\n   * @property {number|null} [zeroCount] DDSketch zeroCount\n   */\n\n  /**\n   * Constructs a new DDSketch.\n   * @exports DDSketch\n   * @classdesc Represents a DDSketch.\n   * @implements IDDSketch\n   * @constructor\n   * @param {IDDSketch=} [properties] Properties to set\n   */\n  function DDSketch(properties) {\n    if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * DDSketch mapping.\n   * @member {IIndexMapping|null|undefined} mapping\n   * @memberof DDSketch\n   * @instance\n   */\n\n\n  DDSketch.prototype.mapping = null;\n  /**\n   * DDSketch positiveValues.\n   * @member {IStore|null|undefined} positiveValues\n   * @memberof DDSketch\n   * @instance\n   */\n\n  DDSketch.prototype.positiveValues = null;\n  /**\n   * DDSketch negativeValues.\n   * @member {IStore|null|undefined} negativeValues\n   * @memberof DDSketch\n   * @instance\n   */\n\n  DDSketch.prototype.negativeValues = null;\n  /**\n   * DDSketch zeroCount.\n   * @member {number} zeroCount\n   * @memberof DDSketch\n   * @instance\n   */\n\n  DDSketch.prototype.zeroCount = 0;\n  /**\n   * Creates a new DDSketch instance using the specified properties.\n   * @function create\n   * @memberof DDSketch\n   * @static\n   * @param {IDDSketch=} [properties] Properties to set\n   * @returns {DDSketch} DDSketch instance\n   */\n\n  DDSketch.create = function create(properties) {\n    return new DDSketch(properties);\n  };\n  /**\n   * Encodes the specified DDSketch message. Does not implicitly {@link DDSketch.verify|verify} messages.\n   * @function encode\n   * @memberof DDSketch\n   * @static\n   * @param {IDDSketch} message DDSketch message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n\n  DDSketch.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create();\n    if (message.mapping != null && Object.hasOwnProperty.call(message, \"mapping\")) $root.IndexMapping.encode(message.mapping, writer.uint32(\n    /* id 1, wireType 2 =*/\n    10).fork()).ldelim();\n    if (message.positiveValues != null && Object.hasOwnProperty.call(message, \"positiveValues\")) $root.Store.encode(message.positiveValues, writer.uint32(\n    /* id 2, wireType 2 =*/\n    18).fork()).ldelim();\n    if (message.negativeValues != null && Object.hasOwnProperty.call(message, \"negativeValues\")) $root.Store.encode(message.negativeValues, writer.uint32(\n    /* id 3, wireType 2 =*/\n    26).fork()).ldelim();\n    if (message.zeroCount != null && Object.hasOwnProperty.call(message, \"zeroCount\")) writer.uint32(\n    /* id 4, wireType 1 =*/\n    33).double(message.zeroCount);\n    return writer;\n  };\n  /**\n   * Encodes the specified DDSketch message, length delimited. Does not implicitly {@link DDSketch.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof DDSketch\n   * @static\n   * @param {IDDSketch} message DDSketch message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n\n  DDSketch.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim();\n  };\n  /**\n   * Decodes a DDSketch message from the specified reader or buffer.\n   * @function decode\n   * @memberof DDSketch\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {DDSketch} DDSketch\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  DDSketch.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.DDSketch();\n\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.mapping = $root.IndexMapping.decode(reader, reader.uint32());\n          break;\n\n        case 2:\n          message.positiveValues = $root.Store.decode(reader, reader.uint32());\n          break;\n\n        case 3:\n          message.negativeValues = $root.Store.decode(reader, reader.uint32());\n          break;\n\n        case 4:\n          message.zeroCount = reader.double();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n  /**\n   * Decodes a DDSketch message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof DDSketch\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {DDSketch} DDSketch\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  DDSketch.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n    return this.decode(reader, reader.uint32());\n  };\n  /**\n   * Verifies a DDSketch message.\n   * @function verify\n   * @memberof DDSketch\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n\n\n  DDSketch.verify = function verify(message) {\n    if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n    if (message.mapping != null && message.hasOwnProperty(\"mapping\")) {\n      var error = $root.IndexMapping.verify(message.mapping);\n      if (error) return \"mapping.\" + error;\n    }\n\n    if (message.positiveValues != null && message.hasOwnProperty(\"positiveValues\")) {\n      var error = $root.Store.verify(message.positiveValues);\n      if (error) return \"positiveValues.\" + error;\n    }\n\n    if (message.negativeValues != null && message.hasOwnProperty(\"negativeValues\")) {\n      var error = $root.Store.verify(message.negativeValues);\n      if (error) return \"negativeValues.\" + error;\n    }\n\n    if (message.zeroCount != null && message.hasOwnProperty(\"zeroCount\")) if (typeof message.zeroCount !== \"number\") return \"zeroCount: number expected\";\n    return null;\n  };\n  /**\n   * Creates a DDSketch message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof DDSketch\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {DDSketch} DDSketch\n   */\n\n\n  DDSketch.fromObject = function fromObject(object) {\n    if (object instanceof $root.DDSketch) return object;\n    var message = new $root.DDSketch();\n\n    if (object.mapping != null) {\n      if (typeof object.mapping !== \"object\") throw TypeError(\".DDSketch.mapping: object expected\");\n      message.mapping = $root.IndexMapping.fromObject(object.mapping);\n    }\n\n    if (object.positiveValues != null) {\n      if (typeof object.positiveValues !== \"object\") throw TypeError(\".DDSketch.positiveValues: object expected\");\n      message.positiveValues = $root.Store.fromObject(object.positiveValues);\n    }\n\n    if (object.negativeValues != null) {\n      if (typeof object.negativeValues !== \"object\") throw TypeError(\".DDSketch.negativeValues: object expected\");\n      message.negativeValues = $root.Store.fromObject(object.negativeValues);\n    }\n\n    if (object.zeroCount != null) message.zeroCount = Number(object.zeroCount);\n    return message;\n  };\n  /**\n   * Creates a plain object from a DDSketch message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof DDSketch\n   * @static\n   * @param {DDSketch} message DDSketch\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n\n\n  DDSketch.toObject = function toObject(message, options) {\n    if (!options) options = {};\n    var object = {};\n\n    if (options.defaults) {\n      object.mapping = null;\n      object.positiveValues = null;\n      object.negativeValues = null;\n      object.zeroCount = 0;\n    }\n\n    if (message.mapping != null && message.hasOwnProperty(\"mapping\")) object.mapping = $root.IndexMapping.toObject(message.mapping, options);\n    if (message.positiveValues != null && message.hasOwnProperty(\"positiveValues\")) object.positiveValues = $root.Store.toObject(message.positiveValues, options);\n    if (message.negativeValues != null && message.hasOwnProperty(\"negativeValues\")) object.negativeValues = $root.Store.toObject(message.negativeValues, options);\n    if (message.zeroCount != null && message.hasOwnProperty(\"zeroCount\")) object.zeroCount = options.json && !isFinite(message.zeroCount) ? String(message.zeroCount) : message.zeroCount;\n    return object;\n  };\n  /**\n   * Converts this DDSketch to JSON.\n   * @function toJSON\n   * @memberof DDSketch\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n\n\n  DDSketch.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n  };\n\n  return DDSketch;\n}();\n\n$root.IndexMapping = function () {\n  /**\n   * Properties of an IndexMapping.\n   * @exports IIndexMapping\n   * @interface IIndexMapping\n   * @property {number|null} [gamma] IndexMapping gamma\n   * @property {number|null} [indexOffset] IndexMapping indexOffset\n   * @property {IndexMapping.Interpolation|null} [interpolation] IndexMapping interpolation\n   */\n\n  /**\n   * Constructs a new IndexMapping.\n   * @exports IndexMapping\n   * @classdesc Represents an IndexMapping.\n   * @implements IIndexMapping\n   * @constructor\n   * @param {IIndexMapping=} [properties] Properties to set\n   */\n  function IndexMapping(properties) {\n    if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * IndexMapping gamma.\n   * @member {number} gamma\n   * @memberof IndexMapping\n   * @instance\n   */\n\n\n  IndexMapping.prototype.gamma = 0;\n  /**\n   * IndexMapping indexOffset.\n   * @member {number} indexOffset\n   * @memberof IndexMapping\n   * @instance\n   */\n\n  IndexMapping.prototype.indexOffset = 0;\n  /**\n   * IndexMapping interpolation.\n   * @member {IndexMapping.Interpolation} interpolation\n   * @memberof IndexMapping\n   * @instance\n   */\n\n  IndexMapping.prototype.interpolation = 0;\n  /**\n   * Creates a new IndexMapping instance using the specified properties.\n   * @function create\n   * @memberof IndexMapping\n   * @static\n   * @param {IIndexMapping=} [properties] Properties to set\n   * @returns {IndexMapping} IndexMapping instance\n   */\n\n  IndexMapping.create = function create(properties) {\n    return new IndexMapping(properties);\n  };\n  /**\n   * Encodes the specified IndexMapping message. Does not implicitly {@link IndexMapping.verify|verify} messages.\n   * @function encode\n   * @memberof IndexMapping\n   * @static\n   * @param {IIndexMapping} message IndexMapping message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n\n  IndexMapping.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create();\n    if (message.gamma != null && Object.hasOwnProperty.call(message, \"gamma\")) writer.uint32(\n    /* id 1, wireType 1 =*/\n    9).double(message.gamma);\n    if (message.indexOffset != null && Object.hasOwnProperty.call(message, \"indexOffset\")) writer.uint32(\n    /* id 2, wireType 1 =*/\n    17).double(message.indexOffset);\n    if (message.interpolation != null && Object.hasOwnProperty.call(message, \"interpolation\")) writer.uint32(\n    /* id 3, wireType 0 =*/\n    24).int32(message.interpolation);\n    return writer;\n  };\n  /**\n   * Encodes the specified IndexMapping message, length delimited. Does not implicitly {@link IndexMapping.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof IndexMapping\n   * @static\n   * @param {IIndexMapping} message IndexMapping message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n\n  IndexMapping.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim();\n  };\n  /**\n   * Decodes an IndexMapping message from the specified reader or buffer.\n   * @function decode\n   * @memberof IndexMapping\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {IndexMapping} IndexMapping\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  IndexMapping.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.IndexMapping();\n\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.gamma = reader.double();\n          break;\n\n        case 2:\n          message.indexOffset = reader.double();\n          break;\n\n        case 3:\n          message.interpolation = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n  /**\n   * Decodes an IndexMapping message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof IndexMapping\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {IndexMapping} IndexMapping\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  IndexMapping.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n    return this.decode(reader, reader.uint32());\n  };\n  /**\n   * Verifies an IndexMapping message.\n   * @function verify\n   * @memberof IndexMapping\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n\n\n  IndexMapping.verify = function verify(message) {\n    if (typeof message !== \"object\" || message === null) return \"object expected\";\n    if (message.gamma != null && message.hasOwnProperty(\"gamma\")) if (typeof message.gamma !== \"number\") return \"gamma: number expected\";\n    if (message.indexOffset != null && message.hasOwnProperty(\"indexOffset\")) if (typeof message.indexOffset !== \"number\") return \"indexOffset: number expected\";\n    if (message.interpolation != null && message.hasOwnProperty(\"interpolation\")) switch (message.interpolation) {\n      default:\n        return \"interpolation: enum value expected\";\n\n      case 0:\n      case 1:\n      case 2:\n      case 3:\n        break;\n    }\n    return null;\n  };\n  /**\n   * Creates an IndexMapping message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof IndexMapping\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {IndexMapping} IndexMapping\n   */\n\n\n  IndexMapping.fromObject = function fromObject(object) {\n    if (object instanceof $root.IndexMapping) return object;\n    var message = new $root.IndexMapping();\n    if (object.gamma != null) message.gamma = Number(object.gamma);\n    if (object.indexOffset != null) message.indexOffset = Number(object.indexOffset);\n\n    switch (object.interpolation) {\n      case \"NONE\":\n      case 0:\n        message.interpolation = 0;\n        break;\n\n      case \"LINEAR\":\n      case 1:\n        message.interpolation = 1;\n        break;\n\n      case \"QUADRATIC\":\n      case 2:\n        message.interpolation = 2;\n        break;\n\n      case \"CUBIC\":\n      case 3:\n        message.interpolation = 3;\n        break;\n    }\n\n    return message;\n  };\n  /**\n   * Creates a plain object from an IndexMapping message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof IndexMapping\n   * @static\n   * @param {IndexMapping} message IndexMapping\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n\n\n  IndexMapping.toObject = function toObject(message, options) {\n    if (!options) options = {};\n    var object = {};\n\n    if (options.defaults) {\n      object.gamma = 0;\n      object.indexOffset = 0;\n      object.interpolation = options.enums === String ? \"NONE\" : 0;\n    }\n\n    if (message.gamma != null && message.hasOwnProperty(\"gamma\")) object.gamma = options.json && !isFinite(message.gamma) ? String(message.gamma) : message.gamma;\n    if (message.indexOffset != null && message.hasOwnProperty(\"indexOffset\")) object.indexOffset = options.json && !isFinite(message.indexOffset) ? String(message.indexOffset) : message.indexOffset;\n    if (message.interpolation != null && message.hasOwnProperty(\"interpolation\")) object.interpolation = options.enums === String ? $root.IndexMapping.Interpolation[message.interpolation] : message.interpolation;\n    return object;\n  };\n  /**\n   * Converts this IndexMapping to JSON.\n   * @function toJSON\n   * @memberof IndexMapping\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n\n\n  IndexMapping.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n  };\n  /**\n   * Interpolation enum.\n   * @name IndexMapping.Interpolation\n   * @enum {number}\n   * @property {number} NONE=0 NONE value\n   * @property {number} LINEAR=1 LINEAR value\n   * @property {number} QUADRATIC=2 QUADRATIC value\n   * @property {number} CUBIC=3 CUBIC value\n   */\n\n\n  IndexMapping.Interpolation = function () {\n    var valuesById = {},\n        values = Object.create(valuesById);\n    values[valuesById[0] = \"NONE\"] = 0;\n    values[valuesById[1] = \"LINEAR\"] = 1;\n    values[valuesById[2] = \"QUADRATIC\"] = 2;\n    values[valuesById[3] = \"CUBIC\"] = 3;\n    return values;\n  }();\n\n  return IndexMapping;\n}();\n\n$root.Store = function () {\n  /**\n   * Properties of a Store.\n   * @exports IStore\n   * @interface IStore\n   * @property {Object.<string,number>|null} [binCounts] Store binCounts\n   * @property {Array.<number>|null} [contiguousBinCounts] Store contiguousBinCounts\n   * @property {number|null} [contiguousBinIndexOffset] Store contiguousBinIndexOffset\n   */\n\n  /**\n   * Constructs a new Store.\n   * @exports Store\n   * @classdesc Represents a Store.\n   * @implements IStore\n   * @constructor\n   * @param {IStore=} [properties] Properties to set\n   */\n  function Store(properties) {\n    this.binCounts = {};\n    this.contiguousBinCounts = [];\n    if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * Store binCounts.\n   * @member {Object.<string,number>} binCounts\n   * @memberof Store\n   * @instance\n   */\n\n\n  Store.prototype.binCounts = $util.emptyObject;\n  /**\n   * Store contiguousBinCounts.\n   * @member {Array.<number>} contiguousBinCounts\n   * @memberof Store\n   * @instance\n   */\n\n  Store.prototype.contiguousBinCounts = $util.emptyArray;\n  /**\n   * Store contiguousBinIndexOffset.\n   * @member {number} contiguousBinIndexOffset\n   * @memberof Store\n   * @instance\n   */\n\n  Store.prototype.contiguousBinIndexOffset = 0;\n  /**\n   * Creates a new Store instance using the specified properties.\n   * @function create\n   * @memberof Store\n   * @static\n   * @param {IStore=} [properties] Properties to set\n   * @returns {Store} Store instance\n   */\n\n  Store.create = function create(properties) {\n    return new Store(properties);\n  };\n  /**\n   * Encodes the specified Store message. Does not implicitly {@link Store.verify|verify} messages.\n   * @function encode\n   * @memberof Store\n   * @static\n   * @param {IStore} message Store message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n\n  Store.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create();\n    if (message.binCounts != null && Object.hasOwnProperty.call(message, \"binCounts\")) for (var keys = Object.keys(message.binCounts), i = 0; i < keys.length; ++i) writer.uint32(\n    /* id 1, wireType 2 =*/\n    10).fork().uint32(\n    /* id 1, wireType 0 =*/\n    8).sint32(keys[i]).uint32(\n    /* id 2, wireType 1 =*/\n    17).double(message.binCounts[keys[i]]).ldelim();\n\n    if (message.contiguousBinCounts != null && message.contiguousBinCounts.length) {\n      writer.uint32(\n      /* id 2, wireType 2 =*/\n      18).fork();\n\n      for (var i = 0; i < message.contiguousBinCounts.length; ++i) writer.double(message.contiguousBinCounts[i]);\n\n      writer.ldelim();\n    }\n\n    if (message.contiguousBinIndexOffset != null && Object.hasOwnProperty.call(message, \"contiguousBinIndexOffset\")) writer.uint32(\n    /* id 3, wireType 0 =*/\n    24).sint32(message.contiguousBinIndexOffset);\n    return writer;\n  };\n  /**\n   * Encodes the specified Store message, length delimited. Does not implicitly {@link Store.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof Store\n   * @static\n   * @param {IStore} message Store message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n\n  Store.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim();\n  };\n  /**\n   * Decodes a Store message from the specified reader or buffer.\n   * @function decode\n   * @memberof Store\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {Store} Store\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  Store.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.Store(),\n        key,\n        value;\n\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          if (message.binCounts === $util.emptyObject) message.binCounts = {};\n          var end2 = reader.uint32() + reader.pos;\n          key = 0;\n          value = 0;\n\n          while (reader.pos < end2) {\n            var tag2 = reader.uint32();\n\n            switch (tag2 >>> 3) {\n              case 1:\n                key = reader.sint32();\n                break;\n\n              case 2:\n                value = reader.double();\n                break;\n\n              default:\n                reader.skipType(tag2 & 7);\n                break;\n            }\n          }\n\n          message.binCounts[key] = value;\n          break;\n\n        case 2:\n          if (!(message.contiguousBinCounts && message.contiguousBinCounts.length)) message.contiguousBinCounts = [];\n\n          if ((tag & 7) === 2) {\n            var end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) message.contiguousBinCounts.push(reader.double());\n          } else message.contiguousBinCounts.push(reader.double());\n\n          break;\n\n        case 3:\n          message.contiguousBinIndexOffset = reader.sint32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n  /**\n   * Decodes a Store message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof Store\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {Store} Store\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  Store.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n    return this.decode(reader, reader.uint32());\n  };\n  /**\n   * Verifies a Store message.\n   * @function verify\n   * @memberof Store\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n\n\n  Store.verify = function verify(message) {\n    if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n    if (message.binCounts != null && message.hasOwnProperty(\"binCounts\")) {\n      if (!$util.isObject(message.binCounts)) return \"binCounts: object expected\";\n      var key = Object.keys(message.binCounts);\n\n      for (var i = 0; i < key.length; ++i) {\n        if (!$util.key32Re.test(key[i])) return \"binCounts: integer key{k:sint32} expected\";\n        if (typeof message.binCounts[key[i]] !== \"number\") return \"binCounts: number{k:sint32} expected\";\n      }\n    }\n\n    if (message.contiguousBinCounts != null && message.hasOwnProperty(\"contiguousBinCounts\")) {\n      if (!Array.isArray(message.contiguousBinCounts)) return \"contiguousBinCounts: array expected\";\n\n      for (var i = 0; i < message.contiguousBinCounts.length; ++i) if (typeof message.contiguousBinCounts[i] !== \"number\") return \"contiguousBinCounts: number[] expected\";\n    }\n\n    if (message.contiguousBinIndexOffset != null && message.hasOwnProperty(\"contiguousBinIndexOffset\")) if (!$util.isInteger(message.contiguousBinIndexOffset)) return \"contiguousBinIndexOffset: integer expected\";\n    return null;\n  };\n  /**\n   * Creates a Store message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Store\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {Store} Store\n   */\n\n\n  Store.fromObject = function fromObject(object) {\n    if (object instanceof $root.Store) return object;\n    var message = new $root.Store();\n\n    if (object.binCounts) {\n      if (typeof object.binCounts !== \"object\") throw TypeError(\".Store.binCounts: object expected\");\n      message.binCounts = {};\n\n      for (var keys = Object.keys(object.binCounts), i = 0; i < keys.length; ++i) message.binCounts[keys[i]] = Number(object.binCounts[keys[i]]);\n    }\n\n    if (object.contiguousBinCounts) {\n      if (!Array.isArray(object.contiguousBinCounts)) throw TypeError(\".Store.contiguousBinCounts: array expected\");\n      message.contiguousBinCounts = [];\n\n      for (var i = 0; i < object.contiguousBinCounts.length; ++i) message.contiguousBinCounts[i] = Number(object.contiguousBinCounts[i]);\n    }\n\n    if (object.contiguousBinIndexOffset != null) message.contiguousBinIndexOffset = object.contiguousBinIndexOffset | 0;\n    return message;\n  };\n  /**\n   * Creates a plain object from a Store message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Store\n   * @static\n   * @param {Store} message Store\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n\n\n  Store.toObject = function toObject(message, options) {\n    if (!options) options = {};\n    var object = {};\n    if (options.arrays || options.defaults) object.contiguousBinCounts = [];\n    if (options.objects || options.defaults) object.binCounts = {};\n    if (options.defaults) object.contiguousBinIndexOffset = 0;\n    var keys2;\n\n    if (message.binCounts && (keys2 = Object.keys(message.binCounts)).length) {\n      object.binCounts = {};\n\n      for (var j = 0; j < keys2.length; ++j) object.binCounts[keys2[j]] = options.json && !isFinite(message.binCounts[keys2[j]]) ? String(message.binCounts[keys2[j]]) : message.binCounts[keys2[j]];\n    }\n\n    if (message.contiguousBinCounts && message.contiguousBinCounts.length) {\n      object.contiguousBinCounts = [];\n\n      for (var j = 0; j < message.contiguousBinCounts.length; ++j) object.contiguousBinCounts[j] = options.json && !isFinite(message.contiguousBinCounts[j]) ? String(message.contiguousBinCounts[j]) : message.contiguousBinCounts[j];\n    }\n\n    if (message.contiguousBinIndexOffset != null && message.hasOwnProperty(\"contiguousBinIndexOffset\")) object.contiguousBinIndexOffset = message.contiguousBinIndexOffset;\n    return object;\n  };\n  /**\n   * Converts this Store to JSON.\n   * @function toJSON\n   * @memberof Store\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n\n\n  Store.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n  };\n\n  return Store;\n}();\n\nmodule.exports = $root;","map":{"version":3,"names":["$protobuf","require","$Reader","Reader","$Writer","Writer","$util","util","$root","roots","DDSketch","properties","keys","Object","i","length","prototype","mapping","positiveValues","negativeValues","zeroCount","create","encode","message","writer","hasOwnProperty","call","IndexMapping","uint32","fork","ldelim","Store","double","encodeDelimited","decode","reader","end","undefined","len","pos","tag","skipType","decodeDelimited","verify","error","fromObject","object","TypeError","Number","toObject","options","defaults","json","isFinite","String","toJSON","constructor","toJSONOptions","gamma","indexOffset","interpolation","int32","enums","Interpolation","valuesById","values","binCounts","contiguousBinCounts","emptyObject","emptyArray","contiguousBinIndexOffset","sint32","key","value","end2","tag2","push","isObject","key32Re","test","Array","isArray","isInteger","arrays","objects","keys2","j","module","exports"],"sources":["/Users/daniel.calderon/Projects/barkito/barkito_front/node_modules/@datadog/sketches-js/dist/ddsketch/proto/compiled.js"],"sourcesContent":["/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\n\"use strict\";\nvar $protobuf = require(\"protobufjs/minimal\");\n// Common aliases\nvar $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;\n// Exported root namespace\nvar $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n$root.DDSketch = (function () {\n    /**\n     * Properties of a DDSketch.\n     * @exports IDDSketch\n     * @interface IDDSketch\n     * @property {IIndexMapping|null} [mapping] DDSketch mapping\n     * @property {IStore|null} [positiveValues] DDSketch positiveValues\n     * @property {IStore|null} [negativeValues] DDSketch negativeValues\n     * @property {number|null} [zeroCount] DDSketch zeroCount\n     */\n    /**\n     * Constructs a new DDSketch.\n     * @exports DDSketch\n     * @classdesc Represents a DDSketch.\n     * @implements IDDSketch\n     * @constructor\n     * @param {IDDSketch=} [properties] Properties to set\n     */\n    function DDSketch(properties) {\n        if (properties)\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * DDSketch mapping.\n     * @member {IIndexMapping|null|undefined} mapping\n     * @memberof DDSketch\n     * @instance\n     */\n    DDSketch.prototype.mapping = null;\n    /**\n     * DDSketch positiveValues.\n     * @member {IStore|null|undefined} positiveValues\n     * @memberof DDSketch\n     * @instance\n     */\n    DDSketch.prototype.positiveValues = null;\n    /**\n     * DDSketch negativeValues.\n     * @member {IStore|null|undefined} negativeValues\n     * @memberof DDSketch\n     * @instance\n     */\n    DDSketch.prototype.negativeValues = null;\n    /**\n     * DDSketch zeroCount.\n     * @member {number} zeroCount\n     * @memberof DDSketch\n     * @instance\n     */\n    DDSketch.prototype.zeroCount = 0;\n    /**\n     * Creates a new DDSketch instance using the specified properties.\n     * @function create\n     * @memberof DDSketch\n     * @static\n     * @param {IDDSketch=} [properties] Properties to set\n     * @returns {DDSketch} DDSketch instance\n     */\n    DDSketch.create = function create(properties) {\n        return new DDSketch(properties);\n    };\n    /**\n     * Encodes the specified DDSketch message. Does not implicitly {@link DDSketch.verify|verify} messages.\n     * @function encode\n     * @memberof DDSketch\n     * @static\n     * @param {IDDSketch} message DDSketch message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    DDSketch.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.mapping != null && Object.hasOwnProperty.call(message, \"mapping\"))\n            $root.IndexMapping.encode(message.mapping, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();\n        if (message.positiveValues != null && Object.hasOwnProperty.call(message, \"positiveValues\"))\n            $root.Store.encode(message.positiveValues, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();\n        if (message.negativeValues != null && Object.hasOwnProperty.call(message, \"negativeValues\"))\n            $root.Store.encode(message.negativeValues, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();\n        if (message.zeroCount != null && Object.hasOwnProperty.call(message, \"zeroCount\"))\n            writer.uint32(/* id 4, wireType 1 =*/ 33).double(message.zeroCount);\n        return writer;\n    };\n    /**\n     * Encodes the specified DDSketch message, length delimited. Does not implicitly {@link DDSketch.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof DDSketch\n     * @static\n     * @param {IDDSketch} message DDSketch message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    DDSketch.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes a DDSketch message from the specified reader or buffer.\n     * @function decode\n     * @memberof DDSketch\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {DDSketch} DDSketch\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    DDSketch.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.DDSketch();\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.mapping = $root.IndexMapping.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.positiveValues = $root.Store.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.negativeValues = $root.Store.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.zeroCount = reader.double();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    /**\n     * Decodes a DDSketch message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof DDSketch\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {DDSketch} DDSketch\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    DDSketch.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies a DDSketch message.\n     * @function verify\n     * @memberof DDSketch\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    DDSketch.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.mapping != null && message.hasOwnProperty(\"mapping\")) {\n            var error = $root.IndexMapping.verify(message.mapping);\n            if (error)\n                return \"mapping.\" + error;\n        }\n        if (message.positiveValues != null && message.hasOwnProperty(\"positiveValues\")) {\n            var error = $root.Store.verify(message.positiveValues);\n            if (error)\n                return \"positiveValues.\" + error;\n        }\n        if (message.negativeValues != null && message.hasOwnProperty(\"negativeValues\")) {\n            var error = $root.Store.verify(message.negativeValues);\n            if (error)\n                return \"negativeValues.\" + error;\n        }\n        if (message.zeroCount != null && message.hasOwnProperty(\"zeroCount\"))\n            if (typeof message.zeroCount !== \"number\")\n                return \"zeroCount: number expected\";\n        return null;\n    };\n    /**\n     * Creates a DDSketch message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof DDSketch\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {DDSketch} DDSketch\n     */\n    DDSketch.fromObject = function fromObject(object) {\n        if (object instanceof $root.DDSketch)\n            return object;\n        var message = new $root.DDSketch();\n        if (object.mapping != null) {\n            if (typeof object.mapping !== \"object\")\n                throw TypeError(\".DDSketch.mapping: object expected\");\n            message.mapping = $root.IndexMapping.fromObject(object.mapping);\n        }\n        if (object.positiveValues != null) {\n            if (typeof object.positiveValues !== \"object\")\n                throw TypeError(\".DDSketch.positiveValues: object expected\");\n            message.positiveValues = $root.Store.fromObject(object.positiveValues);\n        }\n        if (object.negativeValues != null) {\n            if (typeof object.negativeValues !== \"object\")\n                throw TypeError(\".DDSketch.negativeValues: object expected\");\n            message.negativeValues = $root.Store.fromObject(object.negativeValues);\n        }\n        if (object.zeroCount != null)\n            message.zeroCount = Number(object.zeroCount);\n        return message;\n    };\n    /**\n     * Creates a plain object from a DDSketch message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof DDSketch\n     * @static\n     * @param {DDSketch} message DDSketch\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    DDSketch.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        var object = {};\n        if (options.defaults) {\n            object.mapping = null;\n            object.positiveValues = null;\n            object.negativeValues = null;\n            object.zeroCount = 0;\n        }\n        if (message.mapping != null && message.hasOwnProperty(\"mapping\"))\n            object.mapping = $root.IndexMapping.toObject(message.mapping, options);\n        if (message.positiveValues != null && message.hasOwnProperty(\"positiveValues\"))\n            object.positiveValues = $root.Store.toObject(message.positiveValues, options);\n        if (message.negativeValues != null && message.hasOwnProperty(\"negativeValues\"))\n            object.negativeValues = $root.Store.toObject(message.negativeValues, options);\n        if (message.zeroCount != null && message.hasOwnProperty(\"zeroCount\"))\n            object.zeroCount = options.json && !isFinite(message.zeroCount) ? String(message.zeroCount) : message.zeroCount;\n        return object;\n    };\n    /**\n     * Converts this DDSketch to JSON.\n     * @function toJSON\n     * @memberof DDSketch\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    DDSketch.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n    return DDSketch;\n})();\n$root.IndexMapping = (function () {\n    /**\n     * Properties of an IndexMapping.\n     * @exports IIndexMapping\n     * @interface IIndexMapping\n     * @property {number|null} [gamma] IndexMapping gamma\n     * @property {number|null} [indexOffset] IndexMapping indexOffset\n     * @property {IndexMapping.Interpolation|null} [interpolation] IndexMapping interpolation\n     */\n    /**\n     * Constructs a new IndexMapping.\n     * @exports IndexMapping\n     * @classdesc Represents an IndexMapping.\n     * @implements IIndexMapping\n     * @constructor\n     * @param {IIndexMapping=} [properties] Properties to set\n     */\n    function IndexMapping(properties) {\n        if (properties)\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * IndexMapping gamma.\n     * @member {number} gamma\n     * @memberof IndexMapping\n     * @instance\n     */\n    IndexMapping.prototype.gamma = 0;\n    /**\n     * IndexMapping indexOffset.\n     * @member {number} indexOffset\n     * @memberof IndexMapping\n     * @instance\n     */\n    IndexMapping.prototype.indexOffset = 0;\n    /**\n     * IndexMapping interpolation.\n     * @member {IndexMapping.Interpolation} interpolation\n     * @memberof IndexMapping\n     * @instance\n     */\n    IndexMapping.prototype.interpolation = 0;\n    /**\n     * Creates a new IndexMapping instance using the specified properties.\n     * @function create\n     * @memberof IndexMapping\n     * @static\n     * @param {IIndexMapping=} [properties] Properties to set\n     * @returns {IndexMapping} IndexMapping instance\n     */\n    IndexMapping.create = function create(properties) {\n        return new IndexMapping(properties);\n    };\n    /**\n     * Encodes the specified IndexMapping message. Does not implicitly {@link IndexMapping.verify|verify} messages.\n     * @function encode\n     * @memberof IndexMapping\n     * @static\n     * @param {IIndexMapping} message IndexMapping message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    IndexMapping.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.gamma != null && Object.hasOwnProperty.call(message, \"gamma\"))\n            writer.uint32(/* id 1, wireType 1 =*/ 9).double(message.gamma);\n        if (message.indexOffset != null && Object.hasOwnProperty.call(message, \"indexOffset\"))\n            writer.uint32(/* id 2, wireType 1 =*/ 17).double(message.indexOffset);\n        if (message.interpolation != null && Object.hasOwnProperty.call(message, \"interpolation\"))\n            writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.interpolation);\n        return writer;\n    };\n    /**\n     * Encodes the specified IndexMapping message, length delimited. Does not implicitly {@link IndexMapping.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof IndexMapping\n     * @static\n     * @param {IIndexMapping} message IndexMapping message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    IndexMapping.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes an IndexMapping message from the specified reader or buffer.\n     * @function decode\n     * @memberof IndexMapping\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {IndexMapping} IndexMapping\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    IndexMapping.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.IndexMapping();\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.gamma = reader.double();\n                    break;\n                case 2:\n                    message.indexOffset = reader.double();\n                    break;\n                case 3:\n                    message.interpolation = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    /**\n     * Decodes an IndexMapping message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof IndexMapping\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {IndexMapping} IndexMapping\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    IndexMapping.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies an IndexMapping message.\n     * @function verify\n     * @memberof IndexMapping\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    IndexMapping.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.gamma != null && message.hasOwnProperty(\"gamma\"))\n            if (typeof message.gamma !== \"number\")\n                return \"gamma: number expected\";\n        if (message.indexOffset != null && message.hasOwnProperty(\"indexOffset\"))\n            if (typeof message.indexOffset !== \"number\")\n                return \"indexOffset: number expected\";\n        if (message.interpolation != null && message.hasOwnProperty(\"interpolation\"))\n            switch (message.interpolation) {\n                default:\n                    return \"interpolation: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                    break;\n            }\n        return null;\n    };\n    /**\n     * Creates an IndexMapping message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof IndexMapping\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {IndexMapping} IndexMapping\n     */\n    IndexMapping.fromObject = function fromObject(object) {\n        if (object instanceof $root.IndexMapping)\n            return object;\n        var message = new $root.IndexMapping();\n        if (object.gamma != null)\n            message.gamma = Number(object.gamma);\n        if (object.indexOffset != null)\n            message.indexOffset = Number(object.indexOffset);\n        switch (object.interpolation) {\n            case \"NONE\":\n            case 0:\n                message.interpolation = 0;\n                break;\n            case \"LINEAR\":\n            case 1:\n                message.interpolation = 1;\n                break;\n            case \"QUADRATIC\":\n            case 2:\n                message.interpolation = 2;\n                break;\n            case \"CUBIC\":\n            case 3:\n                message.interpolation = 3;\n                break;\n        }\n        return message;\n    };\n    /**\n     * Creates a plain object from an IndexMapping message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof IndexMapping\n     * @static\n     * @param {IndexMapping} message IndexMapping\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    IndexMapping.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        var object = {};\n        if (options.defaults) {\n            object.gamma = 0;\n            object.indexOffset = 0;\n            object.interpolation = options.enums === String ? \"NONE\" : 0;\n        }\n        if (message.gamma != null && message.hasOwnProperty(\"gamma\"))\n            object.gamma = options.json && !isFinite(message.gamma) ? String(message.gamma) : message.gamma;\n        if (message.indexOffset != null && message.hasOwnProperty(\"indexOffset\"))\n            object.indexOffset = options.json && !isFinite(message.indexOffset) ? String(message.indexOffset) : message.indexOffset;\n        if (message.interpolation != null && message.hasOwnProperty(\"interpolation\"))\n            object.interpolation = options.enums === String ? $root.IndexMapping.Interpolation[message.interpolation] : message.interpolation;\n        return object;\n    };\n    /**\n     * Converts this IndexMapping to JSON.\n     * @function toJSON\n     * @memberof IndexMapping\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    IndexMapping.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n    /**\n     * Interpolation enum.\n     * @name IndexMapping.Interpolation\n     * @enum {number}\n     * @property {number} NONE=0 NONE value\n     * @property {number} LINEAR=1 LINEAR value\n     * @property {number} QUADRATIC=2 QUADRATIC value\n     * @property {number} CUBIC=3 CUBIC value\n     */\n    IndexMapping.Interpolation = (function () {\n        var valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"NONE\"] = 0;\n        values[valuesById[1] = \"LINEAR\"] = 1;\n        values[valuesById[2] = \"QUADRATIC\"] = 2;\n        values[valuesById[3] = \"CUBIC\"] = 3;\n        return values;\n    })();\n    return IndexMapping;\n})();\n$root.Store = (function () {\n    /**\n     * Properties of a Store.\n     * @exports IStore\n     * @interface IStore\n     * @property {Object.<string,number>|null} [binCounts] Store binCounts\n     * @property {Array.<number>|null} [contiguousBinCounts] Store contiguousBinCounts\n     * @property {number|null} [contiguousBinIndexOffset] Store contiguousBinIndexOffset\n     */\n    /**\n     * Constructs a new Store.\n     * @exports Store\n     * @classdesc Represents a Store.\n     * @implements IStore\n     * @constructor\n     * @param {IStore=} [properties] Properties to set\n     */\n    function Store(properties) {\n        this.binCounts = {};\n        this.contiguousBinCounts = [];\n        if (properties)\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * Store binCounts.\n     * @member {Object.<string,number>} binCounts\n     * @memberof Store\n     * @instance\n     */\n    Store.prototype.binCounts = $util.emptyObject;\n    /**\n     * Store contiguousBinCounts.\n     * @member {Array.<number>} contiguousBinCounts\n     * @memberof Store\n     * @instance\n     */\n    Store.prototype.contiguousBinCounts = $util.emptyArray;\n    /**\n     * Store contiguousBinIndexOffset.\n     * @member {number} contiguousBinIndexOffset\n     * @memberof Store\n     * @instance\n     */\n    Store.prototype.contiguousBinIndexOffset = 0;\n    /**\n     * Creates a new Store instance using the specified properties.\n     * @function create\n     * @memberof Store\n     * @static\n     * @param {IStore=} [properties] Properties to set\n     * @returns {Store} Store instance\n     */\n    Store.create = function create(properties) {\n        return new Store(properties);\n    };\n    /**\n     * Encodes the specified Store message. Does not implicitly {@link Store.verify|verify} messages.\n     * @function encode\n     * @memberof Store\n     * @static\n     * @param {IStore} message Store message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Store.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.binCounts != null && Object.hasOwnProperty.call(message, \"binCounts\"))\n            for (var keys = Object.keys(message.binCounts), i = 0; i < keys.length; ++i)\n                writer.uint32(/* id 1, wireType 2 =*/ 10).fork().uint32(/* id 1, wireType 0 =*/ 8).sint32(keys[i]).uint32(/* id 2, wireType 1 =*/ 17).double(message.binCounts[keys[i]]).ldelim();\n        if (message.contiguousBinCounts != null && message.contiguousBinCounts.length) {\n            writer.uint32(/* id 2, wireType 2 =*/ 18).fork();\n            for (var i = 0; i < message.contiguousBinCounts.length; ++i)\n                writer.double(message.contiguousBinCounts[i]);\n            writer.ldelim();\n        }\n        if (message.contiguousBinIndexOffset != null && Object.hasOwnProperty.call(message, \"contiguousBinIndexOffset\"))\n            writer.uint32(/* id 3, wireType 0 =*/ 24).sint32(message.contiguousBinIndexOffset);\n        return writer;\n    };\n    /**\n     * Encodes the specified Store message, length delimited. Does not implicitly {@link Store.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof Store\n     * @static\n     * @param {IStore} message Store message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Store.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes a Store message from the specified reader or buffer.\n     * @function decode\n     * @memberof Store\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {Store} Store\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Store.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Store(), key, value;\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (message.binCounts === $util.emptyObject)\n                        message.binCounts = {};\n                    var end2 = reader.uint32() + reader.pos;\n                    key = 0;\n                    value = 0;\n                    while (reader.pos < end2) {\n                        var tag2 = reader.uint32();\n                        switch (tag2 >>> 3) {\n                            case 1:\n                                key = reader.sint32();\n                                break;\n                            case 2:\n                                value = reader.double();\n                                break;\n                            default:\n                                reader.skipType(tag2 & 7);\n                                break;\n                        }\n                    }\n                    message.binCounts[key] = value;\n                    break;\n                case 2:\n                    if (!(message.contiguousBinCounts && message.contiguousBinCounts.length))\n                        message.contiguousBinCounts = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.contiguousBinCounts.push(reader.double());\n                    }\n                    else\n                        message.contiguousBinCounts.push(reader.double());\n                    break;\n                case 3:\n                    message.contiguousBinIndexOffset = reader.sint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    /**\n     * Decodes a Store message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof Store\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {Store} Store\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Store.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies a Store message.\n     * @function verify\n     * @memberof Store\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    Store.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.binCounts != null && message.hasOwnProperty(\"binCounts\")) {\n            if (!$util.isObject(message.binCounts))\n                return \"binCounts: object expected\";\n            var key = Object.keys(message.binCounts);\n            for (var i = 0; i < key.length; ++i) {\n                if (!$util.key32Re.test(key[i]))\n                    return \"binCounts: integer key{k:sint32} expected\";\n                if (typeof message.binCounts[key[i]] !== \"number\")\n                    return \"binCounts: number{k:sint32} expected\";\n            }\n        }\n        if (message.contiguousBinCounts != null && message.hasOwnProperty(\"contiguousBinCounts\")) {\n            if (!Array.isArray(message.contiguousBinCounts))\n                return \"contiguousBinCounts: array expected\";\n            for (var i = 0; i < message.contiguousBinCounts.length; ++i)\n                if (typeof message.contiguousBinCounts[i] !== \"number\")\n                    return \"contiguousBinCounts: number[] expected\";\n        }\n        if (message.contiguousBinIndexOffset != null && message.hasOwnProperty(\"contiguousBinIndexOffset\"))\n            if (!$util.isInteger(message.contiguousBinIndexOffset))\n                return \"contiguousBinIndexOffset: integer expected\";\n        return null;\n    };\n    /**\n     * Creates a Store message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof Store\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {Store} Store\n     */\n    Store.fromObject = function fromObject(object) {\n        if (object instanceof $root.Store)\n            return object;\n        var message = new $root.Store();\n        if (object.binCounts) {\n            if (typeof object.binCounts !== \"object\")\n                throw TypeError(\".Store.binCounts: object expected\");\n            message.binCounts = {};\n            for (var keys = Object.keys(object.binCounts), i = 0; i < keys.length; ++i)\n                message.binCounts[keys[i]] = Number(object.binCounts[keys[i]]);\n        }\n        if (object.contiguousBinCounts) {\n            if (!Array.isArray(object.contiguousBinCounts))\n                throw TypeError(\".Store.contiguousBinCounts: array expected\");\n            message.contiguousBinCounts = [];\n            for (var i = 0; i < object.contiguousBinCounts.length; ++i)\n                message.contiguousBinCounts[i] = Number(object.contiguousBinCounts[i]);\n        }\n        if (object.contiguousBinIndexOffset != null)\n            message.contiguousBinIndexOffset = object.contiguousBinIndexOffset | 0;\n        return message;\n    };\n    /**\n     * Creates a plain object from a Store message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Store\n     * @static\n     * @param {Store} message Store\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    Store.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        var object = {};\n        if (options.arrays || options.defaults)\n            object.contiguousBinCounts = [];\n        if (options.objects || options.defaults)\n            object.binCounts = {};\n        if (options.defaults)\n            object.contiguousBinIndexOffset = 0;\n        var keys2;\n        if (message.binCounts && (keys2 = Object.keys(message.binCounts)).length) {\n            object.binCounts = {};\n            for (var j = 0; j < keys2.length; ++j)\n                object.binCounts[keys2[j]] = options.json && !isFinite(message.binCounts[keys2[j]]) ? String(message.binCounts[keys2[j]]) : message.binCounts[keys2[j]];\n        }\n        if (message.contiguousBinCounts && message.contiguousBinCounts.length) {\n            object.contiguousBinCounts = [];\n            for (var j = 0; j < message.contiguousBinCounts.length; ++j)\n                object.contiguousBinCounts[j] = options.json && !isFinite(message.contiguousBinCounts[j]) ? String(message.contiguousBinCounts[j]) : message.contiguousBinCounts[j];\n        }\n        if (message.contiguousBinIndexOffset != null && message.hasOwnProperty(\"contiguousBinIndexOffset\"))\n            object.contiguousBinIndexOffset = message.contiguousBinIndexOffset;\n        return object;\n    };\n    /**\n     * Converts this Store to JSON.\n     * @function toJSON\n     * @memberof Store\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    Store.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n    return Store;\n})();\nmodule.exports = $root;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}