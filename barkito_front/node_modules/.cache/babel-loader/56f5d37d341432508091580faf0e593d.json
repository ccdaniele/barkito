{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.scan = void 0;\n\nconst crypto = require(\"crypto\");\n\nconst fs = require(\"fs\");\n\nconst path = require(\"path\"); // TODO: Make this more precise.\n\n\nconst findit = require('findit2'); // TODO: Make this more precise.\n\n\nconst split = require('split');\n\nclass ScanResultsImpl {\n  /**\n   * Encapsulates the results of a filesystem scan with methods\n   * to easily select scan information or filenames for a\n   * specific subset of the files listed in the scan results.\n   *\n   * @param stats An object that contains filenames\n   *  as keys where each key maps to an object containing the\n   *  hash and number of lines for the specified file.  This\n   *  information is accessed via the `hash` and `lines`\n   *  attributes respectively\n   * @param hash A hashcode computed from the contents of all the files.\n   */\n  constructor(stats, errorMap, hash) {\n    this.stats = stats;\n    this.errorMap = errorMap;\n    this.hash = hash;\n  }\n\n  errors() {\n    return this.errorMap;\n  }\n  /**\n   * Used to get all of the file scan results.\n   */\n\n\n  all() {\n    return this.stats;\n  }\n  /**\n   * Used to get the only the file paths in the scan results\n   * where the filenames match the specified regex and are\n   * returned with the each relative to the specified base\n   * directory.\n   *\n   * @param {regex} regex The regex that tests a filename to\n   *  determine if the scan results for that filename should\n   *  be included in the returned results.\n   * @param {string} baseDir The absolute path to the directory\n   *  from which all of the returned paths should be relative\n   *  to.\n   */\n\n\n  selectFiles(regex, baseDir) {\n    // ensure the base directory has only a single trailing path separator\n    baseDir = path.normalize(baseDir + path.sep);\n    return Object.keys(this.stats).filter(file => {\n      return file && regex.test(file);\n    }).map(file => {\n      return path.normalize(file).replace(baseDir, '');\n    });\n  }\n\n}\n\nasync function scan(shouldHash, baseDir, regex) {\n  const fileList = await findFiles(baseDir, regex);\n  return computeStats(fileList, shouldHash);\n}\n\nexports.scan = scan;\n/**\n * This function accept an array of filenames and computes a unique hash-code\n * based on the contents.\n *\n * @param {!Array<string>} fileList array of filenames\n * @param {Boolean} shouldHash whether a hash should be computed\n * @param {!function(?Error, ?string, Object)} callback error-back style callback\n *    returning the hash-code and an object containing file statistics.\n */\n// TODO: Typescript: Fix the docs associated with this function to match the\n// call signature\n\nfunction computeStats(fileList, shouldHash) {\n  // eslint-disable-next-line no-async-promise-executor\n  return new Promise(async resolve => {\n    // return a valid, if fake, result when there are no js files to hash.\n    if (fileList.length === 0) {\n      resolve(new ScanResultsImpl({}, new Map(), 'EMPTY-no-js-files'));\n      return;\n    } // TODO: Address the case where the array contains `undefined`.\n\n\n    const hashes = [];\n    const statistics = {};\n    const errors = new Map();\n\n    for (const filename of fileList) {\n      try {\n        const fileStats = await statsForFile(filename, shouldHash);\n\n        if (shouldHash) {\n          hashes.push(fileStats.hash);\n        }\n\n        statistics[filename] = fileStats;\n      } catch (err) {\n        errors.set(filename, err);\n      }\n    }\n\n    let hash;\n\n    if (shouldHash) {\n      // Sort the hashes to get a deterministic order as the files may\n      // not be in the same order each time we scan the disk.\n      const buffer = hashes.sort().join();\n      const sha1 = crypto.createHash('sha1').update(buffer).digest('hex');\n      hash = 'SHA1-' + sha1;\n    }\n\n    resolve(new ScanResultsImpl(statistics, errors, hash));\n  });\n}\n/**\n * Given a base-directory, this function scans the subtree and finds all the js\n * files. .git and node_module subdirectories are ignored.\n * @param {!string} baseDir top-level directory to scan\n * @param {!regex} regex the regular expression that specifies the types of\n *  files to find based on their filename\n * @param {!function(?Error, Array<string>)} callback error-back callback\n */\n\n\nfunction findFiles(baseDir, regex) {\n  return new Promise((resolve, reject) => {\n    let error;\n\n    if (!baseDir) {\n      reject(new Error('hasher.findJSFiles requires a baseDir argument'));\n      return;\n    }\n\n    const find = findit(baseDir);\n    const fileList = [];\n    find.on('error', err => {\n      error = err;\n      return;\n    });\n    find.on('directory', (dir, ignore, stop) => {\n      const base = path.basename(dir);\n\n      if (base === '.git' || base === 'node_modules') {\n        stop(); // do not descend\n      }\n    });\n    find.on('file', file => {\n      if (regex.test(file)) {\n        fileList.push(file);\n      }\n    });\n    find.on('end', () => {\n      // Note: the `end` event fires even after an error\n      if (error) {\n        reject(error);\n      } else {\n        resolve(fileList);\n      }\n    });\n  });\n}\n/**\n * Compute a sha hash for the given file and record line counts along the way.\n * @param {string} filename\n * @param {Boolean} shouldHash whether a hash should be computed\n * @param {function} cb errorback style callback which returns the sha string\n * @private\n */\n\n\nfunction statsForFile(filename, shouldHash) {\n  return new Promise((resolve, reject) => {\n    const reader = fs.createReadStream(filename);\n    reader.on('error', err => {\n      reject(err);\n    });\n    reader.on('open', () => {\n      let shasum;\n\n      if (shouldHash) {\n        shasum = crypto.createHash('sha1');\n      }\n\n      let lines = 0;\n      let error;\n      const byLine = reader.pipe(split());\n      byLine.on('error', e => {\n        error = e;\n      });\n      byLine.on('data', d => {\n        if (shouldHash) {\n          shasum.update(d);\n        }\n\n        lines++;\n      });\n      byLine.on('end', () => {\n        if (error) {\n          reject(error);\n        } else {\n          const hash = shouldHash ? shasum.digest('hex') : undefined;\n          resolve({\n            hash,\n            lines\n          });\n        }\n      });\n    });\n  });\n}","map":{"version":3,"mappings":"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","names":["findit","require","split","ScanResultsImpl","constructor","stats","errorMap","hash","errors","all","selectFiles","regex","baseDir","path","normalize","sep","Object","keys","filter","file","test","map","replace","scan","shouldHash","fileList","findFiles","computeStats","exports","Promise","resolve","length","Map","hashes","statistics","filename","fileStats","statsForFile","push","err","set","buffer","sort","join","sha1","crypto","createHash","update","digest","reject","error","Error","find","on","dir","ignore","stop","base","basename","reader","fs","createReadStream","shasum","lines","byLine","pipe","e","d","undefined"],"sources":["../../../../../../ts/third_party/cloud-debug-nodejs/src/agent/io/scanner.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}