{"ast":null,"code":"'use strict';\n\nconst log = require('./log');\n\nconst format = require('./format');\n\nconst {\n  SpanStatsProcessor\n} = require('./span_stats');\n\nconst startedSpans = new WeakSet();\nconst finishedSpans = new WeakSet();\n\nclass SpanProcessor {\n  constructor(exporter, prioritySampler, config) {\n    this._exporter = exporter;\n    this._prioritySampler = prioritySampler;\n    this._config = config;\n    this._stats = new SpanStatsProcessor(config);\n  }\n\n  process(span) {\n    const spanContext = span.context();\n    const active = [];\n    const formatted = [];\n    const trace = spanContext._trace;\n    const {\n      flushMinSpans\n    } = this._config;\n    const {\n      started,\n      finished\n    } = trace;\n\n    if (started.length === finished.length || finished.length >= flushMinSpans) {\n      this._prioritySampler.sample(spanContext);\n\n      for (const span of started) {\n        if (span._duration !== undefined) {\n          const formattedSpan = format(span);\n\n          this._stats.onSpanFinished(formattedSpan);\n\n          formatted.push(formattedSpan);\n        } else {\n          active.push(span);\n        }\n      }\n\n      if (formatted.length !== 0 && trace.isRecording !== false) {\n        this._exporter.export(formatted);\n      }\n\n      this._erase(trace, active);\n    }\n  }\n\n  _erase(trace, active) {\n    if (process.env.DD_TRACE_EXPERIMENTAL_STATE_TRACKING === 'true') {\n      const started = new Set();\n      const startedIds = new Set();\n      const finished = new Set();\n      const finishedIds = new Set();\n\n      for (const span of trace.finished) {\n        const context = span.context();\n        const id = context.toSpanId();\n\n        if (finished.has(span)) {\n          log.error(`Span was already finished in the same trace: ${span}`);\n        } else {\n          finished.add(span);\n\n          if (finishedIds.has(id)) {\n            log.error(`Another span with the same ID was already finished in the same trace: ${span}`);\n          } else {\n            finishedIds.add(id);\n          }\n\n          if (context._trace !== trace) {\n            log.error(`A span was finished in the wrong trace: ${span}.`);\n          }\n\n          if (finishedSpans.has(span)) {\n            log.error(`Span was already finished in a different trace: ${span}`);\n          } else {\n            finishedSpans.add(span);\n          }\n        }\n      }\n\n      for (const span of trace.started) {\n        const context = span.context();\n        const id = context.toSpanId();\n\n        if (started.has(span)) {\n          log.error(`Span was already started in the same trace: ${span}`);\n        } else {\n          started.add(span);\n\n          if (startedIds.has(id)) {\n            log.error(`Another span with the same ID was already started in the same trace: ${span}`);\n          } else {\n            startedIds.add(id);\n          }\n\n          if (context._trace !== trace) {\n            log.error(`A span was started in the wrong trace: ${span}.`);\n          }\n\n          if (startedSpans.has(span)) {\n            log.error(`Span was already started in a different trace: ${span}`);\n          } else {\n            startedSpans.add(span);\n          }\n        }\n\n        if (!finished.has(span)) {\n          log.error(`Span started in one trace but was finished in another trace: ${span}`);\n        }\n      }\n\n      for (const span of trace.finished) {\n        if (!started.has(span)) {\n          log.error(`Span finished in one trace but was started in another trace: ${span}`);\n        }\n      }\n    }\n\n    for (const span of trace.finished) {\n      span.context()._tags = {};\n    }\n\n    trace.started = active;\n    trace.finished = [];\n  }\n\n}\n\nmodule.exports = SpanProcessor;","map":{"version":3,"names":["log","require","format","SpanStatsProcessor","startedSpans","WeakSet","finishedSpans","SpanProcessor","constructor","exporter","prioritySampler","config","_exporter","_prioritySampler","_config","_stats","process","span","spanContext","context","active","formatted","trace","_trace","flushMinSpans","started","finished","length","sample","_duration","undefined","formattedSpan","onSpanFinished","push","isRecording","export","_erase","env","DD_TRACE_EXPERIMENTAL_STATE_TRACKING","Set","startedIds","finishedIds","id","toSpanId","has","error","add","_tags","module","exports"],"sources":["/Users/daniel.calderon/Projects/barkito/barkito_front/node_modules/dd-trace/packages/dd-trace/src/span_processor.js"],"sourcesContent":["'use strict'\n\nconst log = require('./log')\nconst format = require('./format')\n\nconst { SpanStatsProcessor } = require('./span_stats')\n\nconst startedSpans = new WeakSet()\nconst finishedSpans = new WeakSet()\n\nclass SpanProcessor {\n  constructor (exporter, prioritySampler, config) {\n    this._exporter = exporter\n    this._prioritySampler = prioritySampler\n    this._config = config\n\n    this._stats = new SpanStatsProcessor(config)\n  }\n\n  process (span) {\n    const spanContext = span.context()\n    const active = []\n    const formatted = []\n    const trace = spanContext._trace\n    const { flushMinSpans } = this._config\n    const { started, finished } = trace\n\n    if (started.length === finished.length || finished.length >= flushMinSpans) {\n      this._prioritySampler.sample(spanContext)\n\n      for (const span of started) {\n        if (span._duration !== undefined) {\n          const formattedSpan = format(span)\n          this._stats.onSpanFinished(formattedSpan)\n          formatted.push(formattedSpan)\n        } else {\n          active.push(span)\n        }\n      }\n\n      if (formatted.length !== 0 && trace.isRecording !== false) {\n        this._exporter.export(formatted)\n      }\n\n      this._erase(trace, active)\n    }\n  }\n\n  _erase (trace, active) {\n    if (process.env.DD_TRACE_EXPERIMENTAL_STATE_TRACKING === 'true') {\n      const started = new Set()\n      const startedIds = new Set()\n      const finished = new Set()\n      const finishedIds = new Set()\n\n      for (const span of trace.finished) {\n        const context = span.context()\n        const id = context.toSpanId()\n\n        if (finished.has(span)) {\n          log.error(`Span was already finished in the same trace: ${span}`)\n        } else {\n          finished.add(span)\n\n          if (finishedIds.has(id)) {\n            log.error(`Another span with the same ID was already finished in the same trace: ${span}`)\n          } else {\n            finishedIds.add(id)\n          }\n\n          if (context._trace !== trace) {\n            log.error(`A span was finished in the wrong trace: ${span}.`)\n          }\n\n          if (finishedSpans.has(span)) {\n            log.error(`Span was already finished in a different trace: ${span}`)\n          } else {\n            finishedSpans.add(span)\n          }\n        }\n      }\n\n      for (const span of trace.started) {\n        const context = span.context()\n        const id = context.toSpanId()\n\n        if (started.has(span)) {\n          log.error(`Span was already started in the same trace: ${span}`)\n        } else {\n          started.add(span)\n\n          if (startedIds.has(id)) {\n            log.error(`Another span with the same ID was already started in the same trace: ${span}`)\n          } else {\n            startedIds.add(id)\n          }\n\n          if (context._trace !== trace) {\n            log.error(`A span was started in the wrong trace: ${span}.`)\n          }\n\n          if (startedSpans.has(span)) {\n            log.error(`Span was already started in a different trace: ${span}`)\n          } else {\n            startedSpans.add(span)\n          }\n        }\n\n        if (!finished.has(span)) {\n          log.error(`Span started in one trace but was finished in another trace: ${span}`)\n        }\n      }\n\n      for (const span of trace.finished) {\n        if (!started.has(span)) {\n          log.error(`Span finished in one trace but was started in another trace: ${span}`)\n        }\n      }\n    }\n\n    for (const span of trace.finished) {\n      span.context()._tags = {}\n    }\n\n    trace.started = active\n    trace.finished = []\n  }\n}\n\nmodule.exports = SpanProcessor\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}